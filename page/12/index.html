<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"txing-casia.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":240,"display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="中国科学院自动化研究所 | 泛用类人决战型机器人博士">
<meta property="og:type" content="website">
<meta property="og:title" content="Txing">
<meta property="og:url" content="https://txing-casia.github.io/page/12/index.html">
<meta property="og:site_name" content="Txing">
<meta property="og:description" content="中国科学院自动化研究所 | 泛用类人决战型机器人博士">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Txing">
<meta property="article:tag" content="Txing">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://txing-casia.github.io/page/12/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Txing</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Txing</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">欢迎来到 | 伽蓝之堂</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://txing-casia.github.io/2021/04/07/2021-04-07-Q144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86-%E4%B8%AD%E7%AD%89-%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/my_photo.jpg">
      <meta itemprop="name" content="Txing">
      <meta itemprop="description" content="中国科学院自动化研究所 | 泛用类人决战型机器人博士">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Txing">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/07/2021-04-07-Q144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86-%E4%B8%AD%E7%AD%89-%E6%A0%91/" class="post-title-link" itemprop="url">Q144-二叉树的前序遍历-中等-树</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-07 00:00:00" itemprop="dateCreated datePublished" datetime="2021-04-07T00:00:00+08:00">2021-04-07</time>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>2.2k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>2 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="二叉树的前序遍历"><a
target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144.
二叉树的前序遍历</a></h4>
<h2 id="question">Question</h2>
<blockquote>
<p>给你二叉树的根节点 <code>root</code> ，返回它节点值的
<strong>前序</strong> 遍历。</p>
</blockquote>
<blockquote>
<p><strong>Example 1:</strong></p>
<p>输入：root = [1,null,2,3] 输出：[1,2,3]</p>
</blockquote>
<blockquote>
<p><strong>Example 2:</strong></p>
<p>输入：root = [] 输出：[]</p>
</blockquote>
<blockquote>
<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目在范围 [0, 100] 内</li>
<li>-100 &lt;= Node.val &lt;= 100</li>
</ul>
</blockquote>
<blockquote>
<p><strong>进阶：</strong>
递归算法很简单，你可以通过迭代算法完成吗？</p>
</blockquote>
<h3 id="approach-1-递归">Approach 1: 递归</h3>
<p><strong>思路与算法</strong></p>
<p>首先我们需要了解什么是二叉树的前序遍历：按照访问根节点——左子树——右子树的方式遍历这棵树，而在访问左子树或者右子树的时候，我们按照同样的方式遍历，直到遍历完整棵树。因此整个遍历过程天然具有递归的性质，我们可以直接用递归函数来模拟这一过程。</p>
<p>定义 preorder(root) 表示当前遍历到 root
节点的答案。按照定义，我们只要首先将 root 节点的值加入答案，然后递归调用
preorder(root.left) 来遍历 root 节点的左子树，最后递归调用
preorder(root.right) 来遍历 root
节点的右子树即可，递归终止的条件为碰到空节点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">preorder</span>(<span class="params">root: TreeNode</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            res.append(root.val)</span><br><span class="line">            preorder(root.left)</span><br><span class="line">            preorder(root.right)</span><br><span class="line">        </span><br><span class="line">        res = <span class="built_in">list</span>()</span><br><span class="line">        preorder(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：<span class="math display">\[O(n)\]</span>，其中 n
是二叉树的节点数。每一个节点恰好被遍历一次。</li>
<li>空间复杂度：<span
class="math display">\[O(n)\]</span>，为递归过程中栈的开销，平均情况下为
<span class="math display">\[O(\log
n)\]</span>，最坏情况下树呈现链状，为 <span
class="math display">\[O(n)\]</span>。</li>
</ul>
<h3 id="approach-2-迭代">Approach 2: 迭代</h3>
<p>我们也可以用迭代的方式实现方法一的递归函数，两种方式是等价的，区别在于递归的时候隐式地维护了一个栈，而我们在迭代的时候需要显式地将这个栈模拟出来，其余的实现与细节都相同，具体可以参考下面的代码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">        stack = []</span><br><span class="line">        node = root</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> node:</span><br><span class="line">            <span class="keyword">while</span> node:</span><br><span class="line">                res.append(node.val)</span><br><span class="line">                stack.append(node)</span><br><span class="line">                node = node.left</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            node = node.right</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n)，其中 n
是二叉树的节点数。每一个节点恰好被遍历一次。</li>
<li>空间复杂度：O(n)，为迭代过程中显式栈的开销，平均情况下为
O(logn)，最坏情况下树呈现链状，为 O(n)。</li>
</ul>
<h3 id="approach-3-morris-遍历">Approach 3: Morris 遍历</h3>
<p>有一种巧妙的方法可以在线性时间内，只占用常数空间来实现前序遍历。这种方法由
J. H. Morris 在 1979 年的论文「Traversing Binary Trees Simply and
Cheaply」中首次提出，因此被称为 Morris 遍历。</p>
<p>Morris
遍历的核心思想是利用树的大量空闲指针，实现空间开销的极限缩减。其前序遍历规则总结如下：</p>
<ul>
<li><p>新建临时节点，令该节点为 root；</p></li>
<li><p>如果当前节点的左子节点为空，将当前节点加入答案，并遍历当前节点的右子节点；</p></li>
<li><p>如果当前节点的左子节点不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点：</p>
<ul>
<li>如果前驱节点的右子节点为空，将前驱节点的右子节点设置为当前节点。然后将当前节点加入答案，并将前驱节点的右子节点更新为当前节点。当前节点更新为当前节点的左子节点。</li>
<li>如果前驱节点的右子节点为当前节点，将它的右子节点重新设为空。当前节点更新为当前节点的右子节点。</li>
</ul></li>
<li><p>重复步骤 2 和步骤 3，直到遍历结束。</p></li>
</ul>
<p>这样我们利用 Morris
遍历的方法，前序遍历该二叉树，即可实现线性时间与常数空间的遍历。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">        p1 = root</span><br><span class="line">        <span class="keyword">while</span> p1:</span><br><span class="line">            p2 = p1.left</span><br><span class="line">            <span class="keyword">if</span> p2:</span><br><span class="line">                <span class="keyword">while</span> p2.right <span class="keyword">and</span> p2.right != p1:</span><br><span class="line">                    p2 = p2.right</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> p2.right:</span><br><span class="line">                    res.append(p1.val)</span><br><span class="line">                    p2.right = p1</span><br><span class="line">                    p1 = p1.left</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    p2.right = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(p1.val)</span><br><span class="line">            p1 = p1.right</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n)，其中 n
是二叉树的节点数。没有左子树的节点只被访问一次，有左子树的节点被访问两次。</li>
<li>空间复杂度：O(1)。只操作已经存在的指针（树的空闲指针），因此只需要常数的额外空间。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://txing-casia.github.io/2021/04/06/2021-04-06-Q25-K%20%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8-%E5%9B%B0%E9%9A%BE-%E9%93%BE%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/my_photo.jpg">
      <meta itemprop="name" content="Txing">
      <meta itemprop="description" content="中国科学院自动化研究所 | 泛用类人决战型机器人博士">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Txing">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/06/2021-04-06-Q25-K%20%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8-%E5%9B%B0%E9%9A%BE-%E9%93%BE%E8%A1%A8/" class="post-title-link" itemprop="url">Q25-K 个一组翻转链表-困难-链表</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-06 00:00:00" itemprop="dateCreated datePublished" datetime="2021-04-06T00:00:00+08:00">2021-04-06</time>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>1.8k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>2 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="k-个一组翻转链表"><a
target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">25. K
个一组翻转链表</a></h4>
<h2 id="question">Question</h2>
<blockquote>
<p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p>
<p>k 是一个正整数，它的值小于或等于链表的长度。</p>
<p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<p><strong>进阶：</strong></p>
<p>你可以设计一个只使用常数额外空间的算法来解决此问题吗？
你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p>
</blockquote>
<blockquote>
<p><strong>Example 1:</strong></p>
<p>输入：head = [1,2,3,4,5], k = 2 输出：[2,1,4,3,5]</p>
</blockquote>
<blockquote>
<p><strong>Example 2:</strong></p>
<p>输入：head = [1,2,3,4,5], k = 3 输出：[3,2,1,4,5]</p>
</blockquote>
<blockquote>
<p><strong>Example 3:</strong></p>
<p>输入：head = [1,2,3,4,5], k = 1 输出：[1,2,3,4,5]</p>
</blockquote>
<blockquote>
<p><strong>提示：</strong></p>
<ul>
<li>列表中节点的数量在范围 sz 内</li>
<li>1 &lt;= sz &lt;= 5000</li>
<li>0 &lt;= Node.val &lt;= 1000</li>
<li>1 &lt;= k &lt;= sz</li>
</ul>
</blockquote>
<h3 id="approach-1-自顶向下归并排序">Approach 1: 自顶向下归并排序</h3>
<p>思路与算法</p>
<p>本题的目标非常清晰易懂，不涉及复杂的算法，但是实现过程中需要考虑的细节比较多，容易写出冗长的代码。主要考查面试者设计的能力。</p>
<p>我们需要把链表节点按照 k 个一组分组，所以可以使用一个指针 head
依次指向每组的头节点。这个指针每次向前移动 k
步，直至链表结尾。对于每个分组，我们先判断它的长度是否大于等于
k。若是，我们就翻转这部分链表，否则不需要翻转。</p>
<p>接下来的问题就是如何翻转一个分组内的子链表。翻转一个链表并不难，过程可以参考「206.
反转链表」。但是对于一个子链表，除了翻转其本身之外，还需要将子链表的头部与上一个子链表连接，以及子链表的尾部与下一个子链表连接。</p>
<p>因此，在翻转子链表的时候，我们不仅需要子链表头节点 head，还需要有
head 的上一个节点 pre，以便翻转完后把子链表再接回 pre。</p>
<p>但是对于第一个子链表，它的头节点 head 前面是没有节点 pre
的。太麻烦了！难道只能特判了吗？答案是否定的。没有条件，我们就创造条件；没有节点，我们就创建一个节点。我们新建一个节点，把它接到链表的头部，让它作为
pre 的初始值，这样 head
前面就有了一个节点，我们就可以避开链表头部的边界条件。这么做还有一个好处，下面我们会看到。</p>
<p>反复移动指针 head 与 pre，对 head
所指向的子链表进行翻转，直到结尾，我们就得到了答案。下面我们该返回函数值了。</p>
<p>有的同学可能发现这又是一件麻烦事：链表翻转之后，链表的头节点发生了变化，那么应该返回哪个节点呢？照理来说，前
k 个节点翻转之后，链表的头节点应该是第 k
个节点。那么要在遍历过程中记录第 k 个节点吗？但是如果链表里面没有 k
个节点，答案又还是原来的头节点。我们又多了一大堆循环和判断要写，太崩溃了！</p>
<p>等等！还记得我们创建了节点 pre
吗？这个节点一开始被连接到了头节点的前面，而无论之后链表有没有翻转，它的
next
指针都会指向正确的头节点。那么我们只要返回它的下一个节点就好了。至此，问题解决。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="comment"># 翻转一个子链表，并且返回新的头与尾</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">self, head: ListNode, tail: ListNode</span>):</span><br><span class="line">        prev = tail.<span class="built_in">next</span></span><br><span class="line">        p = head</span><br><span class="line">        <span class="keyword">while</span> prev != tail:</span><br><span class="line">            nex = p.<span class="built_in">next</span></span><br><span class="line">            p.<span class="built_in">next</span> = prev</span><br><span class="line">            prev = p</span><br><span class="line">            p = nex</span><br><span class="line">        <span class="keyword">return</span> tail, head</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseKGroup</span>(<span class="params">self, head: ListNode, k: <span class="built_in">int</span></span>) -&gt; ListNode:</span><br><span class="line">        hair = ListNode(<span class="number">0</span>)</span><br><span class="line">        hair.<span class="built_in">next</span> = head</span><br><span class="line">        pre = hair</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            tail = pre</span><br><span class="line">            <span class="comment"># 查看剩余部分长度是否大于等于 k</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">                tail = tail.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> tail:</span><br><span class="line">                    <span class="keyword">return</span> hair.<span class="built_in">next</span></span><br><span class="line">            nex = tail.<span class="built_in">next</span></span><br><span class="line">            head, tail = self.reverse(head, tail)</span><br><span class="line">            <span class="comment"># 把子链表重新接回原链表</span></span><br><span class="line">            pre.<span class="built_in">next</span> = head</span><br><span class="line">            tail.<span class="built_in">next</span> = nex</span><br><span class="line">            pre = tail</span><br><span class="line">            head = tail.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> hair.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：O(n)，其中 n 为链表的长度。head 指针会在 <span
class="math display">\[O(\lfloor \frac{n}{k}
\rfloor)\]</span>个节点上停留，每次停留需要进行一次 O(k)
的翻转操作。</p>
<p>空间复杂度：O(1)，我们只需要建立常数个变量。</p></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://txing-casia.github.io/2021/04/02/2021-04-02-Q148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8-%E4%B8%AD%E7%AD%89-%E9%93%BE%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/my_photo.jpg">
      <meta itemprop="name" content="Txing">
      <meta itemprop="description" content="中国科学院自动化研究所 | 泛用类人决战型机器人博士">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Txing">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/02/2021-04-02-Q148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8-%E4%B8%AD%E7%AD%89-%E9%93%BE%E8%A1%A8/" class="post-title-link" itemprop="url">Q148-排序链表-中等-链表</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-02 00:00:00" itemprop="dateCreated datePublished" datetime="2021-04-02T00:00:00+08:00">2021-04-02</time>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>3.4k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>3 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="排序链表"><a
target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sort-list/">148.
排序链表</a></h4>
<h2 id="question">Question</h2>
<blockquote>
<p>给你链表的头结点 head ，请将其按 <strong>升序</strong> 排列并返回
排序后的链表 。</p>
</blockquote>
<blockquote>
<p><strong>Example 1:</strong></p>
<p>输入：head = [4,2,1,3] 输出：[1,2,3,4]</p>
</blockquote>
<blockquote>
<p><strong>Example 2:</strong></p>
<p>输入：head = [-1,5,3,4,0] 输出：[-1,0,3,4,5]</p>
</blockquote>
<blockquote>
<p><strong>Example 3:</strong></p>
<p>输入：head = [] 输出：[]</p>
</blockquote>
<blockquote>
<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目在范围 [0, 5 * 104] 内</li>
<li>-105 &lt;= Node.val &lt;= 105</li>
</ul>
</blockquote>
<blockquote>
<p><strong>进阶：</strong></p>
<p>你可以在 O(n log n)
时间复杂度和常数级空间复杂度下，对链表进行排序吗？</p>
</blockquote>
<p><strong>前言</strong></p>
<p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/insertion-sort-list/">147.
对链表进行插入排序</a>使用插入排序的方法对链表进行排序，插入排序的时间复杂度是
<span class="math display">\[O(n^2)\]</span>，其中 n
是链表的长度。这道题考虑时间复杂度更低的排序算法。题目的进阶问题要求达到
<span class="math display">\[O(n \log n)\]</span>的 时间复杂度和 <span
class="math display">\[O(1)\]</span> 的空间复杂度，时间复杂度是 <span
class="math display">\[O(n \log n)\]</span>
的排序算法包括归并排序、堆排序和快速排序（快速排序的最差时间复杂度是
<span
class="math display">\[O(n^2)\]</span>，其中最适合链表的排序算法是归并排序。</p>
<p>归并排序基于分治算法。最容易想到的实现方式是自顶向下的递归实现，考虑到递归调用的栈空间，自顶向下归并排序的空间复杂度是
<span class="math display">\[O(\log n)\]</span>。如果要达到 <span
class="math display">\[O(1)\]</span>
的空间复杂度，则需要使用自底向上的实现方式。</p>
<h3 id="approach-1-自顶向下归并排序">Approach 1: 自顶向下归并排序</h3>
<p>对链表自顶向下归并排序的过程如下。</p>
<ul>
<li><p>找到链表的中点，以中点为分界，将链表拆分成两个子链表。寻找链表的中点可以使用快慢指针的做法，快指针每次移动
2 步，慢指针每次移动 1
步，当快指针到达链表末尾时，慢指针指向的链表节点即为链表的中点。</p></li>
<li><p>对两个子链表分别排序。</p></li>
<li><p>将两个排序后的子链表合并，得到完整的排序后的链表。可以使用<a
target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21.
合并两个有序链表</a>的做法，将两个有序的子链表进行合并。</p></li>
</ul>
<p>上述过程可以通过递归实现。递归的终止条件是链表的节点个数小于或等于
1，即当链表为空或者链表只包含 1
个节点时，不需要对链表进行拆分和排序。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">sortFunc</span>(<span class="params">head: ListNode, tail: ListNode</span>) -&gt; ListNode:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">                <span class="keyword">return</span> head</span><br><span class="line">            <span class="keyword">if</span> head.<span class="built_in">next</span> == tail:</span><br><span class="line">                head.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">                <span class="keyword">return</span> head</span><br><span class="line">            slow = fast = head</span><br><span class="line">            <span class="keyword">while</span> fast != tail:</span><br><span class="line">                slow = slow.<span class="built_in">next</span></span><br><span class="line">                fast = fast.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">if</span> fast != tail: <span class="comment"># 快指针每次多走一步</span></span><br><span class="line">                    fast = fast.<span class="built_in">next</span></span><br><span class="line">            mid = slow</span><br><span class="line">            <span class="keyword">return</span> merge(sortFunc(head, mid), sortFunc(mid, tail))</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">head1: ListNode, head2: ListNode</span>) -&gt; ListNode:</span><br><span class="line">            dummyHead = ListNode(<span class="number">0</span>)</span><br><span class="line">            temp, temp1, temp2 = dummyHead, head1, head2</span><br><span class="line">            <span class="keyword">while</span> temp1 <span class="keyword">and</span> temp2:</span><br><span class="line">                <span class="keyword">if</span> temp1.val &lt;= temp2.val:</span><br><span class="line">                    temp.<span class="built_in">next</span> = temp1</span><br><span class="line">                    temp1 = temp1.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    temp.<span class="built_in">next</span> = temp2</span><br><span class="line">                    temp2 = temp2.<span class="built_in">next</span></span><br><span class="line">                temp = temp.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> temp1:</span><br><span class="line">                temp.<span class="built_in">next</span> = temp1</span><br><span class="line">            <span class="keyword">elif</span> temp2:</span><br><span class="line">                temp.<span class="built_in">next</span> = temp2</span><br><span class="line">            <span class="keyword">return</span> dummyHead.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sortFunc(head, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：<span class="math display">\[O(n \log n)\]</span>，其中
n 是链表的长度。</li>
<li>空间复杂度：<span class="math display">\[O(\log n)\]</span>，其中 n
是链表的长度。空间复杂度主要取决于递归调用的栈空间。</li>
</ul>
<h3 id="approach-2-自底向上归并排序">Approach 2: 自底向上归并排序</h3>
<p>使用自底向上的方法实现归并排序，则可以达到 <span
class="math display">\[O(1)\]</span> 的空间复杂度。</p>
<p>首先求得链表的长度 <span
class="math display">\[\textit{length}\]</span>，然后将链表拆分成子链表进行合并。</p>
<p>具体做法如下。</p>
<ul>
<li><p>用 <span class="math display">\[\textit{subLength}\]</span>
表示每次需要排序的子链表的长度，初始时 <span
class="math display">\[\textit{subLength}=1\]</span>。</p></li>
<li><p>每次将链表拆分成若干个长度为 <span
class="math display">\[\textit{subLength}\]</span>
的子链表（最后一个子链表的长度可以小于 <span
class="math display">\[\textit{subLength}\]</span>，按照每两个子链表一组进行合并，合并后即可得到若干个长度为
<span class="math display">\[\textit{subLength} \times 2\]</span>
的有序子链表（最后一个子链表的长度可以小于 <span
class="math display">\[\textit{subLength} \times
2\]</span>）。合并两个子链表仍然使用<a
target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21.
合并两个有序链表</a>的做法。</p></li>
</ul>
<p>将 <span class="math display">\[\textit{subLength}\]</span>
的值加倍，重复第 2
步，对更长的有序子链表进行合并操作，直到有序子链表的长度大于或等于 <span
class="math display">\[\textit{length}\]</span>，整个链表排序完毕。</p>
<p>如何保证每次合并之后得到的子链表都是有序的呢？可以通过数学归纳法证明。</p>
<ul>
<li><p>初始时 <span
class="math display">\[\textit{subLength}=1\]</span>，每个长度为 1
的子链表都是有序的。</p></li>
<li><p>如果每个长度为 <span
class="math display">\[\textit{subLength}\]</span>
的子链表已经有序，合并两个长度为 <span
class="math display">\[\textit{subLength}\]</span>
的有序子链表，得到长度为 <span class="math display">\[\textit{subLength}
\times 2\]</span> 的子链表，一定也是有序的。</p></li>
<li><p>当最后一个子链表的长度小于 <span
class="math display">\[\textit{subLength}\]</span>
时，该子链表也是有序的，合并两个有序子链表之后得到的子链表一定也是有序的。</p></li>
</ul>
<p>因此可以保证最后得到的链表是有序的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">head1: ListNode, head2: ListNode</span>) -&gt; ListNode:</span><br><span class="line">            dummyHead = ListNode(<span class="number">0</span>)</span><br><span class="line">            temp, temp1, temp2 = dummyHead, head1, head2</span><br><span class="line">            <span class="keyword">while</span> temp1 <span class="keyword">and</span> temp2:</span><br><span class="line">                <span class="keyword">if</span> temp1.val &lt;= temp2.val:</span><br><span class="line">                    temp.<span class="built_in">next</span> = temp1</span><br><span class="line">                    temp1 = temp1.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    temp.<span class="built_in">next</span> = temp2</span><br><span class="line">                    temp2 = temp2.<span class="built_in">next</span></span><br><span class="line">                temp = temp.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> temp1:</span><br><span class="line">                temp.<span class="built_in">next</span> = temp1</span><br><span class="line">            <span class="keyword">elif</span> temp2:</span><br><span class="line">                temp.<span class="built_in">next</span> = temp2</span><br><span class="line">            <span class="keyword">return</span> dummyHead.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        </span><br><span class="line">        length = <span class="number">0</span></span><br><span class="line">        node = head</span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            length += <span class="number">1</span></span><br><span class="line">            node = node.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        dummyHead = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        subLength = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> subLength &lt; length:</span><br><span class="line">            prev, curr = dummyHead, dummyHead.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">while</span> curr:</span><br><span class="line">                head1 = curr</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, subLength):</span><br><span class="line">                    <span class="keyword">if</span> curr.<span class="built_in">next</span>:</span><br><span class="line">                        curr = curr.<span class="built_in">next</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                head2 = curr.<span class="built_in">next</span></span><br><span class="line">                curr.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">                curr = head2</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, subLength):</span><br><span class="line">                    <span class="keyword">if</span> curr <span class="keyword">and</span> curr.<span class="built_in">next</span>:</span><br><span class="line">                        curr = curr.<span class="built_in">next</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                </span><br><span class="line">                succ = <span class="literal">None</span></span><br><span class="line">                <span class="keyword">if</span> curr:</span><br><span class="line">                    succ = curr.<span class="built_in">next</span></span><br><span class="line">                    curr.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">                </span><br><span class="line">                merged = merge(head1, head2)</span><br><span class="line">                prev.<span class="built_in">next</span> = merged</span><br><span class="line">                <span class="keyword">while</span> prev.<span class="built_in">next</span>:</span><br><span class="line">                    prev = prev.<span class="built_in">next</span></span><br><span class="line">                curr = succ</span><br><span class="line">            subLength &lt;&lt;= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dummyHead.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：<span class="math display">\[O(n \log n)\]</span>，其中
n 是链表的长度。</li>
<li>空间复杂度：<span class="math display">\[O(1)\]</span>。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://txing-casia.github.io/2021/04/01/2021-04-01-Q92-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%20II-%E4%B8%AD%E7%AD%89-%E9%93%BE%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/my_photo.jpg">
      <meta itemprop="name" content="Txing">
      <meta itemprop="description" content="中国科学院自动化研究所 | 泛用类人决战型机器人博士">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Txing">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/01/2021-04-01-Q92-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%20II-%E4%B8%AD%E7%AD%89-%E9%93%BE%E8%A1%A8/" class="post-title-link" itemprop="url">Q92-反转链表 II-中等-链表</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-01 00:00:00" itemprop="dateCreated datePublished" datetime="2021-04-01T00:00:00+08:00">2021-04-01</time>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>2.1k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>2 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="反转链表-ii"><a
target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">92.
反转链表 II</a></h4>
<h2 id="question">Question</h2>
<blockquote>
<p>给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;=
right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表
。</p>
</blockquote>
<blockquote>
<p><strong>Example 1:</strong></p>
<p>输入：head = [1,2,3,4,5], left = 2, right = 4 输出：[1,4,3,2,5]</p>
</blockquote>
<blockquote>
<p><strong>Example 2:</strong></p>
<p>输入：head = [5], left = 1, right = 1 输出：[5]</p>
</blockquote>
<blockquote>
<p><strong>提示：</strong></p>
<ul>
<li>链表中节点数目为 n</li>
<li>1 &lt;= n &lt;= 500</li>
<li>-500 &lt;= Node.val &lt;= 500</li>
<li>1 &lt;= left &lt;= right &lt;= n</li>
</ul>
</blockquote>
<blockquote>
<p><strong>进阶：</strong> 你可以使用一趟扫描完成反转吗？</p>
</blockquote>
<h3 id="approach-1-穿针引线">Approach 1: 穿针引线</h3>
<p>一定要先想清楚思路，并且必要的时候在草稿纸上画图，理清「穿针引线」的先后步骤，然后再编码。</p>
<p>使用<a
target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-linked-list/">「206.
反转链表」</a>的解法，反转 left 到 right
部分以后，再拼接起来。我们还需要记录 left 的前一个节点，和 right
的后一个节点。</p>
<ul>
<li>第 1 步：先将待反转的区域反转；</li>
<li>第 2 步：把 pre 的 next
指针指向反转以后的链表头节点，把反转以后的链表的尾节点的 next 指针指向
succ。</li>
</ul>
<p>说明：编码细节我们不在题解中介绍了，请见下方代码。思路想明白以后，编码不是一件很难的事情。这里要提醒大家的是，链接什么时候切断，什么时候补上去，先后顺序一定要想清楚，如果想不清楚，可以在纸上模拟，让思路清晰。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseBetween</span>(<span class="params">self, head: ListNode, left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; ListNode:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">reverse_linked_list</span>(<span class="params">head: ListNode</span>):</span><br><span class="line">            <span class="comment"># 也可以使用递归反转一个链表</span></span><br><span class="line">            pre = <span class="literal">None</span></span><br><span class="line">            cur = head</span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                <span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">                cur.<span class="built_in">next</span> = pre</span><br><span class="line">                pre = cur</span><br><span class="line">                cur = <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 因为头节点有可能发生变化，使用虚拟头节点可以避免复杂的分类讨论</span></span><br><span class="line">        dummy_node = ListNode(-<span class="number">1</span>)</span><br><span class="line">        dummy_node.<span class="built_in">next</span> = head</span><br><span class="line">        pre = dummy_node</span><br><span class="line">        <span class="comment"># 第 1 步：从虚拟头节点走 left - 1 步，来到 left 节点的前一个节点</span></span><br><span class="line">        <span class="comment"># 建议写在 for 循环里，语义清晰</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(left - <span class="number">1</span>):</span><br><span class="line">            pre = pre.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第 2 步：从 pre 再走 right - left + 1 步，来到 right 节点</span></span><br><span class="line">        right_node = pre</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(right - left + <span class="number">1</span>):</span><br><span class="line">            right_node = right_node.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 第 3 步：切断出一个子链表（截取链表）</span></span><br><span class="line">        left_node = pre.<span class="built_in">next</span></span><br><span class="line">        curr = right_node.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 注意：切断链接</span></span><br><span class="line">        pre.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        right_node.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第 4 步：同第 206 题，反转链表的子区间</span></span><br><span class="line">        reverse_linked_list(left_node)</span><br><span class="line">        <span class="comment"># 第 5 步：接回到原来的链表中</span></span><br><span class="line">        pre.<span class="built_in">next</span> = right_node</span><br><span class="line">        left_node.<span class="built_in">next</span> = curr</span><br><span class="line">        <span class="keyword">return</span> dummy_node.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(N)，其中
N是链表总节点数。最坏情况下，需要遍历整个链表。</li>
<li>空间复杂度：O(1)。只使用到常数个变量。</li>
</ul>
<h3 id="approach-2-一次遍历穿针引线反转链表头插法">Approach 2:
一次遍历「穿针引线」反转链表（头插法）</h3>
<p>配图解释：https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/fan-zhuan-lian-biao-ii-by-leetcode-solut-teyq/</p>
<p>方法一的缺点是：如果 left 和 right
的区域很大，恰好是链表的头节点和尾节点时，找到 left 和 right
需要遍历一次，反转它们之间的链表还需要遍历一次，虽然总的时间复杂度为
O(N)，但遍历了链表 2
次，可不可以只遍历一次呢？答案是可以的。我们依然画图进行说明。</p>
<p>整体思想是：在需要反转的区间里，每遍历到一个节点，让这个新节点来到反转部分的起始位置。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseBetween</span>(<span class="params">self, head: ListNode, left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; ListNode:</span><br><span class="line">        <span class="comment"># 设置 dummyNode 是这一类问题的一般做法</span></span><br><span class="line">        dummy_node = ListNode(-<span class="number">1</span>)</span><br><span class="line">        dummy_node.<span class="built_in">next</span> = head</span><br><span class="line">        pre = dummy_node</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(left - <span class="number">1</span>):</span><br><span class="line">            pre = pre.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        cur = pre.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(right - left):</span><br><span class="line">            <span class="built_in">next</span> = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = <span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="built_in">next</span>.<span class="built_in">next</span> = pre.<span class="built_in">next</span></span><br><span class="line">            pre.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy_node.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(N)，其中 N
是链表总节点数。最多只遍历了链表一次，就完成了反转。</li>
<li>空间复杂度：O(1)。只使用到常数个变量。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://txing-casia.github.io/2021/03/31/2021-03-31-Neuroscience%20-%20Adaptation%20to%20Visuomotor%20Rotation%20Through%20Interaction%20Between%20Posterior/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/my_photo.jpg">
      <meta itemprop="name" content="Txing">
      <meta itemprop="description" content="中国科学院自动化研究所 | 泛用类人决战型机器人博士">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Txing">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/31/2021-03-31-Neuroscience%20-%20Adaptation%20to%20Visuomotor%20Rotation%20Through%20Interaction%20Between%20Posterior/" class="post-title-link" itemprop="url">Neuroscience | Adaptation to Visuomotor Rotation Through Interaction Between Posterior Parietal and Motor Cortical Areas</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-31 00:00:00" itemprop="dateCreated datePublished" datetime="2021-03-31T00:00:00+08:00">2021-03-31</time>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>374</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>1 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1
id="adaptation-to-visuomotor-rotation-through-interaction-between-posterior-parietal-and-motor-cortical-areas">Adaptation
to Visuomotor Rotation Through Interaction Between Posterior Parietal
and Motor Cortical Areas</h1>
<p>论文链接：https://journals.physiology.org/doi/full/10.1152/jn.90834.2008</p>
<h2 id="背景">背景</h2>
<ul>
<li>PPC中有高斯调制的神经元，使其成为适应视觉运动旋转的可能部位。Visually
selective neurons with narrow Gaussian tuning curves have been
identified in posterior parietal cortex, making it a possible site of
adaptation to visuomotor rotation.</li>
</ul>
<h2 id="主要工作">主要工作</h2>
<p>没细看，感觉可以引用。</p>
<p>有些公式需要再仔细研究一下</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://txing-casia.github.io/2021/03/31/2021-03-31-Q82-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%20II-%E4%B8%AD%E7%AD%89-%E9%93%BE%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/my_photo.jpg">
      <meta itemprop="name" content="Txing">
      <meta itemprop="description" content="中国科学院自动化研究所 | 泛用类人决战型机器人博士">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Txing">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/31/2021-03-31-Q82-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%20II-%E4%B8%AD%E7%AD%89-%E9%93%BE%E8%A1%A8/" class="post-title-link" itemprop="url">Q82-删除排序链表中的重复元素 II-中等-链表</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-31 00:00:00" itemprop="dateCreated datePublished" datetime="2021-03-31T00:00:00+08:00">2021-03-31</time>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>2k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>2 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="删除排序链表中的重复元素-ii"><a
target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/">82.
删除排序链表中的重复元素 II</a></h4>
<h2 id="question">Question</h2>
<blockquote>
<p>存在一个按升序排列的链表，给你这个链表的头节点 head
，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中
没有重复出现 的数字。</p>
<p>返回同样按升序排列的结果链表。</p>
</blockquote>
<blockquote>
<p><strong>Example 1:</strong></p>
<p>输入：head = [1,2,3,3,4,4,5] 输出：[1,2,5]</p>
</blockquote>
<blockquote>
<p><strong>Example 2:</strong></p>
<p>输入：head = [7,9,6,6,7,8,3,0,9,5], k = 5
输出：[7,9,6,6,8,7,3,0,9,5]</p>
</blockquote>
<blockquote>
<p><strong>Example 3:</strong></p>
<p>输入：head = [1,1,1,2,3] 输出：[2,3]</p>
</blockquote>
<blockquote>
<p><strong>提示：</strong></p>
<ul>
<li>链表中节点数目在范围 [0, 300] 内</li>
<li>-100 &lt;= Node.val &lt;= 100</li>
<li>题目数据保证链表已经按升序排列</li>
</ul>
</blockquote>
<h3 id="approach-1-顺序遍历搜索">Approach 1: 顺序遍历搜索</h3>
<p>由于链表已经排序，因此要找到链表中重复的数字可以只用对比本节点的值和下一个节点的值，而不需使用HASH表。</p>
<p>注意：</p>
<ul>
<li>头节点可能要修改，需要添加哑头节点；</li>
<li>始终对比 cur.next.val 和
cur.next.next.val，避免要寻找上一个节点；</li>
<li>注意 cur 和 dummy 怎么使用；</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteDuplicates</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        <span class="comment"># 判断链表非空</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="comment"># 头节点可能要修改，需要添加哑头节点</span></span><br><span class="line">        dummy = ListNode([])</span><br><span class="line">        dummy.<span class="built_in">next</span> = head</span><br><span class="line">        cur = dummy</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">and</span> cur.<span class="built_in">next</span>.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.<span class="built_in">next</span>.val == cur.<span class="built_in">next</span>.<span class="built_in">next</span>.val:</span><br><span class="line">                x = cur.<span class="built_in">next</span>.val</span><br><span class="line">                <span class="keyword">while</span> cur.<span class="built_in">next</span> <span class="keyword">and</span> cur.<span class="built_in">next</span>.val == x:</span><br><span class="line">                    cur.<span class="built_in">next</span> = cur.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = cur.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    head = stringToListNode([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line">    solution=Solution().deleteDuplicates(head)</span><br><span class="line">    <span class="built_in">print</span>(solution)</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n)，其中 n 是链表的节点数量</li>
<li>空间复杂度：O(1)，增加了常数个指针。</li>
</ul>
<h3 id="approach-2-递归">Approach 2: 递归</h3>
<p>递归最基本的是要明白递归函数的定义！</p>
<p>递归函数直接使用题目给出的函数 deleteDuplicates(head)
，它的含义是删除以 head 作为开头的有序链表中，值出现重复的节点。</p>
<p>终止条件就是能想到的基本的、不用继续递归处理的case。</p>
<ul>
<li>如果 head 为空，那么肯定没有值出现重复的节点，直接返回 head；</li>
<li>如果 head.next
为空，那么说明链表中只有一个节点，也没有值出现重复的节点，也直接返回
head。</li>
</ul>
<p>什么时候需要递归呢？我们想一下这两种情况：</p>
<ul>
<li>如果 head.val != head.next.val
，说明头节点的值不等于下一个节点的值，所以当前的 head 节点必须保留；但是
head.next 节点要不要保留呢？我们还不知道，需要对 head.next
进行递归，即对 head.next 作为头节点的链表，去除值重复的节点。所以
head.next = self.deleteDuplicates(head.next).</li>
<li>如果 head.val == head.next.val
，说明头节点的值等于下一个节点的值，所以当前的 head 节点必须删除，并且
head 之后所有与 head.val
相等的节点也都需要删除；删除到哪个节点为止呢？需要用 move
指针一直向后遍历寻找到与 head.val 不等的节点。此时 move
之前的节点都不保留了，因此返回 deleteDuplicates(move);</li>
</ul>
<p>题目让我们返回删除了值重复的节点后剩余的链表，结合上面两种递归调用的情况。</p>
<ul>
<li>如果 head.val != head.next.val ，头结点需要保留，因此返回的是
head；</li>
<li>如果 head.val == head.next.val
，头结点需要删除，需要返回的是deleteDuplicates(move);。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deleteDuplicates1</span>(<span class="params">self, head</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        <span class="keyword">if</span> head.val != head.<span class="built_in">next</span>.val:</span><br><span class="line">            head.<span class="built_in">next</span> = self.deleteDuplicates(head.<span class="built_in">next</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            move = head.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">while</span> move <span class="keyword">and</span> head.val == move.val:</span><br><span class="line">                move = move.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> self.deleteDuplicates(move)</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(N)，每个节点访问了一次。</li>
<li>空间复杂度：O(N)，递归调用的时候会用到了系统的栈。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://txing-casia.github.io/2021/03/31/2021-03-31-Neuroscience%20-%20The%20posterior%20parietal%20cortex%20Sensorimotor%20interface%20for%20the%20planning%20and%20online%20control%20of%20visually%20guided%20movements/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/my_photo.jpg">
      <meta itemprop="name" content="Txing">
      <meta itemprop="description" content="中国科学院自动化研究所 | 泛用类人决战型机器人博士">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Txing">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/31/2021-03-31-Neuroscience%20-%20The%20posterior%20parietal%20cortex%20Sensorimotor%20interface%20for%20the%20planning%20and%20online%20control%20of%20visually%20guided%20movements/" class="post-title-link" itemprop="url">Neuroscience | The posterior parietal cortex Sensorimotor interface for the planning and online control of visually guided movements</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-31 00:00:00" itemprop="dateCreated datePublished" datetime="2021-03-31T00:00:00+08:00">2021-03-31</time>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>542</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>1 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1
id="the-posterior-parietal-cortex-sensorimotor-interface-for-the-planning-and-online-control-of-visually-guided-movements">The
posterior parietal cortex: Sensorimotor interface for the planning and
online control of visually guided movements</h1>
<p>论文链接：https://www.sciencedirect.com/science/article/pii/S0028393205003337?via%3Dihub</p>
<h2 id="背景">背景</h2>
<p>后顶叶皮层（PPC）参与构建感觉运动地图</p>
<h2 id="主要工作">主要工作</h2>
<ul>
<li>即对于手臂运动，PPC不仅在将感官信息转换为运动命令所需的逆变换中起作用，而且在“正向”变换中也发挥作用，即在将感觉输入与先前和正在进行的运动命令相集成以维持对手臂状态的连续估计的过程中用于更新当前和将来的移动计划。</li>
<li>PPC参与了感觉运动的转化（R.A. Andersen, G.K. Essick, R.M. Siegel
Neurons of area 7a activated by both visual stimuli and oculomotor
behavior Experimental Brain Research, 67 (1987), pp. 316-322）</li>
</ul>
<h2 id="总结">总结</h2>
<p>这篇文章主要介绍PPC在眼睛坐标系和手臂坐标系之间转换的作用，以及PPC对感觉运动映射的作用，可以参考</p>
<p>但是图片实在是太难看了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://txing-casia.github.io/2021/03/30/2021-03-30-Reinforcement%20Learning%20-%20Sim-to-Real%20Transfer%20in%20Deep%20Reinforcement%20Learning%20for%20Robotics%20a%20Survey/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/my_photo.jpg">
      <meta itemprop="name" content="Txing">
      <meta itemprop="description" content="中国科学院自动化研究所 | 泛用类人决战型机器人博士">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Txing">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/30/2021-03-30-Reinforcement%20Learning%20-%20Sim-to-Real%20Transfer%20in%20Deep%20Reinforcement%20Learning%20for%20Robotics%20a%20Survey/" class="post-title-link" itemprop="url">Reinforcement Learning | Sim-to-Real Transfer in Deep Reinforcement Learning for Robotics a Survey</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-30 00:00:00" itemprop="dateCreated datePublished" datetime="2021-03-30T00:00:00+08:00">2021-03-30</time>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>3.3k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>3 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1
id="sim-to-real-transfer-in-deep-reinforcement-learning-for-robotics-a-survey">Sim-to-Real
Transfer in Deep Reinforcement Learning for Robotics: a Survey</h1>
<p>论文链接：https://ieeexplore.ieee.org/document/9308468</p>
<h2 id="背景">背景</h2>
<ul>
<li><p>真实的机器人数据难以获得，或者成本代价高，因此需要用仿真环境模拟，降低成本，保证安全性。Owing
to the limitations of gathering real-world data, i.e., sample
inefficiency and the cost of collecting it, simulation environments are
utilized for training the different agents</p></li>
<li><p>问题是仿真和真实之间存在差距。Nonetheless, <strong>the gap
between the simulated and real worlds</strong> degrades the performance
of the policies once the models are transferred into real
robots</p></li>
<li><p>主要研究方向：</p>
<ul>
<li>域随机化 domain randomization</li>
<li>域适应 domain adaptation</li>
<li>模仿学习 imitation learning</li>
<li>元学习 meta-learning</li>
<li>知识蒸馏 knowledge distillation</li>
</ul></li>
<li><p>Moreover, learning with real robots requires the consideration of
<strong>potentially dangerous</strong> or <strong>unexpected behaviors
in safety-critical applications</strong> [4]</p></li>
<li><p><strong>关键问题</strong>：如何通过<strong>转移知识</strong>并相应地<strong>调整策略</strong>，在真实环境中利用基于模拟的训练。how
to exploit simulation-based training in real-world settings by
transferring the knowledge and adapting the policies
accordingly</p></li>
<li><p>仿真的设置与真实设置之间有着固有的不匹配。Simulation-based
training provides data at low-cost, but involves <strong>inherent
mismatches</strong> with real-world settings</p></li>
<li><p>一些基于深度学习的相关算法：</p>
<ul>
<li>adversarial attacks on computer vision algorithms [7].</li>
<li>introduce perturbances in the environment [8]</li>
<li>domain randomization [9]</li>
<li>Another key aspect to take into account is that an agent deployed in
the real world will potentially be exposed to novel experiences that
were not present in the simulations [10]</li>
<li>meta learning [11]</li>
<li>continual learning [12]</li>
<li>更好的仿真引擎 physics engines: Airsim [13], CARLA [14], RotorS
[15], [16], and others [17]</li>
</ul></li>
<li><p>安全的强化学习这也是一个方向 safe reinforcement learning
[4]</p></li>
<li><p>几个方向的关系如下图所示：</p></li>
</ul>
<p><img
src="https://raw.githubusercontent.com/txing-casia/txing-casia.github.io/master/img/20210330-1.png" /></p>
<h3 id="a.-deep-reinforcement-learning">A. Deep Reinforcement
Learning</h3>
<ul>
<li>略</li>
</ul>
<h3 id="b.-sim-to-real-transfer">B. Sim-to-Real Transfer</h3>
<ul>
<li>Transferring DRL policies form simulation environments to reality is
a necessary step towards more complex robotic systems that have
DL-defined controllers.</li>
</ul>
<h3 id="c.-transfer-learning-and-domain-adaptation">C. Transfer Learning
and Domain Adaptation</h3>
<ul>
<li><strong>迁移学习</strong>：Transfer learning aims at improving the
performance of target learners on <strong>target domains</strong> by
transferring the knowledge contained in different but related
<strong>source domains</strong> [18]. In this way, transfer learning can
reduce the dependence of target domain data when constructing target
learners.</li>
<li><strong>域适应</strong>：它指定了当我们有足够的源域标记数据和与目标任务相同的单个任务，但没有或很少目标域数据时的情况。It
specifies the situation when we have sufficient source domain labeled
data and the same single task as the target task, but without or very
few target domain data. In sim-to-real robotics, researchers tend to
employ a simulator to train the RL model and then deploy it in the
realistic environment, where we should take advantage of the domain
adaptation techniques in order to transfer the simulation based model
well</li>
</ul>
<h3 id="d.-knowledge-distillation">D. Knowledge Distillation</h3>
<ul>
<li>一般用于大型网络，例如使用视觉图像输入的深层网络</li>
<li>使用网络教另一个网络，这样使得两个网络性能差不多，但是学得更快。In
these set-ups, the two networks are typically called teacher and
student.</li>
</ul>
<h3 id="e.-meta-reinforcement-learning">E. Meta Reinforcement
Learning</h3>
<ul>
<li>通常采用LSTM。MetaRL usually implements an LSTM policy and
incorporates the last reward <span
class="math display">\[r_{t−1}\]</span> and last action <span
class="math display">\[a_{t−1}\]</span> into the current policy
observation</li>
</ul>
<h3 id="f.-robust-rl-and-imitation-learning">F. Robust RL and Imitation
Learning</h3>
<ul>
<li><p>Robust RL [23] was proposed quite early as a new RL paradigm that
explicitly takes into account input disturbances as well as modeling
errors</p></li>
<li><p>It considers a bad, or even adversarial model and tries to
maximize the reward as a optimization problem [24], [25].</p></li>
<li><p><strong>Imitation learning</strong> proposes to employ expert
demonstration or trajectories instead of manually constructing a fixed
reward function to train RL agents.</p>
<ul>
<li><strong>behaviour cloning</strong> where an agent learns a mapping
from observations to actions given demonstrations [26], [27]</li>
<li><strong>inverse reinforcement learning</strong> where an agent
attempts to estimate a reward function that describes the given
demonstrations [28].</li>
</ul></li>
<li><p>机器人导航任务的方法：</p>
<ul>
<li>curriculum learning [37]</li>
<li>incremental environment complexity [39]</li>
<li>continual learning and policy distillation for multiple tasks
[12]</li>
</ul></li>
</ul>
<h2 id="总结">总结</h2>
<p>即时限定在机器人领域，迁移学习也不是一个很具体的范畴。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/11/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><span class="space">&hellip;</span><a class="page-number" href="/page/29/">29</a><a class="extend next" rel="next" href="/page/13/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Txing"
      src="/images/my_photo.jpg">
  <p class="site-author-name" itemprop="name">Txing</p>
  <div class="site-description" itemprop="description">中国科学院自动化研究所 | 泛用类人决战型机器人博士</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">229</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">57</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/txing-casia" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;txing-casia" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://blog.uomi.moe/" title="https:&#x2F;&#x2F;blog.uomi.moe" rel="noopener" target="_blank">驱逐舰患者</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://m.mepai.me/photographyer/u_5a68085ba15aa.html?tdsourcetag=s_pctim_aiomsg" title="https:&#x2F;&#x2F;m.mepai.me&#x2F;photographyer&#x2F;u_5a68085ba15aa.html?tdsourcetag&#x3D;s_pctim_aiomsg" rel="noopener" target="_blank">隐之-INF</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2018 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Txing</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">538k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">8:09</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

</body>
</html>
