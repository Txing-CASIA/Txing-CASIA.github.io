<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"txing-casia.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":240,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="泛用类人决战型机器人博士">
<meta property="og:type" content="website">
<meta property="og:title" content="Txing">
<meta property="og:url" content="https://txing-casia.github.io/page/19/index.html">
<meta property="og:site_name" content="Txing">
<meta property="og:description" content="泛用类人决战型机器人博士">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Txing">
<meta property="article:tag" content="Txing">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://txing-casia.github.io/page/19/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Txing</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Txing</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">欢迎来到 | 伽蓝之堂</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://txing-casia.github.io/2020/09/24/2020-09-24-Neuroscience%20-%20Emergence%20of%20abstract%20rules%20in%20the%20primate%20brain/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Txing">
      <meta itemprop="description" content="泛用类人决战型机器人博士">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Txing">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/24/2020-09-24-Neuroscience%20-%20Emergence%20of%20abstract%20rules%20in%20the%20primate%20brain/" class="post-title-link" itemprop="url">Neuroscience | Emergence of abstract rules in the primate brain (Nature)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-24 00:00:00" itemprop="dateCreated datePublished" datetime="2020-09-24T00:00:00+08:00">2020-09-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-25 09:54:14" itemprop="dateModified" datetime="2023-03-25T09:54:14+08:00">2023-03-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="emergence-of-abstract-rules-in-the-primate-brain">Emergence of
abstract rules in the primate brain</h1>
<p>论文链接：https://www.nature.com/articles/s41583-020-0364-5</p>
<h2 id="背景">背景</h2>
<p>抽象能力帮助学习规则，提升认知和决策能力，帮助避免潜在的环境危险，丰富人的社会行为和互动。</p>
<p>人是如何抽象事物，把经验变成有意义的概念的？本文探索这背后的神经机制。进而揭示前额叶皮质对抽象规则的形成（formation）、维护（maintenance）以及修正（revision）上的作用。</p>
<ul>
<li><p>好处：通过抽象规则，帮助形成adaptive behaviour</p></li>
<li><p>规则的出现是动态多阶段的过程（dynamic multistage processes
），包括rule formation, maintenance and revision</p></li>
<li><p>prefrontal cortex (PFC) is heavily involved in the representation
and implementation of abstract
rules。但只有前额叶皮层的部分区域对学习和实施抽象规则是必要的</p></li>
</ul>
<p><strong>结论：</strong>我们最终提出了一个统一的框架，将抽象规则的形成和执行与认知控制的神经架构联系起来</p>
<p><strong>key words:</strong> rule-guided behaviour</p>
<h2 id="主要工作">主要工作</h2>
<h4 id="rules-definition-and-classification">1 Rules: definition and
classification</h4>
<ul>
<li><p><strong>具体规则</strong>（concrete
rules）描绘了对象、事件与行为之间的简单的时空关系。刺激-响应或者刺激-输出关系。</p>
<p>具体的规则是依赖于经验的，通过大量的积极/消极的尝试逐渐强化形成（The
formation of concrete rules is experience-dependent）</p></li>
<li><p><strong>抽象规则</strong>（abstract
rules）更加复杂和多样。一个特点是他们可以容易地生成新的示例。可能会要求选择性注意力。可以用在不熟悉的环境中的新刺激上。</p>
<p>抽象规则描绘物体、事件和响应的交互和因果关系。用一刺激，目标不同，得到不同的响应。</p></li>
<li><p><strong>Selective attention</strong>: Neural mechanisms involved
in focusing cognitive resources on task-relevant sensoryperceptual
processes and inhibiting goal-irrelevant stimuli to facilitate achieving
goals.</p></li>
</ul>
<h4 id="concrete-and-multifaceted-categories">2 Concrete and
multifaceted categories</h4>
<ul>
<li>对环境刺激分类的能力是天生的或者是依赖经验学习到的experience-dependent
learning<br>
</li>
<li>Multifaceted
categories不取决于单个例子和传感特征，而是使用集成的刺激特征（形状、颜色、声音）。与抽象规则类似，能用于处理新的情况，指导复杂的目标导向的行为</li>
</ul>
<h4 id="abstract-rules-in-primates">3 Abstract rules in primates</h4>
<h4 id="evidence-from-neuronal-recordings">4 Evidence from neuronal
recordings</h4>
<h5 id="matching-and-non-matching-rules">4.1 Matching and non-matching
rules</h5>
<ul>
<li><p>Delayed matching to sample (DMS):
延时匹配规则，给出example和cue，延时一段时间后，选根据cue选择test
picture，要选择更example一致的为正确。</p></li>
<li><p>Delayed non-matching to sample (DNMS):
延时不匹配规则，给出example和cue，延时一段时间后，选根据cue选择test
picture，要选择更example不一致的为正确。</p></li>
<li><p>对猕猴的研究发现抽象规则在DLPFC (dorsolateral prefrontal cortex)
and VLPFC (ventrolateral prefrontal
cortex)被编码，对人的研究发现只在VLPFC</p></li>
</ul>
<h5 id="number-rules">4.2 Number rules</h5>
<ul>
<li><p>让猴子忽略物体的外表，只注意数量的关系</p></li>
<li><p>顶叶皮层的顶内沟编码数字信息 intraparietal sulcus (IPS) of the
parietal cortex encode numerical information</p></li>
</ul>
<h5 id="flexible-shifting-between-rules">4.3 Flexible shifting between
rules</h5>
<ul>
<li>规则上的迁移和变换，以及自己探索未知的规则</li>
</ul>
<h5 id="abstract-response-strategies">4.4 Abstract response
strategies</h5>
<ul>
<li>abstract response strategies<br>
</li>
<li>working memory task（Sakai, K. &amp; Passingham, R. E. Prefrontal
interactions reflect future task operations. Nat. Neurosci. 6, 75–81
(2003). ）</li>
</ul>
<h5 id="interactions-of-rules-and-categories">4.5 Interactions of rules
and categories</h5>
<h5 id="insight-from-neuronal-recordings">4.6Insight from neuronal
recordings</h5>
<ul>
<li>rule-based action selection</li>
</ul>
<h5 id="evidence-from-interventional-studies">4.7 Evidence from
interventional studies</h5>
<h5 id="stages-of-abstract-rule-development">4.8 Stages of abstract rule
development</h5>
<p><img src="https://raw.githubusercontent.com/txing-casia/txing-casia.github.io/master/img/20200924-1.png"></p>
<ul>
<li><p><strong>Rule formation</strong></p>
<ul>
<li><p>纹状体调制：</p>
<ul>
<li>Bunge, S. A. &amp; Wallis, J. D. Neuroscience of RuleGuided Behavior
(Oxford Univ. Press, 2008).<br>
</li>
<li>Nieder, A. &amp; Dehaene, S. Representation of number in the brain.
Annu. Rev. Neurosci. 32, 185–208 (2009).<br>
</li>
<li>Sleezer, B. J., Castagno, M. D. &amp; Hayden, B. Y. Rule encoding in
orbitofrontal cortex and striatum guides selection. J. Neurosci. 36,
11223–11237 (2016).</li>
<li>Sleezer, B. J. &amp; Hayden, B. Y. Differential contributions of
ventral and dorsal striatum to early and late phases of cognitive set
reconfiguration. J. Cogn. Neurosci. 28, 1849–1864 (2016).<br>
</li>
<li>Cools, R., Clark, L. &amp; Robbins, T. W. Differential responses in
human striatum and prefrontal cortex to changes in object and rule
relevance. J. Neurosci. 24, 1129–1135 (2004).</li>
</ul></li>
<li><p>海马调制：</p>
<ul>
<li><p>Zeithamova, D. et al. Brain mechanisms of concept learning. J.
Neurosci. 39, 8259–8266 (2019).</p></li>
<li><p>Bowman, C. R. &amp; Zeithamova, D. Abstract memory
representations in the ventromedial prefrontal cortex and hippocampus
support concept generalization. J. Neurosci. 38, 2605–2614
(2018).</p></li>
<li><p>Murray, E. A. &amp; Wise, S. P. Role of the hippocampus plus
subjacent cortex but not amygdala in visuomotor conditional learning in
rhesus monkeys. Behav. Neurosci. 110, 1261–1270 (1996).</p></li>
<li><p>Orbach, J., Milner, B. &amp; Rasmussen, T. Learning and retention
in monkeys after amygdala–hippocampus resection. Arch. Neurol. 3,
230–251 (1960).</p></li>
<li><p>Owen, A. M., Roberts, A. C., Polkey, C. E., Sahakian, B. J. &amp;
Robbins, T. W. Extra-dimensional versus intra-dimensional set shifting
performance following frontal lobe excisions, temporal lobe excisions or
amygdalo-hippocampectomy in man. Neuropsychologia 29, 993–1006
(1991).</p></li>
</ul></li>
<li><p>抽象规则的学习是依赖于海马和底层皮质。一旦学会动作，基于规则的任务随后的表现成为独立的内侧颞叶。PFC区域和纹状体之间的连接被认为形成了几个互补的并行网络，从而促进了通过反复试验学习规则所需的相互信息交换。</p></li>
<li><p>慢的和目标导向的学习是在大FPC完成的，而快的和强化导向的学习发生在纹状体
（Seger, C. A. &amp; Miller, E. K. Category learning in the brain. Annu.
Rev. Neurosci. 33, 203–219 (2010) ）</p></li>
</ul></li>
<li><p><strong>Rule storage and retrieval</strong></p></li>
<li><p><strong>Rule-guided behaviour</strong></p></li>
</ul>
<h2 id="总结">总结</h2>
<p>这是一篇综述文章，介绍的工作比较偏神经科学的研究。本文介绍了与抽象规则相关的背景、定义、神经基础，主要在PFC附近，这部分不熟悉，以后可以继续调研看看。</p>
<p>有几个关键词可以再去检索一下，看看有没有合适的文章。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://txing-casia.github.io/2020/09/23/2020-09-23-Q617%20Merge%20Two%20Binary%20Trees-%E7%AE%80%E5%8D%95-%E6%B7%B1%E5%BA%A6and%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Txing">
      <meta itemprop="description" content="泛用类人决战型机器人博士">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Txing">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/23/2020-09-23-Q617%20Merge%20Two%20Binary%20Trees-%E7%AE%80%E5%8D%95-%E6%B7%B1%E5%BA%A6and%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/" class="post-title-link" itemprop="url">Q617 Merge Two Binary Trees-简单-深度/广度优先搜索</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-23 00:00:00" itemprop="dateCreated datePublished" datetime="2020-09-23T00:00:00+08:00">2020-09-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-25 09:54:14" itemprop="dateModified" datetime="2023-03-25T09:54:14+08:00">2023-03-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="merge-two-binary-trees"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-two-binary-trees/">Merge
Two Binary Trees</a></h1>
<h2 id="question">Question</h2>
<blockquote>
<p>Given two binary trees and imagine that when you put one of them to
cover the other, some nodes of the two trees are overlapped while the
others are not.</p>
<p>You need to merge them into a new binary tree. The merge rule is that
if two nodes overlap, then sum node values up as the new value of the
merged node. Otherwise, the NOT null node will be used as the node of
new tree.</p>
<p><strong>Note:</strong> The merging process must start from the root
nodes of both trees.</p>
</blockquote>
<blockquote>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">	Tree 1                     Tree 2                  </span><br><span class="line">          1                         2                             </span><br><span class="line">         / \                       / \                            </span><br><span class="line">        3   2                     1   3                        </span><br><span class="line">       /                           \   \                      </span><br><span class="line">      5                             4   7                  </span><br><span class="line">Output: </span><br><span class="line">Merged tree:</span><br><span class="line">	     3</span><br><span class="line">	    / \</span><br><span class="line">	   4   5</span><br><span class="line">	  / \   \ </span><br><span class="line">	 5   4   7</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="approach-1-dfs">Approach 1: DFS</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeTrees</span>(<span class="params">self, t1: TreeNode, t2: TreeNode</span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> t1:</span><br><span class="line">            <span class="keyword">return</span> t2</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> t2:</span><br><span class="line">            <span class="keyword">return</span> t1</span><br><span class="line"></span><br><span class="line">        merged = TreeNode(t1.val + t2.val)</span><br><span class="line">        merged.left = self.mergeTrees(t1.left, t2.left)</span><br><span class="line">        merged.right = self.mergeTrees(t1.right, t2.right)</span><br><span class="line">        <span class="keyword">return</span> merged</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：<span class="math display">\[O(\min(m,n))\]</span>，其中 m 和 n
分别是两个二叉树的节点个数。对两个二叉树同时进行深度优先搜索，只有当两个二叉树中的对应节点都不为空时才会对该节点进行显性合并操作，因此被访问到的节点数不会超过较小的二叉树的节点数。</p></li>
<li><p>空间复杂度：<span class="math display">\[O(\min(m,n))\]</span>，其中 m 和 n
分别是两个二叉树的节点个数。空间复杂度取决于递归调用的层数，递归调用的层数不会超过较小的二叉树的最大高度，最坏情况下，二叉树的高度等于节点数。</p></li>
</ul>
<h2 id="approach-2-bfs">Approach 2: BFS</h2>
<p>也可以使用广度优先搜索合并两个二叉树。首先判断两个二叉树是否为空，如果两个二叉树都为空，则合并后的二叉树也为空，如果只有一个二叉树为空，则合并后的二叉树为另一个非空的二叉树。</p>
<p>如果两个二叉树都不为空，则首先计算合并后的根节点的值，然后从合并后的二叉树与两个原始二叉树的根节点开始广度优先搜索，从根节点开始同时遍历每个二叉树，并将对应的节点进行合并。</p>
<p>使用三个队列分别存储合并后的二叉树的节点以及两个原始二叉树的节点。初始时将每个二叉树的根节点分别加入相应的队列。每次从每个队列中取出一个节点，判断两个原始二叉树的节点的左右子节点是否为空。如果两个原始二叉树的当前节点中至少有一个节点的左子节点不为空，则合并后的二叉树的对应节点的左子节点也不为空。对于右子节点同理。</p>
<p>如果合并后的二叉树的左子节点不为空，则需要根据两个原始二叉树的左子节点计算合并后的二叉树的左子节点以及整个左子树。考虑以下两种情况：</p>
<ul>
<li><p>如果两个原始二叉树的左子节点都不为空，则合并后的二叉树的左子节点的值为两个原始二叉树的左子节点的值之和，在创建合并后的二叉树的左子节点之后，将每个二叉树中的左子节点都加入相应的队列；</p></li>
<li><p>如果两个原始二叉树的左子节点有一个为空，即有一个原始二叉树的左子树为空，则合并后的二叉树的左子树即为另一个原始二叉树的左子树，此时也不需要对非空左子树继续遍历，因此不需要将左子节点加入队列。</p></li>
</ul>
<p>对于右子节点和右子树，处理方法与左子节点和左子树相同。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeTrees</span>(<span class="params">self, t1: TreeNode, t2: TreeNode</span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> t1:</span><br><span class="line">            <span class="keyword">return</span> t2</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> t2:</span><br><span class="line">            <span class="keyword">return</span> t1</span><br><span class="line">        </span><br><span class="line">        merged = TreeNode(t1.val + t2.val)</span><br><span class="line">        queue = collections.deque([merged])</span><br><span class="line">        queue1 = collections.deque([t1])</span><br><span class="line">        queue2 = collections.deque([t2])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> queue1 <span class="keyword">and</span> queue2:</span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            node1 = queue1.popleft()</span><br><span class="line">            node2 = queue2.popleft()</span><br><span class="line">            left1, right1 = node1.left, node1.right</span><br><span class="line">            left2, right2 = node2.left, node2.right</span><br><span class="line">            <span class="keyword">if</span> left1 <span class="keyword">or</span> left2:</span><br><span class="line">                <span class="keyword">if</span> left1 <span class="keyword">and</span> left2:</span><br><span class="line">                    left = TreeNode(left1.val + left2.val)</span><br><span class="line">                    node.left = left</span><br><span class="line">                    queue.append(left)</span><br><span class="line">                    queue1.append(left1)</span><br><span class="line">                    queue2.append(left2)</span><br><span class="line">                <span class="keyword">elif</span> left1:</span><br><span class="line">                    node.left = left1</span><br><span class="line">                <span class="keyword">elif</span> left2:</span><br><span class="line">                    node.left = left2</span><br><span class="line">            <span class="keyword">if</span> right1 <span class="keyword">or</span> right2:</span><br><span class="line">                <span class="keyword">if</span> right1 <span class="keyword">and</span> right2:</span><br><span class="line">                    right = TreeNode(right1.val + right2.val)</span><br><span class="line">                    node.right = right</span><br><span class="line">                    queue.append(right)</span><br><span class="line">                    queue1.append(right1)</span><br><span class="line">                    queue2.append(right2)</span><br><span class="line">                <span class="keyword">elif</span> right1:</span><br><span class="line">                    node.right = right1</span><br><span class="line">                <span class="keyword">elif</span> right2:</span><br><span class="line">                    node.right = right2</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> merged</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：<span class="math display">\[O(\min(m,n))\]</span>，其中 m 和 n
分别是两个二叉树的节点个数。对两个二叉树同时进行广度优先搜索，只有当两个二叉树中的对应节点都不为空时才会访问到该节点，因此被访问到的节点数不会超过较小的二叉树的节点数。</p></li>
<li><p>空间复杂度：<span class="math display">\[O(\min(m,n))\]</span>，其中 m 和 n
分别是两个二叉树的节点个数。空间复杂度取决于队列中的元素个数，队列中的元素个数不会超过较小的二叉树的节点数。</p></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://txing-casia.github.io/2020/09/22/2020-09-22-V-rep%E4%B8%AD%E8%AE%BE%E7%BD%AE%E5%AE%8C%E5%85%A8%E5%8F%AF%E6%8E%A7%E7%9A%84%E7%90%83%E7%8A%B6%E5%85%B3%E8%8A%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Txing">
      <meta itemprop="description" content="泛用类人决战型机器人博士">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Txing">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/22/2020-09-22-V-rep%E4%B8%AD%E8%AE%BE%E7%BD%AE%E5%AE%8C%E5%85%A8%E5%8F%AF%E6%8E%A7%E7%9A%84%E7%90%83%E7%8A%B6%E5%85%B3%E8%8A%82/" class="post-title-link" itemprop="url">V-rep中设置完全可控的球状关节   </a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-22 00:00:00" itemprop="dateCreated datePublished" datetime="2020-09-22T00:00:00+08:00">2020-09-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-25 09:54:14" itemprop="dateModified" datetime="2023-03-25T09:54:14+08:00">2023-03-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="v-rep中设置完全可控的球状关节">V-rep中设置完全可控的球状关节</h1>
<h2 id="背景">背景</h2>
<p>V-rep这软件好是好，就是功能太单一，一切都是对照现有工业机器人的功能进行设计的。因此，软件中无法实现可控的球状关节。</p>
<blockquote>
<p>球关节：右键 - add - joint - spherical</p>
</blockquote>
<p>双击关节图标，可以看到设置界面几乎就没有能设置的地方，该关节类型也被锁死，无法控制。</p>
<p>不仅如此，V-rep中，一个物体不能同时连接多余1个旋转关节。而且关节与物体的连接关系只能是<code>物体1--关节1--物体2--关节2</code>因此也几乎堵死想通过三个正交旋转关节构建球关节的想法。</p>
<p>但真的就没有办法了吗？</p>
<h3 id="plan-a-用小中介物体衔接">PLAN A: 用小中介物体衔接</h3>
<p>该方法是利用三个分别平行于空间坐标轴的正交转动关节来构成球关节。尽管关节和关节之间不能直接连接，但我们可以设置比较小的中间介质来衔接不同的关节。</p>
<p><img src="https://raw.githubusercontent.com/txing-casia/txing-casia.github.io/master/img/20200922-1.png"></p>
<p>关节的层级结构如下：</p>
<p><img src="https://raw.githubusercontent.com/txing-casia/txing-casia.github.io/master/img/20200922-2.png"></p>
<p>下图中则是用两个球体衔接了3个关节，基本上实现了球关节的效果。准确地说是实现了一种“椭球”关节。</p>
<p>但次方法还是存在缺点的。如果设置关节匀速转动会发现关节转动的角度和子物体转动的角度不一致（关节角度&gt;物体角度）。还容易造成关节中轴线的偏移等奇怪的情况。因此这个球关节只是“半可控”状态。</p>
<h3 id="plan-b-修改中介物体属性">PLAN B: 修改中介物体属性</h3>
<p>在后续的学习过程中逐渐接触到了关于物体属性的设置，其中有两项吸引力我的注意力。</p>
<p>新建一个object，点开动力学设置，可以看到两个关键属性：Respondable 和
Dynamic。</p>
<p><img src="https://raw.githubusercontent.com/txing-casia/txing-casia.github.io/master/img/20200922-3.png"></p>
<p>其中：</p>
<ul>
<li>Respondable:
指的是该物体是否是可响应的，这个可响应主要是指碰撞和接触，即使设置不响应，也会受到重力和<strong>关节旋转</strong>影响。</li>
<li>Dynamic:
指的是物体是静态还是动态的。如果设置为静态，物体不受重力影响（<strong>可悬浮</strong>），但仍然是可以判定接触和碰撞的，受到<strong>关节旋转</strong>影响的。</li>
</ul>
<p>注意上面标黑的关键字，你是否想到了我想到的东西？</p>
<p><strong>Step 1:</strong>
首先依然是搭建三个正交的转动关节，只不过这一次不用留出中介物体的空隙了。</p>
<p><img src="https://raw.githubusercontent.com/txing-casia/txing-casia.github.io/master/img/20200922-4.png"></p>
<p><strong>Step 2:</strong>
可是这三个关节在功能上并没有连接上，现在我们添加中介物体。</p>
<p><img src="https://raw.githubusercontent.com/txing-casia/txing-casia.github.io/master/img/20200922-5.png"></p>
<p>在分层视图中，将中介物体拖到平行于z轴的关节下，设置物体的动力学为<strong>is
not Respondable</strong>, <strong>Body is Dynamic</strong></p>
<p>这样物体就通过平行于z轴的关节实现了与父物体的连接，并可以实现水平旋转，接下来设置第二个中介物体。</p>
<p><strong>Step 3:</strong>
单击刚才的中介物（这里取名叫中介物1），<code>ctrl + c</code> and
<code>ctrl + v</code> 建立与中介物1重叠的中介物2，设置其动力学<strong>is
not Respondable</strong>, <strong>Body is not Dynamic</strong></p>
<p>相当于新建了一个基座。在层级视图中将中介物2放到中介物1下方。将第二个关节放在中介物2下方。</p>
<p>并在第二个关节下方房子中介物3（依然与之前的中介物是位置重叠的）。设置物体的动力学为<strong>is
not Respondable</strong>, <strong>Body is Dynamic</strong>。</p>
<p>这里解释一下关系：</p>
<p>第一个关节本质上是带动中介物1转动，由于中介物2挂在中介物1下方，尽管中介物2是不可响应的静态物体，但也会受到父物体转动的影响，这相当于基坐标发生了改变。所以中介物2会受到关节1的控制。</p>
<p>但此时中介物2已经不能再被其它关节控制了。我们在介物2所在的空间位置建立中介物3，并用关节2连接中介物2和3，中介物3是直接受到关节2控制的，但也会受中介物2运动的影响。</p>
<p>这样一来，我们就实现了一个复合关节，接下来重复step3，建立好第三个关节，并把连杆放在第三个关节下。</p>
<p><img src="https://raw.githubusercontent.com/txing-casia/txing-casia.github.io/master/img/20200922-6.png"></p>
<p>这个关节中有4个中介物，并且是完全重合的，但由于设置了is not
Respondable，因此不会受到碰撞的影响，而且还可以将这个关节放置在物体内部，也不会被排挤。</p>
<p>至此，我们就完成了一个真正意义上的完全可控的球形关节！</p>
<p>ohhhhhhhhhhhhhhhhhhhhhhh</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://txing-casia.github.io/2020/09/22/2020-09-22-Q1512%20Number%20of%20Good%20Pairs-%E7%AE%80%E5%8D%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Txing">
      <meta itemprop="description" content="泛用类人决战型机器人博士">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Txing">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/22/2020-09-22-Q1512%20Number%20of%20Good%20Pairs-%E7%AE%80%E5%8D%95/" class="post-title-link" itemprop="url">Q1470 Shuffle the Array-简单</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-22 00:00:00" itemprop="dateCreated datePublished" datetime="2020-09-22T00:00:00+08:00">2020-09-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-25 09:54:14" itemprop="dateModified" datetime="2023-03-25T09:54:14+08:00">2023-03-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="number-of-good-pairs"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-good-pairs/">Number of
Good Pairs</a></h1>
<h2 id="question">Question</h2>
<blockquote>
<p>Given an array of integers nums.</p>
<p>A pair (i,j) is called good if nums[i] == nums[j] and i &lt; j.</p>
<p>Return the number of good pairs.</p>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 100</code></li>
<li><code>1 &lt;= nums[i] &lt;= 100</code></li>
</ul>
</blockquote>
<blockquote>
<p><strong>Example 1:</strong></p>
<p>Input: nums = [1,2,3,1,1,3] Output: 4 Explanation: There are 4 good
pairs (0,3), (0,4), (3,4), (2,5) 0-indexed.</p>
</blockquote>
<blockquote>
<p><strong>Example 2:</strong></p>
<p>Input: nums = [1,1,1,1] Output: 6 Explanation: Each pair in the array
are good.</p>
</blockquote>
<blockquote>
<p><strong>Example 3:</strong></p>
<p>Input: nums = [1,2,3] Output: 0</p>
</blockquote>
<h3 id="approach-1-循环嵌套">Approach 1: 循环嵌套</h3>
<p>过于简单，直接上代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numIdenticalPairs</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        n=<span class="built_in">len</span>(nums)</span><br><span class="line">        ans=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,n):</span><br><span class="line">                <span class="keyword">if</span> nums[i]==nums[j]:</span><br><span class="line">                    ans+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    nums =[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line">    solution=Solution().numIdenticalPairs(nums)</span><br><span class="line">    <span class="built_in">print</span>(solution)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：<span class="math display">\[O(\frac{N(N+1)}{2})\]</span></p></li>
<li><p>空间复杂度：O(1)</p></li>
</ul>
<h2 id="approach-2-组合计数">Approach 2: 组合计数</h2>
<p>用哈希表统计每个数在序列中出现的次数，假设数字 k 在序列中出现的次数为
v，那么满足题目中所说的 <span class="math display">\[{\rm nums}[i] =
{\rm nums}[j] = k(i &lt; j)\]</span> 的 <span class="math display">\[(i,
j)\]</span> 的数量就是 <span class="math display">\[\frac{v(v - 1)}{2}
\]</span>，即 k 这个数值对答案的贡献是 <span class="math display">\[\frac{v(v -
1)}{2}\]</span>。我们只需要把所有数值的贡献相加，即可得到答案。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numIdenticalPairs</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m = collections.Counter(nums)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(v * (v - <span class="number">1</span>) // <span class="number">2</span> <span class="keyword">for</span> k, v <span class="keyword">in</span> m.items())</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O<em>(</em>n)。</li>
<li>空间复杂度：O<em>(</em>n)，即哈希表使用到的辅助空间的空间代价。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://txing-casia.github.io/2020/09/21/2020-09-21-Neuroscience%20-%20Principles%20of%20Temporal%20Processing%20Across%20the%20Cortical%20Hierarchy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Txing">
      <meta itemprop="description" content="泛用类人决战型机器人博士">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Txing">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/21/2020-09-21-Neuroscience%20-%20Principles%20of%20Temporal%20Processing%20Across%20the%20Cortical%20Hierarchy/" class="post-title-link" itemprop="url">Neuroscience | Principles of Temporal Processing Across the Cortical Hierarchy</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-21 00:00:00" itemprop="dateCreated datePublished" datetime="2020-09-21T00:00:00+08:00">2020-09-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-25 09:54:14" itemprop="dateModified" datetime="2023-03-25T09:54:14+08:00">2023-03-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="principles-of-temporal-processing-across-the-cortical-hierarchy">Principles
of Temporal Processing Across the Cortical Hierarchy</h1>
<p>论文链接：https://www.sciencedirect.com/science/article/pii/S0306452218302951?via%3Dihub</p>
<h2 id="背景">背景</h2>
<p>生活中存在着许多的时间和空间的尺度。对于空间结构的表现，在网络中通常是以Pooling，normalization，以及pattern
completion的形式呈现。这些操作可以改变空间上的尺度，形成对空间鲁棒的识别能力。这篇文章回顾了一些列的时间上操作的研究，帮助理解temporal
polling，temporal normalization，以及temporal pattern completion。</p>
<ul>
<li>Pooling：建立高维的表征，形成对输入的鲁棒的缩放和转换</li>
<li>normalization：增强特征选择以及输入的鲁棒性</li>
<li>pattern completion：降低噪声和缺失数据的影响</li>
</ul>
<p>如果空间上的这些操作能够帮助开展高效的不同尺度的分析，那么类似的，时间上的操作应该也能帮助对时间的结构分析。</p>
<h2 id="主要工作">主要工作</h2>
<ul>
<li><p>分层的大脑结构是通过语言、听觉、视觉任务来发现的。</p></li>
<li><p>三个问题：</p>
<ul>
<li>如何在功能层面定义时间操作；</li>
<li>操作在皮层中实施的神经基础是什么；</li>
<li>该操作被迭代的运用在多个皮层层级上吗；</li>
</ul></li>
</ul>
<h3 id="时间上的信息处理原则">时间上的信息处理原则</h3>
<h4 id="pooling-in-space-and-time">1.1 Pooling in space and time</h4>
<ul>
<li><p>pooling可以看做是一个"sum" or "max" operation，产生high-level
representations</p></li>
<li><p>方法：</p>
<ul>
<li>定义窗口宽度<span class="math display">\[\tau\]</span></li>
<li>在<span class="math display">\[[t-\tau,t]\]</span>的时间内发生了激活，则输出激活信号。</li>
</ul></li>
<li><p>允许了精确的输入时间</p></li>
<li><p>生物证据：神经元的兴奋通过突出调节，在数秒至数小时内累积并持续（Kukushkin
NV, Carew TJ (2017) Memory takes time. Neuron 95(2):259–279）</p></li>
</ul>
<h4 id="normalization-in-space-and-time">1.2 Normalization in space and
time</h4>
<ul>
<li>神经系统需要非线性操作来增加刺激的选择性响应和抑制过度激活（A
feedforward architecture accounts for rapid categorization. Proc Natl
Acad Sci 104 (15):6424–642）</li>
<li>空间Normalization是根据其他具有相似选择性的神经元收到的输入重新调整其响应的过程</li>
</ul>
<p><span class="math display">\[
R_j=\gamma \bigg(\frac{D^n_i}{\sigma^n+\sum_k D^n_k}\bigg)
\]</span> 神经元<span class="math display">\[j\]</span>的响应 <span class="math display">\[R_j\]</span> ，<span class="math display">\[D_i\]</span> 是输入信号<span class="math display">\[\gamma\]</span>是乘法尺度系数，<span class="math display">\[\sigma\]</span>是形状系数，<span class="math display">\[n\]</span>决定了非线性的程度。这个公式是“winner-take-all”
mechanism: all neuralu units will be normalized to zero, except the unit
thatr eceives the largest input drive.</p>
<ul>
<li><p>Normalization in time</p></li>
<li><p><strong>neuronal adaptation</strong>: the tendency of a neuron to
decrease its response to a stimulus, when that stimulus was previously
presented within some time window.</p></li>
<li><p>temporal normalization can improve <strong>neuronal sensitivity
to sequential patterns</strong>, and make them robust to changes in
input gain .</p></li>
<li><p><strong>pop-out effect</strong>: infrequently presented stimuli
are less adapted and therefore produce larger responses than frequent
stimuli.</p></li>
</ul>
<h4 id="pattern-completion-in-space-and-time">1.3 Pattern completion in
space and time</h4>
<h2 id="总结">总结</h2>
<p>这篇文章讲得不够具体，temporal pool 和 temporal normalization
还行，似乎能和计算模型结合，可是 temporal normalization
有什么好处呢？</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://txing-casia.github.io/2020/09/19/2020-09-19-Reinforcement%20Learning%20-%20Hierarchical%20motor%20control%20in%20mammals%20and%20machinesd%20(Nature)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Txing">
      <meta itemprop="description" content="泛用类人决战型机器人博士">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Txing">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/19/2020-09-19-Reinforcement%20Learning%20-%20Hierarchical%20motor%20control%20in%20mammals%20and%20machinesd%20(Nature)/" class="post-title-link" itemprop="url">Reinforcement Learning | Hierarchical motor control in mammals and machinesd (Nature)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-19 00:00:00" itemprop="dateCreated datePublished" datetime="2020-09-19T00:00:00+08:00">2020-09-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-25 09:54:14" itemprop="dateModified" datetime="2023-03-25T09:54:14+08:00">2023-03-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="hierarchical-motor-control-in-mammals-and-machines">Hierarchical
motor control in mammals and machines</h1>
<p>论文链接：https://www.nature.com/articles/s41467-019-13239-6</p>
<h2 id="背景">背景</h2>
<p>很多人工智能领域的进展启发了神经科学的研究。多数神经科学的研究都致力于探索单个任务空间的离散任务，而AI研究主要在agent玩复杂的游戏上。近期生物上的“synthetic
motor control”却很少有人讨论。</p>
<p>本文是一篇讨论AI和神经科学关于HRL以及H
control的综述，角度比较好，介绍了大量细分方向的工作，非常值得一读。</p>
<h2 id="主要工作">主要工作</h2>
<ul>
<li>神经科学启发了机器人中的subsumption
architecture，简单搜了一下类似于层级机构的雏形（1986）。</li>
<li>Optimal feedback control
(OFC)研究如何优化运动，降低优化函数的值，取得最优性能；神经科学研究的是如何理解通过神经系统生成不同的行为动作。</li>
</ul>
<p>下面介绍几个重叠领域的重要工作：</p>
<h3 id="computational-approaches-to-motor-control">1. computational
approaches to motor control</h3>
<ul>
<li>运动控制在animal and artificial system中都是值得关注的问题；</li>
<li>控制通过一个controller或者policy</li>
<li>图1提供了三种控制结构，</li>
</ul>
<p><img src="https://raw.githubusercontent.com/txing-casia/txing-casia.github.io/master/img/20200917-1.png"></p>
<ul>
<li><p>生物：内部前向模型Internal forward models are used to predict the
future consequences of
actions。该模型是允许虚拟行为的，可以预测行为后果。</p></li>
<li><p>OFC被用于解释volitional control意志控制</p>
<ul>
<li>Diedrichsen, J., Shadmehr, R. &amp; Ivry, R. B. The coordination of
movement: optimal feedback control and beyond. Trends Cogn. Sci. 14,
31–39 (2010).</li>
<li>Scott, S. H. The computational and neural basis of voluntary motor
control and planning. Trends Cogn, Sci, 16, 541–549 (2012).</li>
</ul></li>
<li><p>OFC几乎可以概括所有的闭环控制算法，一些扩展的OFC主要是考虑了以下三点：</p>
<ul>
<li><p>运动控制目标是最大化一个优化函数；</p></li>
<li><p>利用传感反馈来进行行为选择；</p></li>
<li><p>内部模型帮助弥补传感延迟和执行状态估计；</p></li>
</ul></li>
<li><p>OFC对目标函数的组成结构非常包容，甚至不需要一个直接的目标，但在快速求解上有一点缺陷</p></li>
</ul>
<h3 id="motor-control-of-synthetic-systems">2. Motor control of
synthetic systems</h3>
<ul>
<li><p>这部分内容主要涉及DRL，没提到什么新鲜的内容。</p></li>
<li><p>planning methods:</p>
<ul>
<li>Mordatch, I., Todorov, E. &amp; Popović, Z. Discovery of complex
behaviors through contact-invariant optimization. ACM T, Graphics (TOG)
31, 43 (2012).</li>
<li>Mordatch, I., Wang, J. M., Todorov, E. &amp; Koltun, V. Animating
human lower limbs using contact-invariant optimization. ACM T. Graphic.
32, 203 (2013)</li>
</ul></li>
<li><p>导航任务：Jaderberg, M. et al. Reinforcement learning with
unsupervised auxiliary tasks. In International Conference on Learning
Representations, 2017.</p></li>
<li><p><strong>挑战1：</strong>DRL的优化目标比较狭窄比如走路faster，保持平衡稳定，运动到某个位置等等，很难设计有泛化能力的目标。</p></li>
<li><p><strong>挑战2：</strong>
<strong>处理变化的目标</strong>。通过其他任务的经验生成运动，适应变化的目标。</p></li>
</ul>
<h3 id="core-principles-of-hierarchical-motor-control">3. Core
principles of hierarchical motor control</h3>
<h4 id="information-factorization">3.1 Information factorization</h4>
<ul>
<li>Information factorization
（信息因子分解）：分层系统提供局部或者预处理的信息给其它系统的过程</li>
<li>运动中有一部分模式的通用的，要么high-level behavior是invariant
，要么low-level behavior是invariant</li>
<li>That some goals or tasks can be solved by a multiplicity of
execution details (“motor equivalence”) has long been recognized as
important in movement science and has also been identified as relevant
for robot control.
有些任务可以用等效的运动去完成，这也是机器人控制上的一个问题</li>
</ul>
<h4 id="partial-autonomy">3.2 Partial autonomy</h4>
<ul>
<li>完整的优化一个动作成本很高，但是只要产生出了一次动作，可以训练一个“reactive”
subsystem重复地长生这个运动而不用冗余的规划过程。这个过程涉及到局部自主（partial
autonomy）以及半自主系统（semi-autonomous
subsystem），在算法层面主要是加载之前算出来的解。</li>
<li>self-supervised learning ，生成的轨迹永续训练另外的系统in an
amortized fashion（用分期的方式）</li>
</ul>
<h4 id="modular-objectives">3.3 Modular objectives</h4>
<ul>
<li>很多ANN在用于控制问题时使用end2end的优化，这样就只能设置一个优化目标，并最大化它</li>
<li>使用模块化的子系统需要制定独特的模块化子目标</li>
<li>一种流行的方法是训练控制器解决任务的同事也训练一组内部状态表征（internal
state
representations）来预测未来的传感数据，某种程度上来讲，这也是一种分层的控制系统。</li>
<li>另一个景点的方法同样保持了层级的目标结构，divideand-conquer
strategy。例如高层控制器决定运动的方向，低层控制器去实施，高层控制器的信号也可以作为
a dense teaching signal that the low-level controller learns from as it
assesses how well it stays on the instructed
course。高层口农资器处理更全局的任务。代表工作：（前两篇低层系统优化目标固定，最有一批FuN是学习抽象目标空间）
<ul>
<li>Nachum, O., Gu, S., Lee, H. &amp; Levine, S. <strong>Near-optimal
representation learning for hierarchical reinforcement
learning</strong>. In International Conference on Learning
Representations, 2019.<br>
</li>
<li>Wayne, G. &amp; Abbott, L. F. Hierarchical control using networks
trained with higher-level forward models. Neural Comput. 26, 2163–2193
(2014)<br>
</li>
<li>Vezhnevets, A. S. et al. Feudal networks for hierarchical
reinforcement learning. In Proceedings of the 34th International
Conference on achine Learning, 3540–3549. JMLR. org, 2017.</li>
</ul></li>
</ul>
<h4 id="multi-joint-coordination">3.4 Multi-joint coordination</h4>
<ul>
<li><p>motor synergy concept （Synergies in coordination: a
comprehensive overview of neural, computational, and behavioral
approaches. J. Neurophysiol. 120, 2761–2774 (2018). ）</p></li>
<li><p>在肌肉驱动的系统上，从高层面设计任务显然会更容易，例如reaching
and grasping. This is perhaps most readily apparent in a setting like
reaching and grasping, where random movement of all degrees of freedom
independently will be ineffective, but random movements in the subspace
of hand configurations encountered during grasping will lead to more
effective interactions.</p></li>
<li><p>几个机器人学方面的工作:</p></li>
<li><p>Vukobratović, M. &amp; Borovac, B. Zero-moment point—thirty five
years of its life. Int. J. Hum. Robot. 1, 157–173 (2004).</p></li>
<li><p>Todorov, E., Li, W. &amp; Pan, X. From task parameters to motor
synergies: a hierarchical framework for approximately optimal control of
redundant manipulators. J. Robot. Syst. 22, 691–710 (2005).</p></li>
<li><p>Mordatch, I., De Lasa, M. &amp; Hertzmann, A. Robust
physics-based locomotion using low-dimensional planning. ACM T. Graphic.
29, 71 (2010).</p></li>
<li><p>unsupervised learning (or self-supervised learning) of
sensorimotor primitives in order to produce a learned low-level
controller</p>
<ul>
<li>Todorov, E. <strong>Optimality principles in sensorimotor
control</strong>. Nat. Neurosci. 7, 907 (2004).<br>
</li>
<li>Todorov E. &amp; Ghahramani., Z. Unsupervised learning of
sensory-motor primitives. In Proceedings of the 25th Annual
International Conference of the IEEE Engineering in Medicine and Biology
Society, Vol. 2, 1750–1753. IEEE, 2003.</li>
</ul></li>
</ul>
<h4 id="temporal-abstraction">3.5 Temporal abstraction</h4>
<ul>
<li>通过设置时间间隔简化使得高层控制器更宏观，但会损失控制精度，这需要低层的控制器去完成。</li>
<li>对于机器人操作任务，离散情况下只有时间维度是最好抽象的，在连续控制的问题上，多关节的协同比时间抽象更有决定性的作用。当然长期的行动规划和行为选择是需要时间抽象（Temporal
abstraction）的。</li>
</ul>
<h3 id="neurobiological-hierarchical-motor-control">4. Neurobiological
hierarchical motor control</h3>
<ul>
<li>这部分主要就少神经科学上关于分层控制的研究工作。</li>
<li>神经系统在结构和功能和功能上都有分层（both anatomically and
functionally hierarchical）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/txing-casia/txing-casia.github.io/master/img/20200918-1.png"></p>
<h4 id="lower-level-movement-centers">4.1 “Lower-level” movement
centers</h4>
<ul>
<li>脊髓（spine）在没有高层输入的情况下也可以控制躯体运动；脊髓环路能生成多关节的时空协同模式
(spatiotemporal coordination patterns)，通过中心模式生成器（central
pattern generators (CPGs) ）产生虚构的动作（ “fictive”
locomotion）；也可以通过传感信息局部调制关节活动。（CPG）</li>
<li>多关节协同通常需要：cerebellum-derived signals，somatic
feedback（躯体反馈）以及inputs from other sensory
systemts（传感输入）</li>
<li>CPG主要产生节律的运动，比如走路，鱼摆尾等等</li>
</ul>
<h4 id="subcortical-mid-level-movement-regulation">4.2 Subcortical
“mid-level” movement regulation</h4>
<ul>
<li>1）皮层对于运动来说并不是必要的。因为去除了皮层的cat在恢复一段时间后，可以具备避障能力（刚切除时没有）。这反映出层次化控制和局部自治。</li>
<li>2）皮层下的结构可以选择运动协调模式</li>
<li>3）没了皮层后，传感受到损伤。但还可以通过non-cortical的通路接收传感信息。这里体现了信息因子分解。</li>
<li>4）小脑负责运动协调，基底神经节负责行为选择；</li>
</ul>
<h4 id="cortical-high-level-control-of-movement">4.3 Cortical
“high-level” control of movement</h4>
<ul>
<li>具备一些分层结构特征</li>
</ul>
<h3 id="shared-challenges-for-biological-and-synthetic-motor-control">5.
Shared challenges for biological and synthetic motor control</h3>
<ul>
<li>despite significant progress in artificial intelligence research
over the past years, there remain meaningful challenges in dealing with
rich sensation, a broader range of tasks, rapid adaptation or
improvisation, as well as object interaction and tool use.
<ul>
<li>处理多传感融合</li>
<li>处理更普遍的任务</li>
<li>快速适应、即兴创作</li>
<li>物体交互</li>
<li>使用工具</li>
</ul></li>
</ul>
<h4 id="towards-full-scale-body-control">5.1 Towards full-scale body
control</h4>
<ul>
<li>对生物力学、肌肉系统、肌肉骨骼系统的研究</li>
<li>针对这类系统有两个控制思路：
<ul>
<li>训练该系统解决不同的任务</li>
<li>对观测到的行为生成数据驱动的模型</li>
</ul></li>
</ul>
<h4 id="the-structure-of-inter-region-communication">5.2 The structure
of inter-region communication</h4>
<ul>
<li>脑区之间的编码方案(coding
schemes)仍然未知，我们同样不确定分层控制系统中的信息流的形式。</li>
<li>三个问题：
<ul>
<li>一个问题是分层的学习系统层级间的通信不一定需要有明确的可解释性，除非可解释的结构能带来明确的好处</li>
<li>一个系统的输出如何调制另一个系统，对目标的调制应该是线性的还是非线性的？</li>
<li>关于分辨率问题，表示具体行为的抽象目标之间的通讯和对下级系统丰富的指令怎么保持平衡</li>
</ul></li>
<li>生物的角度来看，层次化的系统间一定要有一种语言或者编码，这种上下层级之间的通讯方案是AI和神经科学应该共同讨论的问题。</li>
</ul>
<h4 id="ethological-行为学的-motor-learning-and-imitation">5.3
Ethological （行为学的） motor learning and imitation</h4>
<ul>
<li>self-directed rehearsal: songbird在雏鸟阶段学习唱歌</li>
<li>主动采样策略：Gottlieb J. &amp; Oudeyer, P. Y. <strong>Towards a
neuroscience of active sampling and curiosity</strong>. Nat. Rev.
Neurosci. 19, 758–770 (2018)</li>
</ul>
<h2 id="总结">总结</h2>
<p>这篇综述很好地概括并梳理了在AI和生物神经科学中的零散的工作，总结出了很多子领域和本质问题，这是一篇很好的综述，可以帮助对领域的快速了解。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://txing-casia.github.io/2020/09/18/2020-09-18-Q47%20Permutations%20II-%E4%B8%AD%E7%AD%89-%E5%9B%9E%E6%BA%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Txing">
      <meta itemprop="description" content="泛用类人决战型机器人博士">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Txing">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/18/2020-09-18-Q47%20Permutations%20II-%E4%B8%AD%E7%AD%89-%E5%9B%9E%E6%BA%AF/" class="post-title-link" itemprop="url">Q47 Permutations II-中等-回溯</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-18 00:00:00" itemprop="dateCreated datePublished" datetime="2020-09-18T00:00:00+08:00">2020-09-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-25 09:54:14" itemprop="dateModified" datetime="2023-03-25T09:54:14+08:00">2023-03-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="permutations-ii"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutations-ii/">Permutations
II</a></h1>
<h2 id="question">Question</h2>
<blockquote>
<p>Given a collection of numbers that might contain duplicates, return
all possible unique permutations.</p>
</blockquote>
<blockquote>
<p><strong>Example 1:</strong></p>
<p>Input: [1,1,2] Output: [ [1,1,2], [1,2,1], [2,1,1]]</p>
</blockquote>
<h3 id="approach-1-循环">Approach 1: 循环</h3>
<p>本来打算使用Hash
table统计一下有哪些元素，以及对应的个数，但后来想了想其实没有必要统计。在写代码的时候找到了一个快速实现字典初始化的方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hash=<span class="built_in">dict</span>()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">    Hash[nums[i]]=<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>可以用下面这句等效替代，节省一个For循环：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hash.setdefault(nums[i], <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>下面正片开始</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permuteUnique</span>(<span class="params">self, nums</span>):</span><br><span class="line">        <span class="comment"># 错误输入检测</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">nums, temp_list</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(temp_list) == n:</span><br><span class="line">                ans.append(temp_list) <span class="comment"># temp_list存满了就放入ans</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]: <span class="comment"># 第一个元素不进行此判断</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                dfs(nums[:i]+nums[i+<span class="number">1</span>:], temp_list+[nums[i]])</span><br><span class="line"></span><br><span class="line">        ans = []</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        nums.sort()</span><br><span class="line">        dfs(nums, [])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    nums =[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">    solution=Solution().permuteUnique(nums)</span><br><span class="line">    <span class="built_in">print</span>(solution)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>主要利用排序后对列表的切片操作，巧妙地对排列进行剪支</p>
<p>写的非常简洁，值得好好研究</p>
<h2 id="复杂度分析">复杂度分析</h2>
<ul>
<li><p>时间复杂度：<span class="math display">\[O(n\times
n!)\]</span></p>
<p>算法的复杂度首先受 backtrack 的调用次数制约，backtrack 的调用次数为
<span class="math display">\[\sum_{k = 1}^{n}{P(n, k)}\]</span>次，其中
<span class="math display">\[P(n, k) = \frac{n!}{(n - k)!} = n (n - 1)
... (n - k + 1)\]</span>，该式被称作 n 的 k - 排列，或者部分排列</p>
<p>这说明 backtrack 的调用次数是 <span class="math display">\[O(n!)\]</span>的。</p>
<p>而对于 backtrack 调用的每个叶结点（最坏情况下没有重复数字共 <span class="math display">\[n!\]</span> 个），我们需要将当前答案使用 <span class="math display">\[O(n)\]</span>
的时间复制到答案数组中，相乘得时间复杂度为 <span class="math display">\[O(n \times n!)\]</span>。</p></li>
<li><p>空间复杂度：<span class="math display">\[O(n
)\]</span>。递归的时候栈深度会达到
O(n)<em>O</em>(<em>n</em>)，因此总空间复杂度为 O(n +
n)=O(2n)=O(n)<em>O</em>(<em>n</em>+<em>n</em>)=<em>O</em>(2<em>n</em>)=<em>O</em>(<em>n</em>)。</p></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://txing-casia.github.io/2020/09/17/2020-09-17-Q1470%20Shuffle%20the%20Array-%E7%AE%80%E5%8D%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Txing">
      <meta itemprop="description" content="泛用类人决战型机器人博士">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Txing">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/17/2020-09-17-Q1470%20Shuffle%20the%20Array-%E7%AE%80%E5%8D%95/" class="post-title-link" itemprop="url">Q1470 Shuffle the Array-简单</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-17 00:00:00" itemprop="dateCreated datePublished" datetime="2020-09-17T00:00:00+08:00">2020-09-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-25 09:54:14" itemprop="dateModified" datetime="2023-03-25T09:54:14+08:00">2023-03-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="shuffle-the-array"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shuffle-the-array/">Shuffle the
Array</a></h1>
<h2 id="question">Question</h2>
<blockquote>
<p>Given the array nums consisting of 2n elements in the form
[x1,x2,...,xn,y1,y2,...,yn].</p>
<p>Return the array in the form [x1,y1,x2,y2,...,xn,yn].</p>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 500</code></li>
<li><code>nums.length == 2n</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10^3</code></li>
</ul>
</blockquote>
<blockquote>
<p><strong>Example 1:</strong></p>
<p>Input: nums = [2,5,1,3,4,7], n = 3 Output: [2,3,5,4,1,7] Explanation:
Since x1=2, x2=5, x3=1, y1=3, y2=4, y3=7 then the answer is
[2,3,5,4,1,7].</p>
</blockquote>
<blockquote>
<p><strong>Example 2:</strong></p>
<p>Input: nums = [1,2,3,4,4,3,2,1], n = 4 Output: [1,4,2,3,3,2,4,1]</p>
</blockquote>
<blockquote>
<p><strong>Example 3:</strong></p>
<p>Input: nums = [1,1,2,2], n = 2 Output: [1,2,1,2]</p>
</blockquote>
<h3 id="approach-1-循环">Approach 1: 循环</h3>
<p>本来打算使用单行FOR循环漂亮地完成这道题目：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> [[nums[i],nums[n+i]] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br></pre></td></tr></table></figure>
<p>不幸的是这个写法导致结果变成了一个嵌套的两层的列表，为了消除嵌套的括号，尝试了利用zip(*)解压，.replace("[",'')等操作</p>
<ul>
<li>zip(a,b)是合并/压缩，zip(*c)是拆分/解压，并返回一个地址，使用*
zip()和*
zip(*)则返回数据。如果想连续解压两次写成嵌套形式，就有点问题，比如解压a，写为：*zip(**zip(*a))会造成混乱。因此不能实现效果。</li>
<li>replace则会多出引号</li>
</ul>
<p>没办法，常规写法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">shuffle</span>(<span class="params">self, nums, n</span>):</span><br><span class="line">        ans=nums[:]</span><br><span class="line">        j=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            ans[j],ans[j+<span class="number">1</span>]=nums[i],nums[n+i]</span><br><span class="line">            j=j+<span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    nums =[<span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>]</span><br><span class="line">    n = <span class="number">3</span></span><br><span class="line">    solution=Solution().shuffle(nums,n)</span><br><span class="line">    <span class="built_in">print</span>(solution)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>列表<strong>赋值的时候是地址传递</strong>，例如ans=nums，修改ans会改变nums</p>
<h3 id="复杂度分析">复杂度分析</h3>
<ul>
<li><p>时间复杂度：O(N)</p></li>
<li><p>空间复杂度：O(N)</p></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/18/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><span class="page-number current">19</span><a class="page-number" href="/page/20/">20</a><span class="space">&hellip;</span><a class="page-number" href="/page/29/">29</a><a class="extend next" rel="next" href="/page/20/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Txing</p>
  <div class="site-description" itemprop="description">泛用类人决战型机器人博士</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">229</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">57</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yourname" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/yourname" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Txing</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
