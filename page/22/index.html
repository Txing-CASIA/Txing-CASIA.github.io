<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"txing-casia.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":240,"display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="泛用人形决战型机器人博士">
<meta property="og:type" content="website">
<meta property="og:title" content="Txing">
<meta property="og:url" content="https://txing-casia.github.io/page/22/index.html">
<meta property="og:site_name" content="Txing">
<meta property="og:description" content="泛用人形决战型机器人博士">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Txing">
<meta property="article:tag" content="Txing">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://txing-casia.github.io/page/22/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Txing</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Txing</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">欢迎来到 | 伽蓝之堂</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://txing-casia.github.io/2020/09/08/2020-09-08-Neuroscience-A%20New%20Paradigm%20for%20Exploring%20Neural%20Substrates%20of%20Action%20Execution/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/my_photo.jpg">
      <meta itemprop="name" content="Txing">
      <meta itemprop="description" content="泛用人形决战型机器人博士">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Txing">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/08/2020-09-08-Neuroscience-A%20New%20Paradigm%20for%20Exploring%20Neural%20Substrates%20of%20Action%20Execution/" class="post-title-link" itemprop="url">Neuroscience | A New Paradigm for Exploring Neural Substrates of Action Execution</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-08 00:00:00" itemprop="dateCreated datePublished" datetime="2020-09-08T00:00:00+08:00">2020-09-08</time>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>932</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>1 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1
id="exploring-neural-substrates-underlying-the-execution-of-behavior-across-the-whole-brain">Exploring
Neural Substrates Underlying the Execution of Behavior Across the Whole
Brain</h1>
<p>论文链接：https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5563763/</p>
<h2 id="背景">背景</h2>
<p>目前的行为控制机制的研究难以深入进行，一方面是因为生物的运动是一个连续的过程难以准确切分，此外，在行为过程中人脑还可能并行执行其他任务，因此在观测神经元活动的时候可能会出现干扰。另一方面，一些技术手段例如fMRI的分辨率不足以支持在突触层面分析环路机制，因此研究难以深入。</p>
<p>本文推荐了另一项研究工作中使用的实验方案，有望成为一种新的研究运动控制机制的实验范式。</p>
<h2 id="主要工作">主要工作</h2>
<p>实验对象：斑马鱼（体型小，身体透明，可用光学显微镜直接观察神经元）</p>
<p>使用的技术手段比较复杂：</p>
<ul>
<li><p>light-sheet imaging</p></li>
<li><p>two-photon manipulation</p></li>
<li><p>fictive behavioral paradigm in transgenic fish</p></li>
</ul>
<p>分子标记技术的弊端：</p>
<p>However, in many cases, the specific location or molecular markers
were not identified for particular neurons. More importantly, neurons in
the same location or expressing the same molecular marker may play
different roles in the execution of a particular behavior, presenting
major problems in dissecting the neural circuits underlying behaviors
with the widely-applied spatial or genetic targeting strategies.</p>
<p>他们发现zebrafish的前菱脑转向区（anterior rhombencephalic turning
region,
ARTR）与转向运动有关，通过光遗传学手段增强ARTA活性之后，zebrafish的转向获得了加强。</p>
<p>Txing</p>
<p>2020-09-08</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://txing-casia.github.io/2020/09/08/2020-09-08-Neuroscience-Spontaneous%20Thought%20Processes%20(STPs)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/my_photo.jpg">
      <meta itemprop="name" content="Txing">
      <meta itemprop="description" content="泛用人形决战型机器人博士">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Txing">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/08/2020-09-08-Neuroscience-Spontaneous%20Thought%20Processes%20(STPs)/" class="post-title-link" itemprop="url">Neuroscience | Spontaneous Thought Processes (STPs)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-08 00:00:00" itemprop="dateCreated datePublished" datetime="2020-09-08T00:00:00+08:00">2020-09-08</time>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>941</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>1 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1
id="offline-memory-reprocessing-involvement-of-the-brains-default-network-in-spontaneous-thought-processes">Offline
Memory Reprocessing: Involvement of the Brain's Default Network in
Spontaneous Thought Processes</h1>
<p>论文链接：https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2653727/</p>
<h2 id="背景">背景</h2>
<p>人脑的自发思维活动一直是个谜。比如白日梦（daydream）和心不在焉（mind-wandering）的状态。其特点是切断了外部输入，例如闭眼、冥想，大脑依靠过去的记忆回忆过去或者是期待未来，这种依靠内部记忆的联想机制也叫作离线记忆再处理（Offline
Memory
Reprocessing）。但是这些自发过程的神经机制一直不清楚，本文首次尝试寻找这一过程作用的脑区。</p>
<h2 id="主要工作">主要工作</h2>
<p>利用功能核磁共振成像（functional magnetic resonance imaging,
fMRI）获得全脑的活动状态。结合区域一致性方法（regional homogeneity,
ReHo）评估各个脑区的活跃程度。根据静息状态和记忆再处理状态的活跃程度对比，得到自发思维网络涉及的相应脑区（STPs-network）。</p>
<p><img
src="https://raw.githubusercontent.com/txing-casia/txing-casia.github.io/master/img/20200908-1.png" /></p>
<p>STPs-network 主要涉及的脑区为：</p>
<ul>
<li>the posterior cingulate cortex</li>
<li>the precuneus</li>
<li>the medial prefrontal cortex</li>
<li>bilateral inferior parietal cortex</li>
<li>bilateral dorsal lateral prefrontal cortex</li>
</ul>
<p>文章后面测试了一下自发思维的强度和STPs-network活性的相关性。比较了几个脑区间的连通性。</p>
<h2 id="method">Method</h2>
<ul>
<li>Regional homogeneity (ReHo) Analysis</li>
</ul>
<p><span class="math display">\[
W=\frac{\sum (R_i)^2-n(\overline{R})^2}{\frac{1}{12}k^2(n^3-n)}
\]</span></p>
<p>可以理解为求一个立体区域的平均活跃度，这里不再赘述。</p>
<h2 id="总结">总结</h2>
<p>这篇工作来自昆明动物所徐林老师，研究还是具有一定的启发性的，尤其是提到的大脑外部驱动和内部驱动的切换，挺有意思的。另外自发活动这一点确实还需要继续探索，在神经科学领域也是核心问题。</p>
<p>Txing</p>
<p>2020-09-08</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://txing-casia.github.io/2020/09/08/2020-09-08-Q77%20Combinations-%E4%B8%AD%E7%AD%89-%E9%80%92%E5%BD%92%20%E5%9B%9E%E6%BA%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/my_photo.jpg">
      <meta itemprop="name" content="Txing">
      <meta itemprop="description" content="泛用人形决战型机器人博士">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Txing">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/08/2020-09-08-Q77%20Combinations-%E4%B8%AD%E7%AD%89-%E9%80%92%E5%BD%92%20%E5%9B%9E%E6%BA%AF/" class="post-title-link" itemprop="url">Q77 Combinations-中等-递归 回溯</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-08 00:00:00" itemprop="dateCreated datePublished" datetime="2020-09-08T00:00:00+08:00">2020-09-08</time>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>4.4k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>4 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="combinations"><a
target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combinations/">Combinations</a></h1>
<h2 id="question">Question</h2>
<blockquote>
<p>Given two integers n and k, return all possible combinations of k
numbers out of 1 ... n.</p>
<p>You may return the answer in any order.</p>
<p><strong>Constraints:</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 20</code></li>
<li><code>1 &lt;= k &lt;= n</code></li>
</ul>
</blockquote>
<blockquote>
<p><strong>Example 1:</strong></p>
<p>Input: n = 4, k = 2 Output: [ [2,4], [3,4], [2,3], [1,2], [1,3],
[1,4],]</p>
</blockquote>
<blockquote>
<p><strong>Example 2:</strong></p>
<p>Input: n = 1, k = 1 Output: [[1]]</p>
</blockquote>
<h3 id="approach-1-递归调用">Approach 1: 递归调用</h3>
<p>把选k个数的任务拆解为选2个数的任务，直到选完了k个数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combine</span>(<span class="params">self, n, k</span>):</span><br><span class="line">        <span class="keyword">if</span> k&gt;n <span class="keyword">or</span> k==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> k==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> [[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">if</span> k==n:</span><br><span class="line">            <span class="keyword">return</span> [[i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>)]]</span><br><span class="line">        </span><br><span class="line">        answer=self.combine(n-<span class="number">1</span>,k)</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> self.combine(n-<span class="number">1</span>,k-<span class="number">1</span>):</span><br><span class="line">            item.append(n)</span><br><span class="line">            answer.append(item)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> answer</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    n = <span class="number">4</span></span><br><span class="line">    k = <span class="number">2</span></span><br><span class="line">    solution=Solution().combine(n,k)</span><br><span class="line">    <span class="built_in">print</span>(solution)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="approach-2-回溯算法">Approach 2: <a
target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/combinations/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-ma-/">回溯算法</a></h3>
<h4 id="重点概括">重点概括：</h4>
<ul>
<li><p>如果解决一个问题有多个步骤，每一个步骤有多种方法，题目又要我们找出所有的方法，可以使用回溯算法；</p></li>
<li><p>回溯算法是在一棵树上的
深度优先遍历（因为要找所有的解，所以需要遍历）；</p></li>
<li><p>组合问题，相对于排列问题而言，不计较一个组合内元素的顺序性（即
[1, 2, 3] 与 [1, 3, 2]
认为是同一个组合），因此很多时候需要按某种顺序展开搜索，这样才能做到不重不漏。</p></li>
</ul>
<p>既然是树形问题上的 深度优先遍历，因此首先画出树形结构。例如输入：n =
4, k = 2，我们可以发现如下递归结构：</p>
<ul>
<li>如果组合里有 1 ，那么需要在 [2, 3, 4] 里再找 11 个数；</li>
<li>如果组合里有 2 ，那么需要在 [3, 4] 里再找 11数。注意：这里不能再考虑
11，因为包含 11 的组合，在第 1 种情况中已经包含。
依次类推（后面部分省略），以上描述体现的 递归 结构是：在以 nn
结尾的候选数组里，选出若干个元素。画出递归结构如下图：</li>
</ul>
<h4 id="说明">说明：</h4>
<p>叶子结点的信息体现在从根结点到叶子结点的路径上，因此需要一个表示路径的变量
path，它是一个列表，特别地，path 是一个栈；
每一个结点递归地在做同样的事情，区别在于搜索起点，因此需要一个变量 start
，表示在区间 [begin, n] 里选出若干个数的组合；
可能有一些分支没有必要执行，我们放在优化中介绍。
友情提示：对于这一类问题，画图帮助分析是非常重要的解题方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.<span class="type">List</span>;</span><br><span class="line"></span><br><span class="line">public <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    public <span class="type">List</span>&lt;<span class="type">List</span>&lt;Integer&gt;&gt; combine(<span class="built_in">int</span> n, <span class="built_in">int</span> k) &#123;</span><br><span class="line">        <span class="type">List</span>&lt;<span class="type">List</span>&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= <span class="number">0</span> || n &lt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        // 从 <span class="number">1</span> 开始是题目的设定</span><br><span class="line">        Deque&lt;Integer&gt; path = new ArrayDeque&lt;&gt;();</span><br><span class="line">        dfs(n, k, <span class="number">1</span>, path, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void dfs(<span class="built_in">int</span> n, <span class="built_in">int</span> k, <span class="built_in">int</span> begin, Deque&lt;Integer&gt; path, <span class="type">List</span>&lt;<span class="type">List</span>&lt;Integer&gt;&gt; res) &#123;</span><br><span class="line">        // 递归终止条件是：path 的长度等于 k</span><br><span class="line">        <span class="keyword">if</span> (path.size() == k) &#123;</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 遍历可能的搜索起点</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = begin; i &lt;= n; i++) &#123;</span><br><span class="line">            // 向路径变量里添加一个数</span><br><span class="line">            path.addLast(i);</span><br><span class="line">            // 下一轮搜索，设置的搜索起点要加 <span class="number">1</span>，因为组合数理不允许出现重复的元素</span><br><span class="line">            dfs(n, k, i + <span class="number">1</span>, path, res);</span><br><span class="line">            // 重点理解这里：深度优先遍历有回头的过程，因此递归之前做了什么，递归之后需要做相同操作的逆向操作</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="优化">优化</h4>
<p>事实上，如果 n = 7, k = 4，从 55
开始搜索就已经没有意义了，这是因为：即使把 55 选上，后面的数只有 66 和
77，一共就 33 个候选数，凑不出 44
个数的组合。因此，搜索起点有上界，这个上界是多少，可以举几个例子分析。</p>
<p>分析搜索起点的上界，其实是在深度优先遍历的过程中剪枝，剪枝可以避免不必要的遍历，剪枝剪得好，可以大幅度节约算法的执行时间。</p>
<p>下面的图片绿色部分是剪掉的枝叶，当 n
很大的时候，能少遍历很多结点，节约了时间。</p>
<p>（温馨提示：右键，在弹出的下拉列表框中选择「在新标签页中打开图片」，可以查看大图。）</p>
<p>容易知道：搜索起点和当前还需要选几个数有关，而当前还需要选几个数与已经选了几个数有关，即
path 的长度相关。我们举几个例子分析：</p>
<p>例如：n = 6 ，k = 4。</p>
<p>path.size() == 1 的时候，接下来要选择 33 个数，搜索起点最大是
44，最后一个被选的组合是 [4, 5, 6]； path.size() == 2
的时候，接下来要选择 22 个数，搜索起点最大是 55，最后一个被选的组合是
[5, 6]； path.size() == 3 的时候，接下来要选择 11 个数，搜索起点最大是
66，最后一个被选的组合是 [6]；</p>
<p>再如：n = 15 ，k = 4。 path.size() == 1 的时候，接下来要选择 33
个数，搜索起点最大是 1313，最后一个被选的是 [13, 14, 15]； path.size()
== 2 的时候，接下来要选择 22 个数，搜索起点最大是 1414，最后一个被选的是
[14, 15]； path.size() == 3 的时候，接下来要选择 11 个数，搜索起点最大是
1515，最后一个被选的是 [15]；</p>
<p>搜索起点的上界 + 接下来要选择的元素个数 - 1 = n</p>
<p>其中，接下来要选择的元素个数 = k - path.size()，整理得到：</p>
<p>搜索起点的上界 = n - (k - path.size()) + 1
所以，我们的剪枝过程就是：把 i &lt;= n 改成 i &lt;= n - (k - pre.size())
+ 1 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= <span class="number">0</span> || n &lt; k) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Deque&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        dfs(n, k, <span class="number">1</span>, path, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> index, Deque&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (path.size() == k) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只有这里 i &lt;= n - (k - path.size()) + 1 与参考代码 1 不同</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt;= n - (k - path.size()) + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            path.addLast(i);</span><br><span class="line">            dfs(n, k, i + <span class="number">1</span>, path, res);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="说明-1">说明：</h4>
<p>一些边界条件比较绕的，用具体的例子分析就不容易出错，主要考察的是细心，没有太多技巧；
为参考代码 3 添加 path 的打印输出语句，可以看到输出语句会更少。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">递归之前 =&gt; [<span class="number">1</span>]</span><br><span class="line">递归之前 =&gt; [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">递归之前 =&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">递归之后 =&gt; [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">递归之前 =&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line">递归之后 =&gt; [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">递归之前 =&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>]</span><br><span class="line">递归之后 =&gt; [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">递归之后 =&gt; [<span class="number">1</span>]</span><br><span class="line">递归之前 =&gt; [<span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line">递归之前 =&gt; [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">递归之后 =&gt; [<span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line">递归之前 =&gt; [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">递归之后 =&gt; [<span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line">递归之后 =&gt; [<span class="number">1</span>]</span><br><span class="line">递归之前 =&gt; [<span class="number">1</span>, <span class="number">4</span>]</span><br><span class="line">递归之前 =&gt; [<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">递归之后 =&gt; [<span class="number">1</span>, <span class="number">4</span>]</span><br><span class="line">递归之后 =&gt; [<span class="number">1</span>]</span><br><span class="line">递归之后 =&gt; []</span><br><span class="line">递归之前 =&gt; [<span class="number">2</span>]</span><br><span class="line">递归之前 =&gt; [<span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">递归之前 =&gt; [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">递归之后 =&gt; [<span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">递归之前 =&gt; [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">递归之后 =&gt; [<span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">递归之后 =&gt; [<span class="number">2</span>]</span><br><span class="line">递归之前 =&gt; [<span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line">递归之前 =&gt; [<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">递归之后 =&gt; [<span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line">递归之后 =&gt; [<span class="number">2</span>]</span><br><span class="line">递归之后 =&gt; []</span><br><span class="line">递归之前 =&gt; [<span class="number">3</span>]</span><br><span class="line">递归之前 =&gt; [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">递归之前 =&gt; [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">递归之后 =&gt; [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">递归之后 =&gt; [<span class="number">3</span>]</span><br><span class="line">递归之后 =&gt; []</span><br><span class="line">[[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>], [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>], [<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>], [<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://txing-casia.github.io/2020/09/07/2020-09-07-ImportError%20cannot%20import%20name%20'Optional'/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/my_photo.jpg">
      <meta itemprop="name" content="Txing">
      <meta itemprop="description" content="泛用人形决战型机器人博士">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Txing">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/07/2020-09-07-ImportError%20cannot%20import%20name%20'Optional'/" class="post-title-link" itemprop="url">ImportError: cannot import name 'Optional'</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-07 00:00:00" itemprop="dateCreated datePublished" datetime="2020-09-07T00:00:00+08:00">2020-09-07</time>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>536</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>1 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="importerror-cannot-import-name-optional">ImportError: cannot
import name 'Optional'</h1>
<p>遇到报错：ImportError: cannot import name 'Optional'</p>
<p>已安装所需的库，经查是由于torchvision和pytorch版本不对应导致的。具体对应版本号见<a
target="_blank" rel="noopener" href="https://github.com/pytorch/vision">下图</a></p>
<table>
<colgroup>
<col style="width: 30%" />
<col style="width: 30%" />
<col style="width: 38%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;"><code>torch</code></th>
<th style="text-align: center;"><code>torchvision</code></th>
<th style="text-align: center;"><code>python</code></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>master</code> /
<code>nightly</code></td>
<td style="text-align: center;"><code>master</code> /
<code>nightly</code></td>
<td style="text-align: center;"><code>&gt;=3.6</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>1.6.0</code></td>
<td style="text-align: center;"><code>0.7.0</code></td>
<td style="text-align: center;"><code>&gt;=3.6</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>1.5.1</code></td>
<td style="text-align: center;"><code>0.6.1</code></td>
<td style="text-align: center;"><code>&gt;=3.5</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>1.5.0</code></td>
<td style="text-align: center;"><code>0.6.0</code></td>
<td style="text-align: center;"><code>&gt;=3.5</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>1.4.0</code></td>
<td style="text-align: center;"><code>0.5.0</code></td>
<td style="text-align: center;"><code>==2.7</code>,
<code>&gt;=3.5</code>, <code>&lt;=3.8</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>1.3.1</code></td>
<td style="text-align: center;"><code>0.4.2</code></td>
<td style="text-align: center;"><code>==2.7</code>,
<code>&gt;=3.5</code>, <code>&lt;=3.7</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>1.3.0</code></td>
<td style="text-align: center;"><code>0.4.1</code></td>
<td style="text-align: center;"><code>==2.7</code>,
<code>&gt;=3.5</code>, <code>&lt;=3.7</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>1.2.0</code></td>
<td style="text-align: center;"><code>0.4.0</code></td>
<td style="text-align: center;"><code>==2.7</code>,
<code>&gt;=3.5</code>, <code>&lt;=3.7</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>1.1.0</code></td>
<td style="text-align: center;"><code>0.3.0</code></td>
<td style="text-align: center;"><code>==2.7</code>,
<code>&gt;=3.5</code>, <code>&lt;=3.7</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>&lt;=1.0.1</code></td>
<td style="text-align: center;"><code>0.2.2</code></td>
<td style="text-align: center;"><code>==2.7</code>,
<code>&gt;=3.5</code>, <code>&lt;=3.7</code></td>
</tr>
</tbody>
</table>
<p>更改anaconda中的库的版本也很简单：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda install pytorch = version</span><br></pre></td></tr></table></figure>
<p>将version改为对应的版本号即可（例如1.4）</p>
<p>Txing</p>
<p>2020-09-07</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://txing-casia.github.io/2020/09/07/2020-09-07-Q104%20Maximum%20Depth%20of%20Binary-%E7%AE%80%E5%8D%95-%E6%B7%B1%E5%BA%A6and%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%20Tree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/my_photo.jpg">
      <meta itemprop="name" content="Txing">
      <meta itemprop="description" content="泛用人形决战型机器人博士">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Txing">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/07/2020-09-07-Q104%20Maximum%20Depth%20of%20Binary-%E7%AE%80%E5%8D%95-%E6%B7%B1%E5%BA%A6and%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%20Tree/" class="post-title-link" itemprop="url">Q104 Maximum Depth of Binary Tree-简单-深度/广度优先搜索</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-07 00:00:00" itemprop="dateCreated datePublished" datetime="2020-09-07T00:00:00+08:00">2020-09-07</time>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>1.7k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>2 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="maximum-depth-of-binary-tree"><a
target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">Maximum
Depth of Binary Tree</a></h1>
<h2 id="question">Question</h2>
<blockquote>
<p>Given a binary tree, find its maximum depth.</p>
<p>The maximum depth is the number of nodes along the longest path from
the root node down to the farthest leaf node.</p>
<p><strong>Note:</strong> A leaf is a node with no children.</p>
</blockquote>
<blockquote>
<p><strong>Example 1:</strong></p>
<p>Given binary tree [3,9,20,null,null,15,7],</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>return its depth = 3.</p>
</blockquote>
<h3 id="approach-1-深度优先搜索">Approach 1: 深度优先搜索</h3>
<p>如果我们知道了左子树和右子树的最大深度 l 和
r，那么该二叉树的最大深度即为<span class="math display">\[\max(l,r) +
1\]</span></p>
<p>而左子树和右子树的最大深度又可以以同样的方式进行计算。因此我们在计算当前二叉树的最大深度时，可以先递归计算出其左子树和右子树的最大深度，然后在
O(1)O(1)
时间内计算出当前二叉树的最大深度。递归在访问到空节点时退出。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxDepth</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            left_height = self.maxDepth(root.left)</span><br><span class="line">            right_height = self.maxDepth(root.right)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(left_height, right_height) + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析">复杂度分析</h3>
<ul>
<li>时间复杂度：<span class="math display">\[O(n)\]</span>，其中 n
为二叉树节点的个数。每个节点在递归中只被遍历一次。</li>
<li>空间复杂度：<span
class="math display">\[O(\textit{height})\]</span>，其中 <span
class="math display">\[\textit{height}\]</span>
表示二叉树的高度。递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于二叉树的高度。</li>
</ul>
<h3 id="approach-1-广度优先搜索">Approach 1: 广度优先搜索</h3>
<p>我们也可以用「广度优先搜索」的方法来解决这道题目，但我们需要对其进行一些修改，此时我们广度优先搜索的队列里存放的是「当前层的所有节点」。每次拓展下一层的时候，不同于广度优先搜索的每次只从队列里拿出一个节点，我们需要将队列里的所有节点都拿出来进行拓展，这样能保证每次拓展完的时候队列里存放的是当前层的所有节点，即我们是一层一层地进行拓展，最后我们用一个变量
<span class="math display">\[\textit{ans}\]</span>
来维护拓展的次数，该二叉树的最大深度即为 <span
class="math display">\[\textit{ans}\]</span>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">maxDepth2</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        queue = [(root, <span class="number">1</span>)]</span><br><span class="line">        max_dep = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node, depth = queue.pop()</span><br><span class="line">            max_dep = <span class="built_in">max</span>(max_dep, depth)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                queue.append((node.left, depth +<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                queue.append((node.right, depth + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> max_dep</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析-1">复杂度分析</h3>
<p>时间复杂度：<span class="math display">\[O(n)\]</span>，其中 n
为二叉树的节点个数。与方法一同样的分析，每个节点只会被访问一次。
空间复杂度：此方法空间的消耗取决于队列存储的元素数量，其在最坏情况下会达到
<span class="math display">\[O(n)\]</span>。</p>
<ul>
<li></li>
</ul>
<h3 id="思考题">思考题</h3>
<p>对于给定的排列 <span class="math display">\[a_1, a_2, \cdots,
a_n\]</span> ，你能求出 k 吗？</p>
<p>解答： <span class="math display">\[
k = \left( \sum_{i=1}^n \textit{order}(a_i) \cdot (n-i)! \right) + 1
\]</span> 其中 <span
class="math display">\[\textit{order}(a_i)\]</span>表示 <span
class="math display">\[a_{i+1}, \cdots, a_n\]</span>中小于 <span
class="math display">\[a_i\]</span>的元素个数。</p>
<h3 id="反思">反思</h3>
<p>我在分析这个问题的时候只考虑到了第一项怎么确定，然后就用递归来求解问题，中间忽略了n和k的取值特例。分析不够完备，代码看着比较乱，可读性不强。今后分析的时候还是要把问题分析完整了再编代码，比如推出这道题的通项公式后再写代码。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://txing-casia.github.io/2020/09/05/2020-09-05-Q60%20Permutation%20Sequence-%E4%B8%AD%E7%AD%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/my_photo.jpg">
      <meta itemprop="name" content="Txing">
      <meta itemprop="description" content="泛用人形决战型机器人博士">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Txing">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/05/2020-09-05-Q60%20Permutation%20Sequence-%E4%B8%AD%E7%AD%89/" class="post-title-link" itemprop="url">Q60 Permutation Sequence-中等</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-05 00:00:00" itemprop="dateCreated datePublished" datetime="2020-09-05T00:00:00+08:00">2020-09-05</time>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>2.6k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>2 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="permutation-sequence"><a
target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/permutation-sequence/">Permutation
Sequence</a></h1>
<h2 id="question">Question</h2>
<blockquote>
<p>The set [1,2,3,...,n] contains a total of n! unique permutations.</p>
<p>By listing and labeling all of the permutations in order, we get the
following sequence for n = 3:</p>
<p>"123" "132" "213" "231" "312" "321" Given n and k, return the kth
permutation sequence.</p>
<p><strong>Note:</strong></p>
<p>Given n will be between 1 and 9 inclusive. Given k will be between 1
and n! inclusive.</p>
</blockquote>
<blockquote>
<p><strong>Example 1:</strong></p>
<p>Input: n = 3, k = 3 Output: "213"</p>
</blockquote>
<blockquote>
<p><strong>Example 2:</strong></p>
<p>Input: n = 4, k = 9 Output: "2314"</p>
</blockquote>
<h3 id="approach-1-缩小问题规模">Approach 1: 缩小问题规模</h3>
<p>要想解决本题，首先需要了解一个简单的结论：</p>
<blockquote>
<p>对于 n 个不同的元素（例如数 1, 2, <span
class="math display">\[\cdots\]</span>, n），它们可以组成的排列总数目为
n!。</p>
</blockquote>
<p>对于给定的 n 和 k，我们不妨从左往右确定第 k
个排列中的每一个位置上的元素到底是什么。</p>
<p>我们首先确定排列中的首个元素 <span
class="math display">\[a_1\]</span> 。根据上述的结论，我们可以知道：</p>
<ul>
<li><p>以 1 为 <span class="math display">\[a_1\]</span> 的排列一共有
<span class="math display">\[(n-1)!\]</span> 个；</p></li>
<li><p>以 2 为 <span class="math display">\[a_1\]</span>的排列一共有
<span class="math display">\[(n-1)!\]</span> 个；</p></li>
<li><p>以 n 为 <span class="math display">\[a_1\]</span> 的排列一共有
<span class="math display">\[(n-1)!\]</span> 个。</p></li>
</ul>
<p>由于我们需要求出从小到大的第 k 个排列，因此：</p>
<ul>
<li>如果 <span class="math display">\[k \leq
(n-1)!\]</span>，我们就可以确定排列的首个元素为 1；</li>
<li>如果 <span class="math display">\[(n-1)! &lt; k \leq 2 \cdot
(n-1)!\]</span>，我们就可以确定排列的首个元素为 2；</li>
<li>如果 <span class="math display">\[(n-1) \cdot (n-1)! &lt; k \leq n
\cdot (n-1)!\]</span>，我们就可以确定排列的首个元素为 n。 因此，第 k
个排列的首个元素就是：</li>
</ul>
<p><span class="math display">\[
a_1=\frac{k−1}{(n−1)!}+1
\]</span></p>
<p>当我们确定了 <span class="math display">\[a_1\]</span>
后，如何使用相似的思路，确定下一个元素 <span
class="math display">\[a_2\]</span> 呢？实际上，我们考虑以 <span
class="math display">\[a_1\]</span> 为首个元素的所有排列：</p>
<ul>
<li>以 <span class="math display">\[[1,n] \backslash
a_1\]</span>最小的元素为 <span class="math display">\[a_2\]</span>
的排列一共有 <span class="math display">\[(n-2)!\]</span>个；</li>
<li>以 <span class="math display">\[[1,n] \backslash a_1\]</span>
次小的元素为 <span class="math display">\[a_2\]</span>的排列一共有 <span
class="math display">\[(n-2)!\]</span>个；</li>
<li>以 <span class="math display">\[[1,n] \backslash
a_1\]</span>最大的元素为 <span
class="math display">\[a_2\]</span>的排列一共有 <span
class="math display">\[(n-2)!\]</span> 个；</li>
</ul>
<p>其中 <span class="math display">\[[1,n] \backslash
a_1\]</span>表示包含 <span class="math display">\[1, 2, \cdots
n\]</span>中除去 <span
class="math display">\[a_1\]</span>以外元素的集合。这些排列从编号 <span
class="math display">\[(a_1-1) \cdot (n-1)!\]</span>开始，到 <span
class="math display">\[a_1 \cdot (n-1)!\]</span>结束，总计 <span
class="math display">\[(n-1)!\]</span>个，因此第 k
个排列实际上就对应着这其中的第 <span class="math display">\[
k&#39; = (k-1) \bmod (n-1)! + 1
\]</span> 个排列。这样一来，我们就把原问题转化成了一个完全相同但规模减少
1 的子问题：</p>
<p>求 <span class="math display">\[[1, n] \backslash a_1\]</span>这 n-1
个元素组成的排列中，第 <span class="math display">\[k&#39;\]</span>
小的排列。</p>
<h4 id="算法">算法</h4>
<p>设第 k 个排列为 <span class="math display">\[a_1, a_2, \cdots,
a_n\]</span>，我们从左往右地确定每一个元素 <span
class="math display">\[a_i\]</span>。我们用数组 <span
class="math display">\[\textit{valid}\]</span>记录每一个元素是否被使用过。</p>
<p>我们从小到大枚举 i：</p>
<ul>
<li><p>我们已经使用过了 i-1 个元素，剩余 n-i+1
个元素未使用过，每一个元素作为 a_i 都对应着 (n-i)!个排列，总计 (n-i+1)!
个排列；</p></li>
<li><p>因此在第 k 个排列中，<span class="math display">\[a_i\]</span>
即为剩余未使用过的元素中第 <span class="math display">\[\lfloor
\frac{k-1}{(n-i)!}\rfloor + 1\]</span>小的元素；</p></li>
<li><p>在确定了 <span class="math display">\[a_i\]</span>后，这 <span
class="math display">\[n-i+1\]</span> 个元素的第 k 个排列，就等于 <span
class="math display">\[a_i\]</span>之后跟着剩余 n-i 个元素的第 <span
class="math display">\[(k-1) \bmod (n-i)! + 1\]</span>个排列。</p></li>
</ul>
<p>在实际的代码中，我们可以首先将 k 的值减少
1，这样可以减少运算，降低代码出错的概率。对应上述的后两步，即为：</p>
<ul>
<li><p>因此在第 k 个排列中，<span
class="math display">\[a_i\]</span>即为剩余未使用过的元素中第 <span
class="math display">\[\lfloor \frac{k}{(n-i)!} \rfloor +
1\]</span>小的元素；</p></li>
<li><p>在确定了 <span class="math display">\[a_i\]</span> 后，这 n-i+1
个元素的第 k 个排列，就等于 <span class="math display">\[a_i\]</span>
之后跟着剩余 n-i个元素的第 <span class="math display">\[k \bmod
(n-i)!\]</span>个排列。</p></li>
</ul>
<p>实际上，这相当于我们将所有的排列从 0 开始进行编号。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getPermutation</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        factorial = [<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            factorial.append(factorial[-<span class="number">1</span>] * i)</span><br><span class="line">        </span><br><span class="line">        k -= <span class="number">1</span></span><br><span class="line">        ans = <span class="built_in">list</span>()</span><br><span class="line">        valid = [<span class="number">1</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            order = k // factorial[n - i] + <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                order -= valid[j]</span><br><span class="line">                <span class="keyword">if</span> order == <span class="number">0</span>:</span><br><span class="line">                    ans.append(<span class="built_in">str</span>(j))</span><br><span class="line">                    valid[j] = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            k %= factorial[n - i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(ans)</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析">复杂度分析</h3>
<ul>
<li><p>时间复杂度：<span
class="math display">\[O(n^2)\]</span>。</p></li>
<li><p>空间复杂度：<span class="math display">\[O(n)\]</span>。</p></li>
</ul>
<h3 id="思考题">思考题</h3>
<p>对于给定的排列 <span class="math display">\[a_1, a_2, \cdots,
a_n\]</span> ，你能求出 k 吗？</p>
<p>解答： <span class="math display">\[
k = \left( \sum_{i=1}^n \textit{order}(a_i) \cdot (n-i)! \right) + 1
\]</span> 其中 <span
class="math display">\[\textit{order}(a_i)\]</span>表示 <span
class="math display">\[a_{i+1}, \cdots, a_n\]</span>中小于 <span
class="math display">\[a_i\]</span>的元素个数。</p>
<h3 id="反思">反思</h3>
<p>我在分析这个问题的时候只考虑到了第一项怎么确定，然后就用递归来求解问题，中间忽略了n和k的取值特例。分析不够完备，代码看着比较乱，可读性不强。今后分析的时候还是要把问题分析完整了再编代码，比如推出这道题的通项公式后再写代码。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://txing-casia.github.io/2020/09/04/2020-09-04-Q257%20Binary%20Tree%20Paths-%E7%AE%80%E5%8D%95-%E6%B7%B1%E5%BA%A6and%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/my_photo.jpg">
      <meta itemprop="name" content="Txing">
      <meta itemprop="description" content="泛用人形决战型机器人博士">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Txing">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/04/2020-09-04-Q257%20Binary%20Tree%20Paths-%E7%AE%80%E5%8D%95-%E6%B7%B1%E5%BA%A6and%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/" class="post-title-link" itemprop="url">Q257 Binary Tree Paths-简单-深度/广度优先搜索</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-04 00:00:00" itemprop="dateCreated datePublished" datetime="2020-09-04T00:00:00+08:00">2020-09-04</time>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>2.1k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>2 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="binary-tree-paths"><a
target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-paths/">Binary Tree
Paths</a></h1>
<h2 id="question">Question</h2>
<blockquote>
<p>Given a binary tree, return all root-to-leaf paths.</p>
<p>Note: A leaf is a node with no children.</p>
</blockquote>
<blockquote>
<p><strong>Example 1:</strong></p>
<p>Input:</p>
<pre><code>1</code></pre>
<p>/<br />
2 3<br />
5</p>
<p>Output: ["1-&gt;2-&gt;5", "1-&gt;3"]</p>
<p>Explanation: All root-to-leaf paths are: 1-&gt;2-&gt;5, 1-&gt;3</p>
</blockquote>
<h3 id="approach-1-深度优先搜索">Approach 1: 深度优先搜索</h3>
<p>最直观的方法是使用深度优先搜索。在深度优先搜索遍历二叉树时，我们需要考虑当前的节点以及它的孩子节点。</p>
<p>如果当前节点不是叶子节点，则在当前的路径末尾添加该节点，并继续递归遍历该节点的每一个叶子节点。
如果当前节点是叶子节点，则在当前路径末尾添加该节点后我们就得到了一条从根节点到叶子节点的路径，将该路径加入到答案即可。
如此，当遍历完整棵二叉树以后我们就得到了所有从根节点到叶子节点的路径。当然，深度优先搜索也可以使用非递归的方式实现，这里不再赘述。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">binaryTreePaths</span>(<span class="params">self, root</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">construct_paths</span>(<span class="params">root, path</span>):</span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                path += <span class="built_in">str</span>(root.val)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:  <span class="comment"># 当前节点是叶子节点</span></span><br><span class="line">                    paths.append(path)  <span class="comment"># 把路径加入到答案中</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    path += <span class="string">&#x27;-&gt;&#x27;</span>  <span class="comment"># 当前节点不是叶子节点，继续递归遍历</span></span><br><span class="line">                    construct_paths(root.left, path)</span><br><span class="line">                    construct_paths(root.right, path)</span><br><span class="line"></span><br><span class="line">        paths = []</span><br><span class="line">        construct_paths(root, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> paths</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析">复杂度分析</h3>
<ul>
<li><p>时间复杂度：<span class="math display">\[O(N^2)\]</span>，其中 N
表示节点数目。在深度优先搜索中每个节点会被访问一次且只会被访问一次，每一次会对
path 变量进行拷贝构造，时间代价为 O(N)，故时间复杂度为 <span
class="math display">\[ O(N^2)\]</span>。</p></li>
<li><p>空间复杂度：<span class="math display">\[O(N^2)\]</span>，其中 N
表示节点数目。除答案数组外我们需要考虑递归调用的栈空间。在最坏情况下，当二叉树中每个节点只有一个孩子节点时，即整棵二叉树呈一个链状，此时递归的层数为
N，此时每一层的 path 变量的空间代价的总和为 <span
class="math display">\[O(\sum_{i = 1}^{N} i) = O(N^2)\]</span>
空间复杂度为 <span
class="math display">\[O(N^2)\]</span>。最好情况下，当二叉树为平衡二叉树时，它的高度为
<span class="math display">\[\log N\]</span>，此时空间复杂度为 <span
class="math display">\[O((\log {N})^2)\]</span>。</p></li>
<li><p><strong>平衡二叉树</strong>（Balanced Binary
Tree）又被称为AVL树（有别于AVL算法），且具有以下性质：它是一
棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p></li>
</ul>
<h3 id="approach-2-广度优先搜索">Approach 2: 广度优先搜索</h3>
<p>我们也可以用广度优先搜索来实现。我们维护一个队列，存储节点以及根到该节点的路径。一开始这个队列里只有根节点。在每一步迭代中，我们取出队列中的首节点，如果它是叶子节点，则将它对应的路径加入到答案中。如果它不是叶子节点，则将它的所有孩子节点加入到队列的末尾。当队列为空时广度优先搜索结束，我们即能得到答案。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">binaryTreePaths</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        paths = <span class="built_in">list</span>()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> paths</span><br><span class="line"></span><br><span class="line">        node_queue = collections.deque([root])</span><br><span class="line">        path_queue = collections.deque([<span class="built_in">str</span>(root.val)])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> node_queue:</span><br><span class="line">            node = node_queue.popleft()</span><br><span class="line">            path = path_queue.popleft()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                paths.append(path)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    node_queue.append(node.left)</span><br><span class="line">                    path_queue.append(path + <span class="string">&#x27;-&gt;&#x27;</span> + <span class="built_in">str</span>(node.left.val))</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    node_queue.append(node.right)</span><br><span class="line">                    path_queue.append(path + <span class="string">&#x27;-&gt;&#x27;</span> + <span class="built_in">str</span>(node.right.val))</span><br><span class="line">        <span class="keyword">return</span> paths</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析-1">复杂度分析</h3>
<ul>
<li>时间复杂度：<span class="math display">\[O(N^2)\]</span>，其中 N
表示节点数目。分析同方法一。</li>
<li>空间复杂度：<span class="math display">\[O(N^2)\]</span>，其中 N
表示节点数目。在最坏情况下，队列中会存在 N
个节点，保存字符串的队列中每个节点的最大长度为 N，故空间复杂度为 <span
class="math display">\[O(N^2)\]</span></li>
</ul>
<h3 id="section"></h3>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://txing-casia.github.io/2020/09/03/2020-09-03-Q51-N%E7%9A%87%E5%90%8E-%E5%9B%B0%E9%9A%BE-%E6%8E%92%E5%88%97%E6%9E%9A%E4%B8%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/my_photo.jpg">
      <meta itemprop="name" content="Txing">
      <meta itemprop="description" content="泛用人形决战型机器人博士">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Txing">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/03/2020-09-03-Q51-N%E7%9A%87%E5%90%8E-%E5%9B%B0%E9%9A%BE-%E6%8E%92%E5%88%97%E6%9E%9A%E4%B8%BE/" class="post-title-link" itemprop="url">Q51 N皇后-困难-排列枚举</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-03 00:00:00" itemprop="dateCreated datePublished" datetime="2020-09-03T00:00:00+08:00">2020-09-03</time>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>5.4k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>5 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="n皇后"><a
target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/n-queens/">N皇后</a></h1>
<h2 id="question">Question</h2>
<blockquote>
<p><em>n</em> 皇后问题研究的是如何将 <em>n</em> 个皇后放置在
<em>n</em>×<em>n</em> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p>给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。</p>
<p>每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 'Q' 和
'.' 分别代表了皇后和空位。</p>
</blockquote>
<blockquote>
<p><strong>Example 1:</strong></p>
<p>输入：4 输出：[ [".Q..", // 解法 1 "...Q", "Q...", "..Q."],</p>
<p>["..Q.", // 解法 2 "Q...", "...Q", ".Q.."] ] 解释: 4
皇后问题存在两个不同的解法。</p>
</blockquote>
<blockquote>
<p><strong>提示：</strong></p>
<p>皇后彼此不能相互攻击，也就是说：任何两个皇后都不能处于同一条横行、纵行或斜线上。</p>
</blockquote>
<h3 id="前言">前言</h3>
<p>「N 皇后问题」研究的是如何将 N 个皇后放置在 N×N
的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p>皇后的走法是：可以横直斜走，格数不限。因此要求皇后彼此之间不能相互攻击，等价于要求任何两个皇后都不能在同一行、同一列以及同一条斜线上。</p>
<p>直观的做法是暴力枚举将 NN 个皇后放置在 N NN×N
的棋盘上的所有可能的情况，并对每一种情况判断是否满足皇后彼此之间不相互攻击。暴力枚举的时间复杂度是非常高的，因此必须利用限制条件加以优化。</p>
<p>显然，每个皇后必须位于不同行和不同列，因此将 N 个皇后放置在 N×N
的棋盘上，一定是每一行有且仅有一个皇后，每一列有且仅有一个皇后，且任何两个皇后都不能在同一条斜线上。基于上述发现，可以通过回溯的方式寻找可能的解。</p>
<p>回溯的具体做法是：使用一个数组记录每行放置的皇后的列下标，依次在每一行放置一个皇后。每次新放置的皇后都不能和已经放置的皇后之间有攻击：即新放置的皇后不能和任何一个已经放置的皇后在同一列以及同一条斜线上，并更新数组中的当前行的皇后列下标。当
NN
个皇后都放置完毕，则找到一个可能的解。当找到一个可能的解之后，将数组转换成表示棋盘状态的列表，并将该棋盘状态的列表加入返回列表。</p>
<p>由于每个皇后必须位于不同列，因此已经放置的皇后所在的列不能放置别的皇后。第一个皇后有
N 列可以选择，第二个皇后最多有 N−1 列可以选择，第三个皇后最多有 N−2
列可以选择（如果考虑到不能在同一条斜线上，可能的选择数量更少），因此所有可能的情况不会超过
N! 种，遍历这些情况的时间复杂度是 O(N!)。</p>
<p>为了降低总时间复杂度，每次放置皇后时需要快速判断每个位置是否可以放置皇后，显然，最理想的情况是在
O(1) 的时间内判断该位置所在的列和两条斜线上是否已经有皇后。</p>
<p>以下两种方法分别使用集合和位运算对皇后的放置位置进行判断，都可以在
O(1) 的时间内判断一个位置是否可以放置皇后，算法的总时间复杂度都是
O(N!)。</p>
<h3 id="approach-1-基于集合的回溯">Approach 1: 基于集合的回溯</h3>
<p>为了判断一个位置所在的列和两条斜线上是否已经有皇后，使用三个集合
<span class="math display">\[columns\]</span>、<span
class="math display">\[\textit{diagonals}_1\]</span>和 <span
class="math display">\[\textit{diagonals}_2
\]</span>分别记录每一列以及两个方向的每条斜线上是否有皇后。</p>
<p>列的表示法很直观，一共有 N 列，每一列的下标范围从 0 到
N−1，使用列的下标即可明确表示每一列。</p>
<p>如何表示两个方向的斜线呢？对于每个方向的斜线，需要找到斜线上的每个位置的行下标与列下标之间的关系。</p>
<p>方向一的斜线为从左上到右下方向，同一条斜线上的每个位置满足<strong>行下标与列下标之差相等</strong>，例如
(0,0)和(3,3)
在同一条方向一的斜线上。因此使用行下标与列下标之差即可明确表示每一条方向一的斜线。</p>
<p>方向二的斜线为从右上到左下方向，同一条斜线上的每个位置满足<strong>行下标与列下标之和相等</strong>，例如
(3,0) 和 (1,2)
在同一条方向二的斜线上。因此使用行下标与列下标之和即可明确表示每一条方向二的斜线。</p>
<p>每次放置皇后时，对于每个位置判断其是否在三个集合中，如果三个集合都不包含当前位置，则当前位置是可以放置皇后的位置。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">solveNQueens1</span>(<span class="params">self, n</span>) :</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">generateBoard</span>():</span><br><span class="line">            board = <span class="built_in">list</span>()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                row[queens[i]] = <span class="string">&quot;Q&quot;</span></span><br><span class="line">                board.append(<span class="string">&quot;&quot;</span>.join(row)) <span class="comment"># join 连接字符串</span></span><br><span class="line">                row[queens[i]] = <span class="string">&quot;.&quot;</span></span><br><span class="line">            <span class="keyword">return</span> board</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">row: <span class="built_in">int</span></span>):</span><br><span class="line">            <span class="keyword">if</span> row == n:</span><br><span class="line">                board = generateBoard()</span><br><span class="line">                solutions.append(board)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                    <span class="keyword">if</span> i <span class="keyword">in</span> columns <span class="keyword">or</span> row - i <span class="keyword">in</span> diagonal1 <span class="keyword">or</span> row + i <span class="keyword">in</span> diagonal2:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    queens[row] = i</span><br><span class="line">                    columns.add(i)</span><br><span class="line">                    diagonal1.add(row - i)</span><br><span class="line">                    diagonal2.add(row + i)</span><br><span class="line">                    backtrack(row + <span class="number">1</span>)</span><br><span class="line">                    columns.remove(i)</span><br><span class="line">                    diagonal1.remove(row - i)</span><br><span class="line">                    diagonal2.remove(row + i)</span><br><span class="line">                    </span><br><span class="line">        solutions = <span class="built_in">list</span>()</span><br><span class="line">        queens = [-<span class="number">1</span>] * n</span><br><span class="line">        columns = <span class="built_in">set</span>()</span><br><span class="line">        diagonal1 = <span class="built_in">set</span>()</span><br><span class="line">        diagonal2 = <span class="built_in">set</span>()</span><br><span class="line">        row = [<span class="string">&quot;.&quot;</span>] * n</span><br><span class="line">        backtrack(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> solutions</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    s = <span class="number">6</span></span><br><span class="line">    solution=Solution().solveNQueens1(s)</span><br><span class="line">    <span class="built_in">print</span>(solution)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析">复杂度分析</h3>
<ul>
<li><p>时间复杂度：O(N!)，其中 N 是皇后数量</p></li>
<li><p>空间复杂度：O(N)，其中 N
是皇后数量。空间复杂度主要取决于递归调用层数、记录每行放置的皇后的列下标的数组以及三个集合，递归调用层数不会超过
N，数组的长度为 N，每个集合的元素个数都不会超过 N。</p></li>
</ul>
<h3 id="approach-2-基于位运算的回溯">Approach 2: 基于位运算的回溯</h3>
<p>方法一使用三个集合记录分别记录每一列以及两个方向的每条斜线上是否有皇后，每个集合最多包含
N 个元素，因此集合的空间复杂度是
O(N)。如果利用位运算记录皇后的信息，就可以将记录皇后信息的空间复杂度从
O(N) 降到 O(1)。</p>
<p>具体做法是，使用三个整数 <span
class="math display">\[\textit{columns}\]</span>、<span
class="math display">\[\textit{diagonals}_1\]</span> 和 <span
class="math display">\[\textit{diagonals}_2\]</span>分别记录每一列以及两个方向的每条斜线上是否有皇后，每个整数有
N
个二进制位。棋盘的每一列对应每个整数的二进制表示中的一个数位，其中棋盘的最左列对应每个整数的最低二进制位，最右列对应每个整数的最高二进制位。</p>
<p>那么如何根据每次放置的皇后更新三个整数的值呢？在说具体的计算方法之前，首先说一个例子。</p>
<p>棋盘的边长和皇后的数量
N=8。如果棋盘的前两行分别在（0,2）和（1,4）放置了皇后（下标从 0
开始），则棋盘的前两行如下图所示。</p>
<p>如果要在下一行放置皇后，哪些位置不能放置呢？我们用 0
代表可以放置皇后的位置，1 代表不能放置皇后的位置。</p>
<p>新放置的皇后不能和任何一个已经放置的皇后在同一列，因此不能放置在第 2
列和第 4 列，对应 <span
class="math display">\[\textit{columns}=00010100_{(2)}\]</span> 。</p>
<p>新放置的皇后不能和任何一个已经放置的皇后在同一条方向一（从左上到右下方向）的斜线上，因此不能放置在第
4 列和第 5 列，对应 <span
class="math display">\[\textit{diagonals}_1=00110000_{(2)}\]</span>。其中，第
4 列为其前两行的第 2 列的皇后往右下移动两步的位置，第 5 列为其前一行的第
4 列的皇后往右下移动一步的位置。</p>
<p>新放置的皇后不能和任何一个已经放置的皇后在同一条方向二（从右上到左下方向）的斜线上，因此不能放置在第
0 列和第 3 列，对应 <span
class="math display">\[\textit{diagonals}_2=00001001_{(2)}\]</span>。其中，第
0 列为其前两行的第 2 列的皇后往左下移动两步的位置，第 3 列为其前一行的第
4 列的皇后往左下移动一步的位置。</p>
<p>由此可以得到三个整数的计算方法：</p>
<ul>
<li>初始时，三个整数的值都等于 0，表示没有放置任何皇后；</li>
<li>在当前行放置皇后，如果皇后放置在第 i 列，则将三个整数的第 i
个二进制位（指从低到高的第 i 个二进制位）的值设为 1;</li>
<li>进入下一行时，<span class="math display">\[\textit{columns}\]</span>
的值保持不变，<span class="math display">\[\textit{diagonals}_1\]</span>
左移一位，<span class="math display">\[\textit{diagonals}_2\]</span>
右移一位，由于棋盘的最左列对应每个整数的最低二进制位，即每个整数的最右二进制位，因此对整数的移位操作方向和对棋盘的移位操作方向相反（对棋盘的移位操作方向是
<span
class="math display">\[\textit{diagonals}_1\]</span>右移一位，<span
class="math display">\[\textit{diagonals}_2\]</span>左移一位）。</li>
</ul>
<p>每次放置皇后时，三个整数的按位或运算的结果即为不能放置皇后的位置，其余位置即为可以放置皇后的位置。可以通过
<span class="math display">\[(2^n-1)~\&amp;~(\sim(\textit{columns} |
\textit{diagonals}_1 |
\textit{diagonals}_2))\]</span>得到可以放置皇后的位置（该结果的值为 1
的位置表示可以放置皇后的位置），然后遍历这些位置，尝试放置皇后并得到可能的解。</p>
<p>遍历可以放置皇后的位置时，可以利用以下两个按位与运算的性质：</p>
<ul>
<li><p><span class="math display">\[x~\&amp;~(-x)\]</span>可以获得 x
的二进制表示中的最低位的 1 的位置；</p></li>
<li><p><span class="math display">\[x~\&amp;~(x-1)\]</span> 可以将 x
的二进制表示中的最低位的 1 置成 0。</p></li>
</ul>
<p>具体做法是，每次获得可以放置皇后的位置中的最低位，并将该位的值置成
0，尝试在该位置放置皇后。这样即可遍历每个可以放置皇后的位置。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">solveNQueens2</span>(<span class="params">self, n</span>) :</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">generateBoard</span>():</span><br><span class="line">            board = <span class="built_in">list</span>()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                row[queens[i]] = <span class="string">&quot;Q&quot;</span></span><br><span class="line">                board.append(<span class="string">&quot;&quot;</span>.join(row))</span><br><span class="line">                row[queens[i]] = <span class="string">&quot;.&quot;</span></span><br><span class="line">            <span class="keyword">return</span> board</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">solve</span>(<span class="params">row: <span class="built_in">int</span>, columns: <span class="built_in">int</span>, diagonals1: <span class="built_in">int</span>, diagonals2: <span class="built_in">int</span></span>):</span><br><span class="line">            <span class="keyword">if</span> row == n:</span><br><span class="line">                board = generateBoard()</span><br><span class="line">                solutions.append(board)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                availablePositions = ((<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>) &amp; (~(columns | diagonals1 | diagonals2))</span><br><span class="line">                <span class="keyword">while</span> availablePositions:</span><br><span class="line">                    position = availablePositions &amp; (-availablePositions)</span><br><span class="line">                    availablePositions = availablePositions &amp; (availablePositions - <span class="number">1</span>)</span><br><span class="line">                    column = <span class="built_in">bin</span>(position - <span class="number">1</span>).count(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">                    queens[row] = column</span><br><span class="line">                    solve(row + <span class="number">1</span>, columns | position, (diagonals1 | position) &lt;&lt; <span class="number">1</span>, (diagonals2 | position) &gt;&gt; <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        solutions = <span class="built_in">list</span>()</span><br><span class="line">        queens = [-<span class="number">1</span>] * n</span><br><span class="line">        row = [<span class="string">&quot;.&quot;</span>] * n</span><br><span class="line">        solve(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> solutions</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    s = <span class="number">6</span></span><br><span class="line">    solution=Solution().solveNQueens2(s)</span><br><span class="line">    <span class="built_in">print</span>(solution)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析-1">复杂度分析</h3>
<ul>
<li><p>时间复杂度：O(N!)，其中 N 是皇后数量。</p></li>
<li><p>空间复杂度：O(N)，其中 N
是皇后数量。由于使用位运算表示，因此存储皇后信息的空间复杂度是
O(1)，空间复杂度主要取决于递归调用层数和记录每行放置的皇后的列下标的数组，递归调用层数不会超过
N，数组的长度为 N。</p></li>
</ul>
<h3 id="小结">小结</h3>
<p>回顾这道题，拿到这道题的时候，其实我们很容易看出需要使用枚举的方法来求解这个问题，当我们不知道用什么办法来枚举是最优的时候，可以从下面三个方向考虑：</p>
<ul>
<li><p>子集枚举：可以把问题转化成「从 <span
class="math display">\[n^2\]</span>个格子中选一个子集，使得子集中恰好有
n 个格子，且任意选出两个都不在同行、同列或者同对角线」，这里枚举的规模是
<span class="math display">\[2^{n^2}\]</span>;</p></li>
<li><p>组合枚举：可以把问题转化成「从 <span
class="math display">\[n^2\]</span> 个格子中选择 n
个，且任意选出两个都不在同行、同列或者同对角线」，这里的枚举规模是 <span
class="math display">\[{n^2} \choose {n}\]</span>;</p></li>
<li><p>排列枚举：因为这里每行只能放置一个皇后，而所有行中皇后的列号正好构成一个
1 到 n 的排列，所以我们可以把问题转化为一个排列枚举，规模是
n!。</p></li>
</ul>
<p>带入一些 n
进这三种方法验证，就可以知道哪种方法的枚举规模是最小的，这里我们发现第三种方法的枚举规模最小。这道题给出的两个方法其实和排列枚举的本质是类似的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/21/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/21/">21</a><span class="page-number current">22</span><a class="page-number" href="/page/23/">23</a><span class="space">&hellip;</span><a class="page-number" href="/page/30/">30</a><a class="extend next" rel="next" href="/page/23/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Txing"
      src="/images/my_photo.jpg">
  <p class="site-author-name" itemprop="name">Txing</p>
  <div class="site-description" itemprop="description">泛用人形决战型机器人博士</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">233</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">58</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/txing-casia" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;txing-casia" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://blog.uomi.moe/" title="https:&#x2F;&#x2F;blog.uomi.moe" rel="noopener" target="_blank">驱逐舰患者</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://m.mepai.me/photographyer/u_5a68085ba15aa.html?tdsourcetag=s_pctim_aiomsg" title="https:&#x2F;&#x2F;m.mepai.me&#x2F;photographyer&#x2F;u_5a68085ba15aa.html?tdsourcetag&#x3D;s_pctim_aiomsg" rel="noopener" target="_blank">隐之-INF</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2018 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Txing</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">568k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">8:36</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

</body>
</html>
