<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"txing-casia.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":240,"display":"post","padding":18,"offset":12,"onmobile":true},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="泛用人形决战型机器人博士">
<meta property="og:type" content="website">
<meta property="og:title" content="Txing">
<meta property="og:url" content="https://txing-casia.github.io/page/9/index.html">
<meta property="og:site_name" content="Txing">
<meta property="og:description" content="泛用人形决战型机器人博士">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Txing">
<meta property="article:tag" content="Txing">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://txing-casia.github.io/page/9/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Txing</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Txing</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">欢迎来到 | 伽蓝之堂</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://txing-casia.github.io/2021/07/22/2021-07-22-Reinforcement%20Learning%20-%20Intrinsically%20Motivated%20Reinforcement%20Learning%20An%20Evolutionary%20Perspective/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/my_photo.jpg">
      <meta itemprop="name" content="Txing">
      <meta itemprop="description" content="泛用人形决战型机器人博士">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Txing">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/22/2021-07-22-Reinforcement%20Learning%20-%20Intrinsically%20Motivated%20Reinforcement%20Learning%20An%20Evolutionary%20Perspective/" class="post-title-link" itemprop="url">Reinforcement Learning | Intrinsically Motivated Reinforcement Learning: An Evolutionary Perspective</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-07-22 00:00:00" itemprop="dateCreated datePublished" datetime="2021-07-22T00:00:00+08:00">2021-07-22</time>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>5.8k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>5 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1
id="intrinsically-motivated-reinforcement-learning-an-evolutionary-perspective">Intrinsically
Motivated Reinforcement Learning: An Evolutionary Perspective</h1>
<p>论文链接：https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&amp;arnumber=5471106</p>
<h2 id="主要内容">主要内容</h2>
<ul>
<li><p>intrinsically motivated
这个词最开始是在1950年的文章中提出的，文章认为需要有一种内在的操纵驱动力来解释为什么猴子会在没有任何外在奖励的情况下精力充沛地持续工作数小时来解决复杂的机械难题。内在动机行为对智力增长至关重要</p></li>
<li><p>本文解决了如何在人工系统中实现类似于内在动机的过程的问题，特别关注可能会或可能不会区分内在动机和外在动机的因素，其中外在动机是指由行为的特定奖励结果产生的动机，而不是行为本身。</p></li>
<li><p>相关工作：</p>
<ul>
<li><p>定义有趣度：Lenat's AM system [18], for example, focused on
heuristic definitions of “interestingness,”</p></li>
<li><p>建立好奇心框架：Schmidhuber [32] [33] [34] [35] [36] [37]
introduced methods for implementing forms of curiosity using the
framework of computational reinforcement learning (RL)1 [47].</p></li>
<li><p>奖励函数设计：Other researchers have reported interesting results
of computational experiments involving evolutionary search for RL reward
functions [1], [8], [19], [31], [43], but they did not directly address
the motivational issues on which we focus.</p></li>
<li><p>寻找本质奖励：Uchibe and Doya [51] do address intrinsic reward in
an evolutionary context, but their aim and approach differ significantly
from ours.</p>
<p>[51]. E. Uchibe and K. Doya, "Finding intrinsic rewards by embodied
evolution and constrained reinforcement learning", <em>Neural
Netw.</em>, vol. 21, no. 10, pp. 1447-1455, 2008.</p></li>
<li><p>与我们最接近的研究是 Elfwing
等人的研究。[11]其中使用遗传算法来搜索塑造奖励[23]和其他提高 RL
学习系统性能的学习算法参数。</p>
<p>[11]. S. Elfwing, E. Uchibe, K. Doya and H. I. Christensen,
"Co-evolution of shaping rewards and meta-parameters in reinforcement
learning", <em>Adapt. Behav.</em>, vol. 16, pp. 400-412, 2008.</p></li>
</ul></li>
<li><p>使用RL的模型结构示意图</p></li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/txing-casia/txing-casia.github.io/master/img/20210722-1.png"
alt="Agent–environment interactions in reinforcement learning" />
<figcaption aria-hidden="true">Agent–environment interactions in
reinforcement learning</figcaption>
</figure>
<ul>
<li><p>这篇文章[3]使用属于内部奖励（intrinsic
reward），并将其与强化学习框架结合。所谓内部奖励，就是内部动机生成的奖励函数；外部奖励就是常规的强化学习框架的奖励函数。</p>
<p>[3]. A. G. Barto, S. Singh and N. Chentanez, "Intrinsically motivated
learning of hierarchical collections of skills", <em>Proc. Int. Conf.
Develop. Learn.</em>, 2004.</p></li>
<li><p>目前的方法基本都是构建特殊的内部奖励函数，并且将其与一般的强化学习算法结合。例如基于好奇心的内部驱动方法[32]。</p>
<p>[32]. J. Schmidhuber, <em>Adaptive Confidence and Adaptive
Curiosity</em>, 1991.</p></li>
<li><p>这种内部动机的RL框架更加符合生物实际。并且奖励和奖励信号是不同的概念，RL模型中使用的更类似于奖励信号。</p>
<ul>
<li><p>奖励（Reward）指的是获得的好处；</p></li>
<li><p>奖励信号（Reward signal）指的是大脑中奖励神经元发放的信号；</p>
<p>Schultz [38], [39] writes that “Rewards are objects or events that
make us come back for more,” whereas reward signals are produced by
reward neurons in the brain.</p></li>
</ul></li>
<li><p>RL中的环境应该分为an external environment 和 an internal
environment.</p></li>
<li><p>但是并不能从行为上区分是否使用了内部奖励[25]。但是内部动机是通过外部奖励形成的。</p>
<p>[25]. P.-Y. Oudeyer and F. Kaplan, "What is intrinsic motivation? A
typology of computational approaches", <em>Frontiers Neurorobot.</em>,
2007.</p></li>
<li><p>Primary and Secondary
Reward：使用内部动机意义在于作为一种次要的奖励信号，配合主要的外部奖励信号完成行为</p></li>
<li><p>生物动机心理学依据：</p>
<p>Among the most influential theories of motivation in psychology is
the drive theory of Hull [13] [14] [15]. According to Hull's theory, all
behavior is motivated either by an organism's survival and reproductive
needs giving rise to primary drives (such as hunger, thirst, sex, and
the avoidance of pain), or by derivative drives that have acquired their
motivational significance through learning. Primary drives are the
result of physiological deficits—“tissue needs”— and they energize
behavior whose result is to reduce the deficit. A key additional feature
of Hull's theory is that a need reduction, and hence a drive reduction,
acts as a primary reinforcer for learning: behavior that reduces a
primary drive is reinforced. Additionally, through the process of
secondary reinforcement in which a neutral stimulus is paired with a
primary reinforcer, the formerly neutral stimulus becomes a secondary
reinforcer, i.e., acquires the reinforcing power of the primary
reinforcer. In this way, stimuli that predict primary reward, i.e.,
predict a reduction in a primary drive, become rewarding themselves.
According to this influential theory (in its several variants), all
behavior is energized and directed by its relevance to primal drives,
either directly or as the result of learning through secondary
reinforcement.</p></li>
<li><p>一些驱动力对行为影响的例子，在某些条件下，饥饿的老鼠宁愿探索不熟悉的空间，也不愿进食；他们忍受穿越电网的痛苦，去探索新的空间。</p></li>
<li><p>但是饥饿、口渴、繁衍这些驱动都伴随着满足的状态，他们是否能作为次要驱动还是有待研究。下面介绍基于进化的观点。</p></li>
<li><p>使用一个适应度函数和一些环境兴趣的分布（an explicit fitness
function and some distribution of environments of
interest），这个适应度可以是累积的外部奖励和等形式。</p></li>
<li><p><strong>实验1：</strong></p></li>
<li><p>一个6x6的格子空间中分割了4个3x3的子空间，格子之间的墙壁不是全部封闭的，其中2个子格子空间中分别有一个打开的盒子和一个封闭的盒子（盒子位置在智能体生命周期内是不再变化的），一个打开的盒子在每个时间步以
0.1
的概率关闭，密闭的盒子里总是装着食物。智能体在这样的格子迷宫中要找到打开的盒子，并在封闭的盒子中寻找食物。智能体的行动分为上下左右4个方向。</p></li>
<li><p>当代理食用食物时，它会在一个时间步长内感到饱足。代理在所有其他时间步都饥饿。智能体每吃一次食物，它的适应度就会增加
1</p></li>
<li><p>在格子迷宫环境中假设了两只钟情况：</p>
<ol type="1">
<li>constant condition:
食物总是智能体10000步生命周期中，在封闭的盒子中出现；</li>
<li>step condition:
智能体的生命周期是20000步，食物总是出现在10000步之后出现在封闭盒子中；</li>
</ol></li>
<li><p>符号说明：</p>
<ul>
<li>agent <span class="math display">\[\mathcal{A}\]</span></li>
<li>a space of reward function <span
class="math display">\[R_\mathcal{A}\]</span></li>
<li>a specific reward function <span
class="math display">\[r_\mathcal{A} \in R_\mathcal{A}\]</span></li>
<li>a sampled environment <span class="math display">\[E \sim
P(\varepsilon)\]</span></li>
<li>history of agent <span class="math display">\[\mathcal{A}\]</span>
adapting to environment <span class="math display">\[E\]</span> over its
lifetime using the reward function <span
class="math display">\[r_\mathcal{A}\]</span>, i.e., <span
class="math display">\[h \sim \langle
\mathcal{A}(r_\mathcal{A}),E\rangle\]</span></li>
<li>fitness function <span class="math display">\[\mathcal{F}\]</span>
produces a scalar evaluation <span
class="math display">\[\mathcal{F}(h)\]</span> for each history <span
class="math display">\[h\]</span></li>
<li>optimal reward function <span
class="math display">\[r^*_{\mathcal{A}} \in
R_{\mathcal{A}}\]</span></li>
</ul></li>
</ul>
<p><span class="math display">\[
r^*_{\mathcal{A}}=\arg \max_{r_\mathcal{A} \in R_\mathcal{A}}
\mathbb{E}_{E\sim P(\varepsilon)} \mathbb{E}_{h \sim \langle
\mathcal{A}(r_\mathcal{A}),E\rangle}[\mathcal{F}(h)]
\]</span></p>
<ul>
<li><p>使用的算法 the lookup-table -greedy Q-learning [52].</p>
<p>[52]. C. J. C. H. Watkins, “Learning from Delayed Rewards,” Ph.D.
dissertation, Cambridge Univ., Cambridge, U.K., 1989</p></li>
</ul>
<p><span class="math display">\[
Q_{t+1}(s_t,a_t)=(1-\alpha)Q_t(s_t,a_t)+\alpha[r_t + \gamma \max_b
(Q_t(s_{t+1},b))]
\]</span></p>
<p>之后通过实验验证了<span
class="math display">\[r*\]</span>的奖励函数趋近最优奖励函数</p>
<ul>
<li><p><strong>实验2</strong></p>
<ul>
<li>一个三走廊的觅食环境，虫子每次随机出现正在其中一个走廊的尽头。由于每次虫子的位置是随机且未知的，智能体过去的经验不能直接直到新的觅食，所以这个环境是非马尔科夫的。</li>
<li>实验要求智能体在固定的10000步之内尽可能多地吃到虫子。</li>
</ul>
<p><span class="math display">\[
Q_d(s,a)=r_{\mathcal{A}}(s,a)+\gamma\sum_{s&#39;\in \mathcal{S}}
\hat{T}(s&#39;|s,a)\max_{a&#39;} Q_{d-1}(s&#39;,a&#39;)\\
\hat{T}(s&#39;|s,a)=\frac{n_{s,a,s&#39;}}{n_{s,a}}
\]</span></p>
<p>其中 <span class="math display">\[n_{s,a,s&#39;}\]</span> 表示在
<span class="math display">\[s\]</span> 状态下，选择 <span
class="math display">\[a\]</span> 后转移到 <span
class="math display">\[s&#39;\]</span> 的次数。 <span
class="math display">\[n_{s,a}\]</span> 表示在 <span
class="math display">\[s\]</span> 状态下，选择 <span
class="math display">\[a\]</span> 的次数。</p></li>
<li><p>奖励函数：<span
class="math display">\[r_{\mathcal{A}}(s,a)=\beta_F\varPhi_F(s) +
\beta_c\varPhi_c(s,a,h)\]</span> ，其中 <span
class="math display">\[\beta_F\]</span> 和 <span
class="math display">\[\beta_c\]</span> 是权重系数。特征 <span
class="math display">\[\varPhi_F(s)\]</span> 在智能体饱的时候是 1
，其他时候是 0 。特征 <span class="math display">\[\varPhi_c(s,a,h) =
1-\frac{1}{c(s,a,h)}\]</span> ，其中 <span
class="math display">\[c(s,a,h)\]</span> 是智能体在历史 <span
class="math display">\[h\]</span> 中执行行为的时间步数。</p></li>
<li><p>当参数 <span class="math display">\[\beta_c\]</span>
为正时，智能体会因为最近没有从当前状态采取的行动而获得奖励。这种奖励不是外部环境的固定函数.
feature <span class="math display">\[\varPhi_F(s)\]</span> is a
hunger-status feature, and thus when <span
class="math display">\[\beta_F=1\]</span> and <span
class="math display">\[\beta_c=0\]</span>, the reward function is the
fitness-based reward function</p></li>
</ul>
<p>最终基于适应度的奖励函数表现次于最优奖励函数2个数量级。因此利用内在奖励
<span class="math display">\[\varPhi_c(s,a,h)\]</span>
对提升探索能力很有意义。</p>
<h2 id="总结">总结</h2>
<p>视角很独特，实验很新奇。</p>
<p>但是文章发表在自主心理发展IEEE TRANSACTIONS ON AUTONOMOUS MENTAL
DEVELOPMENT，因此作为一篇概念文章比较好。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://txing-casia.github.io/2021/07/21/2021-07-21-Q134-%E5%8A%A0%E6%B2%B9%E7%AB%99-%E4%B8%AD%E7%AD%89-%E8%B4%AA%E5%BF%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/my_photo.jpg">
      <meta itemprop="name" content="Txing">
      <meta itemprop="description" content="泛用人形决战型机器人博士">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Txing">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/21/2021-07-21-Q134-%E5%8A%A0%E6%B2%B9%E7%AB%99-%E4%B8%AD%E7%AD%89-%E8%B4%AA%E5%BF%83/" class="post-title-link" itemprop="url">Q134-加油站-中等-贪心</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-07-21 00:00:00" itemprop="dateCreated datePublished" datetime="2021-07-21T00:00:00+08:00">2021-07-21</time>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>2k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>2 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="加油站"><a
target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/gas-station/">134.
加油站</a></h4>
<h2 id="question">Question</h2>
<blockquote>
<p>在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p>
<p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1
个加油站需要消耗汽油 cost[i]
升。你从其中的一个加油站出发，开始时油箱为空。</p>
<p>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p>
<p><strong>说明:</strong></p>
<ul>
<li>如果题目有解，该答案即为唯一答案。</li>
<li>输入数组均为非空数组，且长度相同。</li>
<li>输入数组中的元素均为非负数。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>Example 1:</strong></p>
<p>输入: gas = [1,2,3,4,5] cost = [3,4,5,1,2]</p>
<p>输出: 3</p>
<p>解释: 从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0
+ 4 = 4 升汽油 开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油 开往 0
号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油 开往 1 号加油站，此时油箱有 7
- 3 + 2 = 6 升汽油 开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油 开往
3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。 因此，3
可为起始索引。</p>
</blockquote>
<blockquote>
<p><strong>Example 2:</strong></p>
<p>输入: gas = [2,3,4] cost = [3,4,3]</p>
<p>输出: -1</p>
<p>解释: 你不能从 0 号或 1
号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。 我们从 2
号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油 开往 0
号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油 开往 1 号加油站，此时油箱有 3
- 3 + 3 = 3 升汽油 你无法返回 2 号加油站，因为返程需要消耗 4
升汽油，但是你的油箱只有 3 升汽油。
因此，无论怎样，你都不可能绕环路行驶一周。</p>
</blockquote>
<h3 id="approach-1-直接求解">Approach 1: 直接求解</h3>
<p>这个方法比较笨，但是最直接。</p>
<p>把一次环形拆分为3段：</p>
<ul>
<li>出发点到最后一个加油站</li>
<li>最后一个加油站到第一个加油站</li>
<li>第一个加油站到出发点</li>
</ul>
<p>依次计算</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canCompleteCircuit</span>(<span class="params">self, gas: <span class="type">List</span>[<span class="built_in">int</span>], cost: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = -<span class="number">1</span></span><br><span class="line">        <span class="comment"># 以每个加油站为出发点依次正向遍历，直到最后一个加油站</span></span><br><span class="line">        <span class="keyword">for</span> step <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(gas)):</span><br><span class="line">            start = step <span class="comment"># 起始加油站编号</span></span><br><span class="line">            num_step = <span class="number">0</span> <span class="comment"># 走过的加油站数目</span></span><br><span class="line">            oil = gas[start] <span class="comment"># 油箱中油存量</span></span><br><span class="line">            <span class="comment"># 正向遍历到最后一个加油站i+1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(step,<span class="built_in">len</span>(gas)-<span class="number">1</span>):</span><br><span class="line">                oil -= cost[i] </span><br><span class="line">                <span class="keyword">if</span> oil &lt; <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                oil += gas[i+<span class="number">1</span>]</span><br><span class="line">                num_step += <span class="number">1</span></span><br><span class="line">			<span class="comment"># 最后一个加油站到第一个加油站单独判断</span></span><br><span class="line">            oil -= cost[-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> oil &gt;= <span class="number">0</span>:</span><br><span class="line">                oil += gas[<span class="number">0</span>]</span><br><span class="line">                num_step += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 判断是否走完一圈</span></span><br><span class="line">                <span class="keyword">if</span> num_step == <span class="built_in">len</span>(gas):</span><br><span class="line">                    ans = start</span><br><span class="line">                    <span class="keyword">return</span> ans <span class="comment"># 题目说了是唯一解</span></span><br><span class="line">            <span class="keyword">else</span>: <span class="comment"># 油不够，退出循环</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 从第一个加油站遍历到出发的加油站</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(step):</span><br><span class="line">                oil -= cost[j]</span><br><span class="line">                <span class="keyword">if</span> oil &lt; <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                oil += gas[j+<span class="number">1</span>]</span><br><span class="line">                num_step += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> num_step == <span class="built_in">len</span>(gas):</span><br><span class="line">                    ans = start</span><br><span class="line">                    <span class="keyword">return</span> ans</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：<span class="math display">\[O(N^2)\]</span>。</li>
<li>空间复杂度：<span class="math display">\[O(1)\]</span>.</li>
</ul>
<h3 id="approach-2-问题分析简化运算">Approach 2: 问题分析简化运算</h3>
<p>这是个逻辑题。
首先，老司机们都知道，开车的时候，油不能为负数，先变成负数再往后加回来是不可以的。
然后开完一圈回来，如果耗得油总量比加的总量还多那铁定开不回来。</p>
<p>再然后，我们只要遍历一遍就可以了。为什么呢，假设从头开始开一遍，累计下来耗油最多的点的后面那个点开始出发，一定就是跑完以后剩下油最多的。</p>
<p>比如我们跑到第i个点，这时候总消耗减去总加油最大，那说明前面i个点的消耗是整条链上最多的。然后如果总油数比总消耗多，说明可以保证开完一圈。
那么如果想保证能开完一圈，就要从它后面那个点开始开。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canCompleteCircuit</span>(<span class="params">self, gas: <span class="type">List</span>[<span class="built_in">int</span>], cost: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left = [gas[i] - cost[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(gas))]</span><br><span class="line">        minValue = <span class="number">999</span></span><br><span class="line">        minIndex = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        sumValue = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j, l <span class="keyword">in</span> <span class="built_in">enumerate</span>(left):</span><br><span class="line">            sumValue += l</span><br><span class="line">            <span class="keyword">if</span> sumValue &lt; minValue:</span><br><span class="line">                minValue = sumValue</span><br><span class="line">                minIndex = j</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> sumValue &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (minIndex + <span class="number">1</span>) % <span class="built_in">len</span>(gas)</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：<span class="math display">\[O(N)\]</span>。</li>
<li>空间复杂度：<span class="math display">\[O(1)\]</span>.</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://txing-casia.github.io/2021/07/21/2021-07-21-Q419-%E7%94%B2%E6%9D%BF%E4%B8%8A%E7%9A%84%E6%88%98%E8%88%B0-%E4%B8%AD%E7%AD%89-%E6%B7%B1%E5%BA%A6and%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/my_photo.jpg">
      <meta itemprop="name" content="Txing">
      <meta itemprop="description" content="泛用人形决战型机器人博士">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Txing">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/21/2021-07-21-Q419-%E7%94%B2%E6%9D%BF%E4%B8%8A%E7%9A%84%E6%88%98%E8%88%B0-%E4%B8%AD%E7%AD%89-%E6%B7%B1%E5%BA%A6and%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/" class="post-title-link" itemprop="url">Q419-甲板上的战舰-中等-深度/宽度优先搜索</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-07-21 00:00:00" itemprop="dateCreated datePublished" datetime="2021-07-21T00:00:00+08:00">2021-07-21</time>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>775</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>1 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="甲板上的战舰"><a
target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/battleships-in-a-board/">419.
甲板上的战舰</a></h4>
<h2 id="question">Question</h2>
<blockquote>
<p>给定一个二维的甲板， 请计算其中有多少艘战舰。 战舰用 'X'表示，空位用
'.'表示。 你需要遵守以下规则：</p>
<p>给你一个有效的甲板，仅由战舰或者空位组成。
战舰只能水平或者垂直放置。换句话说,战舰只能由 1xN (1 行, N 列)组成，或者
Nx1 (N 行, 1 列)组成，其中N可以是任意大小。
两艘战舰之间至少有一个水平或垂直的空位分隔 - 即没有相邻的战舰。</p>
<p>输入二维数组board</p>
<p>输出有多少战舰</p>
</blockquote>
<blockquote>
<p><strong>Example 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X..X</span><br><span class="line">...X</span><br><span class="line">...X</span><br></pre></td></tr></table></figure>
<p>输出：2</p>
</blockquote>
<blockquote>
<p><strong>Note:</strong></p>
<p>不用考虑无效样本</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...X</span><br><span class="line">XXXX</span><br><span class="line">...X</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="approach-1-深度优先搜索递归">Approach 1: 深度优先搜索+递归</h3>
<p>简单处理，DFS越来越熟练了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countBattleships</span>(<span class="params">self, board: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">DFS</span>(<span class="params">cur_i,cur_j</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span>&lt;=cur_i <span class="keyword">and</span> cur_i&lt;r <span class="keyword">and</span> <span class="number">0</span>&lt;=cur_j <span class="keyword">and</span> cur_j&lt;c <span class="keyword">and</span> board[cur_i][cur_j] == <span class="string">&#x27;X&#x27;</span>:</span><br><span class="line">                board[cur_i][cur_j] = <span class="string">&quot;.&quot;</span></span><br><span class="line">                <span class="keyword">for</span> di,dj <span class="keyword">in</span> [(-<span class="number">1</span>,<span class="number">0</span>),(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">0</span>,-<span class="number">1</span>),(<span class="number">0</span>,<span class="number">1</span>)]:</span><br><span class="line">                    DFS(cur_i+di,cur_j+dj)</span><br><span class="line">            </span><br><span class="line">        r,c = <span class="built_in">len</span>(board),<span class="built_in">len</span>(board[<span class="number">0</span>])</span><br><span class="line">        ans=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(r):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(c):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">&#x27;X&#x27;</span>:</span><br><span class="line">                    ans+=<span class="number">1</span></span><br><span class="line">                    DFS(i,j)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans </span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：<span class="math display">\[O(R \times
C)\]</span>。其中 R 是给定网格中的行数，C
是列数。我们访问每个网格最多一次。</li>
<li>空间复杂度：<span class="math display">\[O(1)\]</span></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://txing-casia.github.io/2021/07/21/2021-07-21-Q695-%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF-%E4%B8%AD%E7%AD%89-%E6%B7%B1%E5%BA%A6and%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/my_photo.jpg">
      <meta itemprop="name" content="Txing">
      <meta itemprop="description" content="泛用人形决战型机器人博士">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Txing">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/21/2021-07-21-Q695-%E5%B2%9B%E5%B1%BF%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF-%E4%B8%AD%E7%AD%89-%E6%B7%B1%E5%BA%A6and%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/" class="post-title-link" itemprop="url">Q695-岛屿的最大面积-中等-深度/宽度优先搜索</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-07-21 00:00:00" itemprop="dateCreated datePublished" datetime="2021-07-21T00:00:00+08:00">2021-07-21</time>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>2.4k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>2 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="岛屿的最大面积"><a
target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/max-area-of-island/">695.
岛屿的最大面积</a></h4>
<h2 id="question">Question</h2>
<blockquote>
<p>给定一个包含了一些 0 和 1 的非空二维数组 grid 。</p>
<p>一个 岛屿 是由一些相邻的 1 (代表土地)
构成的组合，这里的「相邻」要求两个 1
必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被
0（代表水）包围着。</p>
<p>找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0
。)</p>
</blockquote>
<blockquote>
<p><strong>Example 1:</strong></p>
<p>[[0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0],
[0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0],
[0,1,0,0,1,1,0,0,1,1,1,0,0], [0,0,0,0,0,0,0,0,0,0,1,0,0],
[0,0,0,0,0,0,0,1,1,1,0,0,0], [0,0,0,0,0,0,0,1,1,0,0,0,0]]</p>
<p>对于上面这个给定矩阵应返回 <code>6</code>。注意答案不应该是
<code>11</code> ，因为岛屿只能包含水平或垂直的四个方向的 <code>1</code>
。</p>
</blockquote>
<blockquote>
<p><strong>Example 2:</strong></p>
<p>[[0,0,0,0,0,0,0,0]]</p>
<p>对于上面这个给定的矩阵, 返回 <code>0</code>。</p>
</blockquote>
<blockquote>
<p><strong>Note:</strong></p>
<ul>
<li>给定的矩阵<code>grid</code> 的长度和宽度都不超过 50。</li>
</ul>
</blockquote>
<h3 id="approach-1-深度优先搜索递归">Approach 1: 深度优先搜索+递归</h3>
<p>这个思路比较好理解，DFS+递归可以按照这个步骤思考</p>
<ul>
<li>计算行数，列数</li>
<li>遍历二维数组，计算当前“岛屿”面积，并与最大面积对比取最大值
<ul>
<li>在DFS函数中计算当前岛屿的面积</li>
<li>先判断位置是否合法（r and c）</li>
<li>如果当前位置是1，那就置0，避免重复，在返回结果递归DFS，检测周围是否是岛屿</li>
</ul></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxAreaOfIsland</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">DFS</span>(<span class="params">grid,ci,cj</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span>&lt;=ci <span class="keyword">and</span> ci&lt;r <span class="keyword">and</span> <span class="number">0</span>&lt;=cj <span class="keyword">and</span> cj&lt;c <span class="keyword">and</span> grid[ci][cj] == <span class="number">1</span>:</span><br><span class="line">                grid[ci][cj] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span> + DFS(grid,ci-<span class="number">1</span>,cj) + DFS(grid,ci+<span class="number">1</span>,cj) + DFS(grid,ci,cj-<span class="number">1</span>) + DFS(grid,ci,cj+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">                </span><br><span class="line">        r , c = <span class="built_in">len</span>(grid),<span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        fin_res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(r):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(c):</span><br><span class="line">                fin_res = <span class="built_in">max</span>(DFS(grid,i,j),fin_res)</span><br><span class="line">        <span class="keyword">return</span> fin_res</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：<span class="math display">\[O(R \times
C)\]</span>。其中 R 是给定网格中的行数，C
是列数。我们访问每个网格最多一次。</li>
<li>空间复杂度：<span class="math display">\[O(R \times
C)\]</span>，递归的深度最大可能是整个网格的大小，因此最大可能使用 <span
class="math display">\[O(R \times C)\]</span> 的栈空间。</li>
</ul>
<h3 id="approach-2-广度优先搜索">Approach 2: 广度优先搜索</h3>
<p>广度优先的写法需要建立一个队列que，记录当前遍历到的结点，结合while
que进行遍历</p>
<ul>
<li>遍历每个元素，判断是否是1，是则放入que</li>
<li>对每个放入que的元素遍历几种移动情况，满足条件的元素置零后放入que，继续遍历</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxAreaOfIsland</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        r , c = <span class="built_in">len</span>(grid) , <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        total_res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(r):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(c):</span><br><span class="line">                ans = <span class="number">0</span></span><br><span class="line">                que = []</span><br><span class="line">                <span class="keyword">if</span> grid[i][j] == <span class="number">1</span>:</span><br><span class="line">                    grid[i][j] = <span class="number">0</span></span><br><span class="line">                    ans += <span class="number">1</span></span><br><span class="line">                    que.append((i,j))</span><br><span class="line">                    <span class="keyword">while</span> que:</span><br><span class="line">                        cur_r,cur_c = que.pop(<span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">for</span> dr,dc <span class="keyword">in</span> [(-<span class="number">1</span>,<span class="number">0</span>),(<span class="number">1</span>,<span class="number">0</span>),(<span class="number">0</span>,-<span class="number">1</span>),(<span class="number">0</span>,<span class="number">1</span>)]:</span><br><span class="line">                            temp_r , temp_c = cur_r + dr , cur_c + dc</span><br><span class="line">                            <span class="keyword">if</span> <span class="number">0</span>&lt;=temp_r <span class="keyword">and</span> temp_r&lt;r <span class="keyword">and</span> <span class="number">0</span>&lt;=temp_c <span class="keyword">and</span> temp_c&lt;c <span class="keyword">and</span> grid[temp_r][temp_c] == <span class="number">1</span>:</span><br><span class="line">                                grid[temp_r][temp_c] = <span class="number">0</span></span><br><span class="line">                                ans += <span class="number">1</span></span><br><span class="line">                                que.append((temp_r,temp_c))</span><br><span class="line">                total_res = <span class="built_in">max</span>(total_res,ans)</span><br><span class="line">        <span class="keyword">return</span> total_res</span><br></pre></td></tr></table></figure>
<p>另一种写法，每次从队首取出土地，并将接下来想要遍历的土地放在队尾，就实现了广度优先搜索算法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxAreaOfIsland</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, l <span class="keyword">in</span> <span class="built_in">enumerate</span>(grid):</span><br><span class="line">            <span class="keyword">for</span> j, n <span class="keyword">in</span> <span class="built_in">enumerate</span>(l):</span><br><span class="line">                cur = <span class="number">0</span></span><br><span class="line">                q = collections.deque([(i, j)])</span><br><span class="line">                <span class="keyword">while</span> q:</span><br><span class="line">                    cur_i, cur_j = q.popleft()</span><br><span class="line">                    <span class="keyword">if</span> cur_i &lt; <span class="number">0</span> <span class="keyword">or</span> cur_j &lt; <span class="number">0</span> <span class="keyword">or</span> cur_i == <span class="built_in">len</span>(grid) <span class="keyword">or</span> cur_j == <span class="built_in">len</span>(grid[<span class="number">0</span>]) <span class="keyword">or</span> grid[cur_i][cur_j] != <span class="number">1</span>:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    cur += <span class="number">1</span></span><br><span class="line">                    grid[cur_i][cur_j] = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">for</span> di, dj <span class="keyword">in</span> [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, -<span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>], [-<span class="number">1</span>, <span class="number">0</span>]]:</span><br><span class="line">                        next_i, next_j = cur_i + di, cur_j + dj</span><br><span class="line">                        q.append((next_i, next_j))</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, cur)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：<span class="math display">\[O(R \times
C)\]</span>。其中 R 是给定网格中的行数，C
是列数。我们访问每个网格最多一次。</li>
<li>空间复杂度：<span class="math display">\[O(R \times
C)\]</span>，队列中最多会存放所有的土地，土地的数量最多为 <span
class="math display">\[R \times C\]</span> 块，因此使用的空间为 <span
class="math display">\[O(R \times C)\]</span>。</li>
<li></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://txing-casia.github.io/2021/07/18/2021-07-18-Q688-%E9%A9%AC%E5%9C%A8%E6%A3%8B%E7%9B%98%E4%B8%8A%E7%9A%84%E6%A6%82%E7%8E%87-%E4%B8%AD%E7%AD%89-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/my_photo.jpg">
      <meta itemprop="name" content="Txing">
      <meta itemprop="description" content="泛用人形决战型机器人博士">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Txing">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/18/2021-07-18-Q688-%E9%A9%AC%E5%9C%A8%E6%A3%8B%E7%9B%98%E4%B8%8A%E7%9A%84%E6%A6%82%E7%8E%87-%E4%B8%AD%E7%AD%89-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" class="post-title-link" itemprop="url">Q688-马在棋盘上的概率-中等-动态规划</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-07-18 00:00:00" itemprop="dateCreated datePublished" datetime="2021-07-18T00:00:00+08:00">2021-07-18</time>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>3k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>3 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="马在棋盘上的概率"><a
target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/knight-probability-in-chessboard/">688.
“马”在棋盘上的概率</a></h4>
<h2 id="question">Question</h2>
<blockquote>
<p>已知一个 NxN 的国际象棋棋盘，棋盘的行号和列号都是从 0
开始。即最左上角的格子记为 (0, 0)，最右下角的记为 (N-1, N-1)。</p>
<p>现有一个 “马”（也译作 “骑士”）位于 (r, c) ，并打算进行 K 次移动。</p>
<p>如下图所示，国际象棋的 “马” 每一步先沿水平或垂直方向移动 2
个格子，然后向与之相垂直的方向再移动 1 个格子，共有 8 个可选的位置。</p>
<p>现在 “马”
每一步都从可选的位置（包括棋盘外部的）中独立随机地选择一个进行移动，直到移动了
K 次或跳到了棋盘外面。</p>
<p>求移动结束后，“马” 仍留在棋盘上的概率。</p>
</blockquote>
<blockquote>
<p><strong>Example 1:</strong></p>
<p>输入: 3, 2, 0, 0 输出: 0.0625 解释: 输入的数据依次为 N, K, r, c 第 1
步时，有且只有 2 种走法令 “马”
可以留在棋盘上（跳到（1,2）或（2,1））。对于以上的两种情况，各自在第2步均有且只有2种走法令
“马” 仍然留在棋盘上。 所以 “马” 在结束后仍在棋盘上的概率为 0.0625。</p>
</blockquote>
<blockquote>
<p><strong>Note:</strong></p>
<ul>
<li><code>N</code> 的取值范围为 [1, 25]</li>
<li><code>K</code> 的取值范围为 [0, 100]</li>
<li>开始时，“马” 总是位于棋盘上</li>
</ul>
</blockquote>
<h3 id="approach-1-动态规划">Approach 1: 动态规划</h3>
<ul>
<li>令 <code>f[r][c][steps]</code> 代表马在位置 <code>(r, c)</code>
移动了 <code>steps</code>
次以后还留在棋盘上的概率，根据马的移动方式，我们有以下递归：</li>
</ul>
<p><span class="math display">\[
f[r][c][steps]=\sum_{dr,dc} f[r+dr][c+dc][steps-1]\cdot \frac{1}{8}
\]</span></p>
<ul>
<li>根据题目我们可以知道 (dr, dc) 的可能数据对是 (2, 1), (2, -1), (-2,
1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2)。</li>
<li>我们将使用二维的 dp 和 dp2 来存储我们的数据，而不是使用三维数组 f。
<ul>
<li><code>dp2</code> 代表 <code>f[][][steps]</code>；</li>
<li><code>dp</code> 代表 <code>f[][][steps-1]</code>；</li>
</ul></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">knightProbability</span>(<span class="params">self, N, K, r, c</span>):</span><br><span class="line">        dp = [[<span class="number">0</span>] * N <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N)]</span><br><span class="line">        dp[r][c] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(K): <span class="comment"># 走k步还在棋盘内的概率</span></span><br><span class="line">            dp2 = [[<span class="number">0</span>] * N <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N)]</span><br><span class="line">            <span class="keyword">for</span> r, row <span class="keyword">in</span> <span class="built_in">enumerate</span>(dp):</span><br><span class="line">                <span class="keyword">for</span> c, val <span class="keyword">in</span> <span class="built_in">enumerate</span>(row):</span><br><span class="line">                    <span class="keyword">for</span> dr, dc <span class="keyword">in</span> ((<span class="number">2</span>,<span class="number">1</span>),(<span class="number">2</span>,-<span class="number">1</span>),(-<span class="number">2</span>,<span class="number">1</span>),(-<span class="number">2</span>,-<span class="number">1</span>),</span><br><span class="line">                                   (<span class="number">1</span>,<span class="number">2</span>),(<span class="number">1</span>,-<span class="number">2</span>),(-<span class="number">1</span>,<span class="number">2</span>),(-<span class="number">1</span>,-<span class="number">2</span>)):</span><br><span class="line">                        <span class="comment"># 走了一步之后还在棋盘内</span></span><br><span class="line">                        <span class="keyword">if</span> <span class="number">0</span> &lt;= r + dr &lt; N <span class="keyword">and</span> <span class="number">0</span> &lt;= c + dc &lt; N:</span><br><span class="line">                            dp2[r+dr][c+dc] += val / <span class="number">8.0</span></span><br><span class="line">            dp = dp2</span><br><span class="line">        <span class="comment"># map()函数把sum依次作用在dp的每一项上，在map()外再使用sum()完成二维数组的求和</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(<span class="built_in">map</span>(<span class="built_in">sum</span>, dp))</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    N, K, r, c = <span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    solution=Solution().solve(N, K, r, c)</span><br><span class="line">    <span class="built_in">print</span>(solution)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：<span class="math display">\[O(N^2 K)\]</span>。其中 N,
K 为题目中的定义。我们对 <span class="math display">\[N^2\]</span>
元素的每一层 dp 进行 O(1) 工作，并且考虑了 K 层。</li>
<li>空间复杂度：<span class="math display">\[O(N^2)\]</span>，dp 和 dp2
的大小。</li>
</ul>
<h3 id="approach-2-矩阵求幂">Approach 2: 矩阵求幂</h3>
<p>方法 1 中表示的状态重复表达了过渡到其他的线性组合的状态。
任何情况下，我们都可以将整个转换表示为这些线性组合的矩阵。然后，这个矩阵的第
n 次方代表了 n 移动的转换，因此我们可以将问题简化为矩阵求幂问题。</p>
<p><strong>算法：</strong></p>
<ul>
<li>首先，我们可以利用棋盘上的对称性。马可能有 n^2
的状态（假设它在板上）。由于横轴、纵轴和对角线的对称性，我们可以假设骑士在棋盘的左上象限，并且列数等于或大于行数。对于任何一个位置，通过满足条件通过轴反射得到位置将是该位置的标准索引。</li>
<li>这将使状态数从 <span class="math display">\[N^2\]</span> 减少到大约
<span class="math display">\[\frac{N^2}{8}\]</span> ，这使得在这个 <span
class="math display">\[O(\frac{N^2}{8}) \times O(\frac{N^2}{8})\]</span>
矩阵上下求幂大约快 <span class="math display">\[8^3\]</span> 倍。</li>
<li>现在，如果我们知道每一个状态在一次移动后都会变成某种状态的线性组合，那么让我们写一个过渡矩阵
<span class="math display">\[\mathcal{T}\]</span>，其中 <span
class="math display">\[\mathcal{T}\]</span> 的第 i 行代表了第 i
个状态的线性组合。然后，<span
class="math display">\[\mathcal{T}^n\]</span> 表示 n
次移动的转换，我们需要第 i 行的总和，其中 i 是起始位置的索引。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">knightProbability2</span>(<span class="params">self, N, K, sr, sc</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">canonical</span>(<span class="params">r, c</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="number">2</span> * r &gt; N: r = N - <span class="number">1</span> - r</span><br><span class="line">            <span class="keyword">if</span> <span class="number">2</span> * c &gt; N: c = N - <span class="number">1</span> - c</span><br><span class="line">            <span class="keyword">if</span> r &gt; c: r, c = c, r</span><br><span class="line">            <span class="keyword">return</span> r*N + c</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">matrix_mult</span>(<span class="params">A, B</span>):</span><br><span class="line">            ZB = <span class="built_in">zip</span>(*B)</span><br><span class="line">            <span class="keyword">return</span> [[<span class="built_in">sum</span>(a * b <span class="keyword">for</span> a, b <span class="keyword">in</span> <span class="built_in">zip</span>(row, col))</span><br><span class="line">                    <span class="keyword">for</span> col <span class="keyword">in</span> ZB] <span class="keyword">for</span> row <span class="keyword">in</span> A]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">matrix_expo</span>(<span class="params">A, K</span>):</span><br><span class="line">            <span class="keyword">if</span> K == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> [[+(i==j) <span class="keyword">for</span> j <span class="keyword">in</span> xrange(<span class="built_in">len</span>(A))]</span><br><span class="line">                        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="built_in">len</span>(A))]</span><br><span class="line">            <span class="keyword">if</span> K == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> A</span><br><span class="line">            <span class="keyword">elif</span> K % <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> matrix_mult(matrix_expo(A, K-<span class="number">1</span>), A)</span><br><span class="line">            B = matrix_expo(A, K/<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> matrix_mult(B, B)</span><br><span class="line"></span><br><span class="line">        index = [<span class="number">0</span>] * (N*N)</span><br><span class="line">        t = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> xrange(N):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> xrange(N):</span><br><span class="line">                <span class="keyword">if</span> r*N + c == canonical(r, c):</span><br><span class="line">                    index[r*N + c] = t</span><br><span class="line">                    t += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    index[r*N + c] = index[canonical(r, c)]</span><br><span class="line"></span><br><span class="line">        T = []</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> xrange(N):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> xrange(N):</span><br><span class="line">                <span class="keyword">if</span> r*N + c == canonical(r, c):</span><br><span class="line">                    row = [<span class="number">0</span>] * t</span><br><span class="line">                    <span class="keyword">for</span> dr, dc <span class="keyword">in</span> ((<span class="number">2</span>,<span class="number">1</span>),(<span class="number">2</span>,-<span class="number">1</span>),(-<span class="number">2</span>,<span class="number">1</span>),(-<span class="number">2</span>,-<span class="number">1</span>),</span><br><span class="line">                                    (<span class="number">1</span>,<span class="number">2</span>),(<span class="number">1</span>,-<span class="number">2</span>),(-<span class="number">1</span>,<span class="number">2</span>),(-<span class="number">1</span>,-<span class="number">2</span>)):</span><br><span class="line">                        <span class="keyword">if</span> <span class="number">0</span> &lt;= r+dr &lt; N <span class="keyword">and</span> <span class="number">0</span> &lt;= c+dc &lt; N:</span><br><span class="line">                            row[index[(r+dr)*N + c+dc]] += <span class="number">0.125</span></span><br><span class="line">                    T.append(row)</span><br><span class="line"></span><br><span class="line">        Tk = matrix_expo(T, K)</span><br><span class="line">        i = index[sr * N + sc]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(Tk[i])</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：<span class="math display">\[O(N^6
\log(K))\]</span>。其中 N, K 为题目中的定义。大约有 <span
class="math display">\[\frac{N^2}{8}\]</span>
规范状态，这使得我们的矩阵乘法 <span
class="math display">\[O(N^6)\]</span>。为了找到这个矩阵的第 K
次幂，我们做了 <span class="math display">\[O(\log(K))\]</span>
matrix乘法。</p></li>
<li><p>空间复杂度：<span
class="math display">\[O(N^4)\]</span>，矩阵有大约 <span
class="math display">\[\frac{N^4}{64}\]</span> 个元素。</p></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://txing-casia.github.io/2021/07/18/2021-07-18-Q200.%20%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F-%E4%B8%AD%E7%AD%89-%E6%B7%B1%E5%BA%A6and%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/my_photo.jpg">
      <meta itemprop="name" content="Txing">
      <meta itemprop="description" content="泛用人形决战型机器人博士">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Txing">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/18/2021-07-18-Q200.%20%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F-%E4%B8%AD%E7%AD%89-%E6%B7%B1%E5%BA%A6and%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/" class="post-title-link" itemprop="url">Q200-岛屿数量-中等-深度and广度优先搜索</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-07-18 00:00:00" itemprop="dateCreated datePublished" datetime="2021-07-18T00:00:00+08:00">2021-07-18</time>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>1.8k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>2 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="岛屿数量"><a
target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-islands/">200.
岛屿数量</a></h4>
<h2 id="question">Question</h2>
<blockquote>
<p>给你一个由 '1'（陆地）和
'0'（水）组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
</blockquote>
<blockquote>
<p><strong>Example 1:</strong></p>
<p>输入：grid = [ ["1","1","1","1","0"], ["1","1","0","1","0"],
["1","1","0","0","0"], ["0","0","0","0","0"]] 输出：1</p>
</blockquote>
<blockquote>
<p><strong>Example 2:</strong></p>
<p>输入：grid = [ ["1","1","0","0","0"], ["1","1","0","0","0"],
["0","0","1","0","0"], ["0","0","0","1","1"]] 输出：3</p>
</blockquote>
<blockquote>
<p><strong>Note:</strong></p>
<ul>
<li><code>m == grid.length</code></li>
<li><code>n == grid[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 300</code></li>
<li><code>grid[i][j]</code> 的值为 <code>'0'</code> 或
<code>'1'</code></li>
</ul>
</blockquote>
<h3 id="approach-1-深度优先搜索">Approach 1: 深度优先搜索</h3>
<p>我们可以将二维网格看成一个无向图，竖直或水平相邻的 11
之间有边相连。</p>
<p>为了求出岛屿的数量，我们可以扫描整个二维网格。如果一个位置为
11，则以其为起始节点开始进行深度优先搜索。在深度优先搜索的过程中，每个搜索到的
11 都会被重新标记为 00。</p>
<p>最终岛屿的数量就是我们进行深度优先搜索的次数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">self, grid, r, c</span>):</span><br><span class="line">        grid[r][c] = <span class="number">0</span></span><br><span class="line">        nr, nc = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> [(r - <span class="number">1</span>, c), (r + <span class="number">1</span>, c), (r, c - <span class="number">1</span>), (r, c + <span class="number">1</span>)]:</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= x &lt; nr <span class="keyword">and</span> <span class="number">0</span> &lt;= y &lt; nc <span class="keyword">and</span> grid[x][y] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                self.dfs(grid, x, y)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numIslands</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        nr = <span class="built_in">len</span>(grid)</span><br><span class="line">        <span class="keyword">if</span> nr == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        nc = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        num_islands = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(nr):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(nc):</span><br><span class="line">                <span class="keyword">if</span> grid[r][c] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                    num_islands += <span class="number">1</span></span><br><span class="line">                    self.dfs(grid, r, c)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> num_islands</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：O(MN)，其中 M 和 N 分别为行数和列数。</p></li>
<li><p>空间复杂度：O(MN)，在最坏情况下，整个网格均为陆地，深度优先搜索的深度达到
MN。</p></li>
</ul>
<h3 id="approach-2-广度优先搜索">Approach 2: 广度优先搜索</h3>
<p>同样地，我们也可以使用广度优先搜索代替深度优先搜索。</p>
<p>为了求出岛屿的数量，我们可以扫描整个二维网格。如果一个位置为
1，则将其加入队列，开始进行广度优先搜索。在广度优先搜索的过程中，每个搜索到的
1 都会被重新标记为 0。直到队列为空，搜索结束。</p>
<p>最终岛屿的数量就是我们进行广度优先搜索的次数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numIslands</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        nr = <span class="built_in">len</span>(grid)</span><br><span class="line">        <span class="keyword">if</span> nr == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        nc = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        num_islands = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> <span class="built_in">range</span>(nr):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(nc):</span><br><span class="line">                <span class="keyword">if</span> grid[r][c] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                    num_islands += <span class="number">1</span></span><br><span class="line">                    grid[r][c] = <span class="string">&quot;0&quot;</span></span><br><span class="line">                    neighbors = collections.deque([(r, c)])</span><br><span class="line">                    <span class="keyword">while</span> neighbors:</span><br><span class="line">                        row, col = neighbors.popleft()</span><br><span class="line">                        <span class="keyword">for</span> x, y <span class="keyword">in</span> [(row - <span class="number">1</span>, col), (row + <span class="number">1</span>, col), (row, col - <span class="number">1</span>), (row, col + <span class="number">1</span>)]:</span><br><span class="line">                            <span class="keyword">if</span> <span class="number">0</span> &lt;= x &lt; nr <span class="keyword">and</span> <span class="number">0</span> &lt;= y &lt; nc <span class="keyword">and</span> grid[x][y] == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                                neighbors.append((x, y))</span><br><span class="line">                                grid[x][y] = <span class="string">&quot;0&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> num_islands</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：<span class="math display">\[O(MN)\]</span>，其中 M 和 N
分别为行数和列数。</li>
<li>空间复杂度：<span class="math display">\[O(\min(M,
N))\]</span>，在最坏情况下，整个网格均为陆地，队列的大小可以达到<span
class="math display">\[ \min(M, N)\]</span>。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://txing-casia.github.io/2021/07/16/2021-07-16-Reinforcement%20Learning%20-%20On%20Learning%20Intrinsic%20Rewards%20for%20Policy%20Gradient%20Methods/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/my_photo.jpg">
      <meta itemprop="name" content="Txing">
      <meta itemprop="description" content="泛用人形决战型机器人博士">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Txing">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/16/2021-07-16-Reinforcement%20Learning%20-%20On%20Learning%20Intrinsic%20Rewards%20for%20Policy%20Gradient%20Methods/" class="post-title-link" itemprop="url">Reinforcement Learning | On Learning Intrinsic Rewards for Policy Gradient Methods</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-07-16 00:00:00" itemprop="dateCreated datePublished" datetime="2021-07-16T00:00:00+08:00">2021-07-16</time>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>5.4k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>5 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="on-learning-intrinsic-rewards-for-policy-gradient-methods">On
Learning Intrinsic Rewards for Policy Gradient Methods</h1>
<p>论文链接：https://dl.acm.org/doi/pdf/10.5555/3327345.3327375</p>
<h2 id="主要内容">主要内容</h2>
<ul>
<li>本文提出基于 <strong>optimal reward framework</strong> [Singh et
al., 2010] 的本质奖励学习方法，并和 PPO 算法（Mujoco）结合</li>
</ul>
<p>Satinder Singh, Richard L Lewis, Andrew G Barto, and Jonathan Sorg.
Intrinsically motivated reinforcement learning: An evolutionary
perspective. IEEE Transactions on Autonomous Mental Development,
2(2):70–82, 2010.</p>
<ul>
<li>在一些游戏场景中缺少清晰的奖励函数选择方式。有时候存在多个目标，最小化能量消耗，最大化吞吐量，最小化延时等（minimizing
energy consumption and maximizing throughput and minimizing
latency）</li>
<li>早期的工作证明了最优策略的奖励函数并不唯一，例如使用一个势能函数（potential-based
reward [Ng et al., 1999]）的奖励函数不会改变最优策略。</li>
</ul>
<p>Andrew Y Ng, Daishi Harada, and Stuart J Russell. Policy invariance
under reward transformations: Theory and application to reward shaping.
In Proceedings of the Sixteenth International Conference on Machine
Learning, pages 278–287. Morgan Kaufmann Publishers Inc., 1999.</p>
<ul>
<li><p>另一方面，由于实际任务中的各种限制（e.g., inadequate memory,
representational capacity, computation, training data,
etc.），智能体很难学习到最优策略。因此，在解决奖励设计问题时，希望设计能改变最优策略的奖励函数变换方式。</p></li>
<li><p>构造奖励函数的好处：</p>
<ul>
<li>比原始的奖励函数更少的稀疏性，加快学习过程 [Rajeswaran et al.,
2017]；</li>
<li>帮助探索状态边界的区域，例如count-based reward
鼓励探索很少探索到的区域 [Bellemare et al., 2016, Ostrovski et al.,
2017, Tang et al., 2017]；</li>
</ul></li>
<li><p>相关的方法：</p>
<ul>
<li>preference elicitation</li>
<li>inverse RL</li>
<li>intrinsically motivated RL</li>
<li>optimal rewards</li>
<li>potentialbased shaping rewards</li>
<li>more general reward shaping</li>
<li>mechanism design</li>
</ul></li>
<li><p>主要贡献：</p>
<ul>
<li>基于策略梯度的方法推导intrinsic rewards学习方法，并与
task-specifying (hereafter extrinsic) reward
相结合，最大化外部奖励。</li>
<li>内部和外部奖励之和的参数通过策略梯度方法更新训练</li>
</ul></li>
<li><p>使用本质奖励的主要原因是对RL
agent的训练都是有限的（表征能力，可得到的数据，计算能力限制等等），通过集合内部奖励可以环节这些限制。The
main intuition is that in practice all RL agents are bounded
(computationally, representationally, in terms of data availability,
etc.) and the optimal intrinsic reward can help mitigate these
bounds.</p></li>
</ul>
<h3 id="background-and-related-work">Background and Related Work</h3>
<ul>
<li><p><strong>Optimal rewards and reward design</strong></p>
<p>Sorg et al.
[2010]提出了PGRD算法，这是一种可扩展的算法，仅适用于基于前瞻搜索(例如，UCT)的规划agent(因此agent本身不是基于学习的agent；只学习与固定规划者一起使用的奖励)。Sorg
et al. [2010] introduced PGRD (Policy Gradient for Reward Design), a
scalable algorithm that only works with lookahead-search (e.g., UCT)
based planning agents (and hence the agent itself is not a
learning-based agent; only the reward to use with the fixed planner is
learned).</p></li>
<li><p><strong>Reward shaping and Auxiliary rewards</strong></p>
<ul>
<li><p>Reward shaping [Ng et al.,
1999]提供了一个一般性的答案，说明什么样的奖励函数修改空间不会改变最优策略，特别是基于势能的奖励函数。Reward
shaping [Ng et al., 1999] provides a general answer to what space of
reward function modifications do not change the optimal policy,
specifically potential-based rewards.</p></li>
<li><p>The <strong>UNREAL</strong> agent <strong>[Jaderberg et al.,
2016]</strong> used pseudo-reward computed from unsupervised auxiliary
tasks to refine its internal representations.</p>
<p>Max Jaderberg, Volodymyr Mnih, Wojciech Marian Czarnecki, Tom Schaul,
Joel Z Leibo, David Silver, and Koray Kavukcuoglu. Reinforcement
learning with unsupervised auxiliary tasks. arXiv preprint
arXiv:1611.05397, 2016.</p></li>
<li><p>In <strong>Bellemare et al. [2016]</strong>, <strong>Ostrovski et
al. [2017]</strong>, and <strong>Tang et al. [2017]</strong>, a
pseudo-count based reward bonus was given to the agent to encourage
exploration</p></li>
<li><p><strong>Pathak et al. [2017]</strong> used self-supervised
prediction errors as intrinsic rewards to help the agent
explore.</p></li>
<li><p>本文的主要出发点是学习本质奖励，使其能够映射高维的观测和行为到奖励中。The
main departure point in this paper is that we learn the parameters of an
intrinsic reward function that maps high-dimensional observations and
actions to rewards.</p></li>
</ul></li>
<li><p><strong>Hierarchical RL</strong></p>
<ul>
<li>另一类的的本质奖励在分层强化学习中使用，比如FeUdal
Network通过manager和worker在不同时间尺度尽心学习，manager学习抽象的目标指挥worker最大化外部奖励</li>
<li>Finally, another difference is that hierarchical RL typically treats
the lower-level learner as a black box while we train the intrinsic
reward using gradients through the policy module in our
architecture.</li>
</ul></li>
<li><p><strong>Meta Learning for RL</strong></p>
<ul>
<li>这篇工作也可以被当做meta-RL方向的工作</li>
<li>与之前工作的区别：在单个任务中元学习到内部奖励，而不是快速适应新的任务。However,
a key distinction from the prior work on meta learning for RL [Finn et
al., 2017, Duan et al., 2017, Wang et al., 2016, Duan et al., 2016b] is
that our method aims to meta-learn intrinsic rewards within a single
task, whereas much of the prior work is designed to quickly adapt to new
tasks in a few-shot learning scenario.</li>
</ul></li>
</ul>
<h3
id="gradient-based-learning-of-intrinsic-rewards-a-derivation">Gradient-Based
Learning of Intrinsic Rewards: A Derivation</h3>
<h4 id="policy-gradient-based-rl">Policy Gradient based RL</h4>
<ul>
<li><p>The value of a policy <span
class="math display">\[J(\theta)=E[\sum^{\infty}_{t=0}
\gamma^tr_t]\]</span></p></li>
<li><p>the gradient of the value <span
class="math display">\[J(\theta)\]</span> is<br />
<span class="math display">\[
\nabla_{\theta} J(\theta)=E_{\theta}[G(s_t,a_t) \nabla_{\theta} \log
\pi_{\theta}(a_t|s_t)]\\
G(s_t,a_t)=\sum^{\infty}_{i=t} \gamma^{i-t}r_i
\]</span> G是到终点为止的return</p></li>
</ul>
<h4 id="lirpg-learning-intrinsic-rewards-for-policy-gradient">LIRPG:
Learning Intrinsic Rewards for Policy Gradient</h4>
<figure>
<img
src="https://raw.githubusercontent.com/txing-casia/txing-casia.github.io/master/img/20210719-1.png"
alt="Learning Intrinsic Rewards for Policy Gradient" />
<figcaption aria-hidden="true">Learning Intrinsic Rewards for Policy
Gradient</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/txing-casia/txing-casia.github.io/master/img/20210719-2.png"
alt="Algorithm 1 LIRPG: Learning Intrinsic Reward for Policy Gradient" />
<figcaption aria-hidden="true">Algorithm 1 LIRPG: Learning Intrinsic
Reward for Policy Gradient</figcaption>
</figure>
<ul>
<li><p><strong>Updating Policy Parameters (θ)</strong></p>
<p>使用内部和外部奖励之和来更新 <span
class="math display">\[\theta\]</span><br />
<span class="math display">\[
\begin{align}
\theta&#39;&amp;=\theta+\alpha\nabla_{\theta} J^{ex+in}(\theta)\\
&amp;\approx \theta +\alpha G^{ex+in}(s_t,a_t) \nabla_{\theta} \log
\pi_{\theta}(a_t|s_t)
\end{align}
\]</span></p></li>
<li><p><strong>Updating Intrinsic Reward Parameters
(η)</strong></p></li>
</ul>
<p>Given an episode and the updated policy parameters <span
class="math display">\[\theta&#39;\]</span> , we update intrinsic reward
parameters.<br />
<span class="math display">\[
\begin{align}
\nabla_{\eta}
J^{ex}&amp;=\nabla_{\theta&#39;}J^{ex}\nabla_{\eta}\theta&#39;\\
\nabla_{\theta&#39;}J^{ex} &amp;\approx G^{ex}(s_t,a_t)
\nabla_{\theta&#39;}\log \pi_{\theta&#39;}(a_t \mid s_t)\\
\nabla_{\eta} \theta&#39; &amp; =\nabla_{\eta}(\theta+\alpha
G^{ex+in}(s_t,a_t)\nabla_{\theta}\log \pi_{\theta}(a_t|s_t))\\
&amp;= \nabla_{\eta}(\alpha G^{ex+in}(s_t,a_t) \nabla_{\theta}\log
\pi_{\theta}(a_t|s_t)))\\
&amp;= \nabla_{\eta}(\alpha \lambda G^{in}(s_t,a_t) \nabla_{\theta}\log
\pi_{\theta}(a_t|s_t)))\\
&amp;= \alpha \lambda \sum^{\infty}_{i=t} \gamma^{i-t}\nabla_{\eta}
r^{in}_{\eta}(s_i,a_i)\nabla_{\theta} \log \pi_{\theta}(a_t\mid s_t)
\end{align}  
\]</span> The importance sampling:<br />
<span class="math display">\[
\nabla_{\theta&#39;}
J^{ex}=G^{ex}(s_t,a_t)\frac{\nabla_{\theta&#39;}\pi_{\theta&#39;}(a_t\mid
s_t)}{\pi_{\theta}(a_t\mid s_t)}\\  
\]</span>
重要性采样就是假设数据属于p(x)分布，但是实际采样是以q(x)分布采样的，需要乘以一个权重，把数据转换到p(x)分布，也就是重要性权重。</p>
<h2 id="总结">总结</h2>
<p>整个工作还是很漂亮的，尤其的这两层的梯度推导（需要结合途中公式和文本中的公式来看）。后面考虑再看几篇本质reward的文章，看看还有什么构造方式。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://txing-casia.github.io/2021/07/14/2021-07-14-Reinforcement%20Learning%20-%20Hierarchical%20Deep%20Reinforcement%20Learning%20Integrating%20Temporal%20Abstraction%20and%20Intrinsic%20Motivation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/my_photo.jpg">
      <meta itemprop="name" content="Txing">
      <meta itemprop="description" content="泛用人形决战型机器人博士">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Txing">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/14/2021-07-14-Reinforcement%20Learning%20-%20Hierarchical%20Deep%20Reinforcement%20Learning%20Integrating%20Temporal%20Abstraction%20and%20Intrinsic%20Motivation/" class="post-title-link" itemprop="url">Reinforcement Learning | Hierarchical Deep Reinforcement Learning: Integrating Temporal Abstraction and Intrinsic Motivation</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-07-14 00:00:00" itemprop="dateCreated datePublished" datetime="2021-07-14T00:00:00+08:00">2021-07-14</time>
            </span>

          <br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>2.6k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>2 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1
id="hierarchical-deep-reinforcement-learning-integrating-temporal-abstraction-and-intrinsic-motivation">Hierarchical
Deep Reinforcement Learning: Integrating Temporal Abstraction and
Intrinsic Motivation</h1>
<p>论文链接：https://proceedings.neurips.cc/paper/2016/file/f442d33fa06832082290ad8544a8da27-Paper.pdf</p>
<h2 id="主要内容">主要内容</h2>
<ul>
<li><p>稀疏反馈下，不充分的探索使得agent很难学习到鲁棒的行为策略。本文通过设计本质动机来驱动行为探索，并结合分层的结构来完成行为，最后在奖励稀疏和延迟的任务中进行了实验。</p></li>
<li><p>结构分为两层，顶层的meta-controller学习定义子目标，底层的controller学习根据状态和子目标执行行动，直到目标完成或者情节结束。</p></li>
<li><p>这项工作是基于 option 框架完成的。相关的分层强化学习框架还有 MAXQ
等。这篇文章没有对每个option单独使用Q函数。这一点和 [21]
是一致的，这会带来两个好处：（1）不同选项之间存在共享学习；（2）该模型可扩展到大量options的情况；</p>
<p>[21]. T. Schaul, D. Horgan, K. Gregor, and D. Silver. Universal value
function approximators. In Proceedings of the 32nd International
Conference on Machine Learning (ICML-15), pages 1312–1320,
2015.</p></li>
<li><p>In another paper, Singh et al. [26] take an evolutionary
perspective to optimize over the space of reward functions for the
agent, leading to a notion of extrinsically and intrinsically motivated
behavior.</p></li>
<li><p>Cognitive Science and Neuroscience The nature and origin of
intrinsic goals in humans is a thorny issue but there are some notable
insights from existing literature. There is converging evidence in
developmental psychology that human infants, primates, children, and
adults in diverse cultures base their core knowledge on certain
cognitive systems including – entities, agents and their actions,
numerical quantities, space, social-structures and intuitive theories
[29]. During curiositydriven activities, toddlers use this knowledge to
generate intrinsic goals such as building physically stable block
structures. In order to accomplish these goals, toddlers seem to
construct subgoals in the space of their core knowledge. Knowledge of
space can also be utilized to learn a hierarchical decomposition of
spatial environments. This has been explored in Neuroscience with the
successor representation, which represents value functions in terms of
the expected future state occupancy. Decomposition of the successor
representation have shown to yield reasonable subgoals for spatial
navigation problems [5, 30].</p></li>
<li><p>MDP过程中的高效探索是一个难题。<span
class="math display">\[\epsilon-greedy\]</span>
在局部探索中表现还好，但是对于整个状态空间不同区域的探索比较失败。这里通过设计本质目标
<span class="math display">\[g\]</span> 和本质奖励intrinsic
rewards</p></li>
</ul>
<p><img
src="https://raw.githubusercontent.com/txing-casia/txing-casia.github.io/master/img/20210714-1.png" /></p>
<ul>
<li><p>agent设置：</p>
<ul>
<li>meta-controller: 接收状态 <span class="math display">\[s_t\]</span>
然后选择子目标 <span class="math display">\[g_t\]</span>.</li>
<li>controller: 根据 <span class="math display">\[s_t\]</span> 和 <span
class="math display">\[g_t\]</span> 选择行为 <span
class="math display">\[a_t\]</span>.</li>
</ul></li>
<li><p>一个内部的critic用来为 controller 评估 <span
class="math display">\[r_t(g)\]</span>
（这篇文章使用的是一个二值的奖励）。controller
的目标就是最大化累积的本质奖励intrinsic reward <span
class="math display">\[R_t(g)=\sum_{t&#39;=t}^{\infty}
\gamma^{t&#39;-t}r_{t&#39;}(g)\]</span></p></li>
<li><p>meta-controller 的目标是最大化累积的外部奖励 extrinsic reward
<span class="math display">\[F_t=\sum_{t&#39;=t}^{\infty}
\gamma^{t&#39;-t}f_{t&#39;}\]</span>，其中<span
class="math display">\[f_{t&#39;}\]</span>是从环境中收到的奖励信号，并且<span
class="math display">\[F_{t}\]</span>和<span
class="math display">\[R_{t}\]</span>的时间尺度是不同的。</p></li>
<li><p>Controller: <span class="math display">\[
Q_1^*(s,a;g)=\max_{\pi_{a,g}} \mathbb{E} \Big[r_t+\gamma
\max_{a_{t+1}}Q_1^*(s_{t+1},a_{t+1};g)\Big]
\]</span></p></li>
<li><p>meta-controller: <span class="math display">\[
Q_2^*(s,g)=\max_{\pi_{g}} \mathbb{E} \Big[\sum_{t&#39;=t}^{t+N}
f_{t&#39;}+\gamma \max_{g&#39;}Q_2^*(s_{t+N},g&#39;)\Big]
\]</span> N 代表当控制器停止时所经过的步数。</p></li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/txing-casia/txing-casia.github.io/master/img/20210714-2.png"
alt="算法步骤" />
<figcaption aria-hidden="true">算法步骤</figcaption>
</figure>
<h2 id="总结">总结</h2>
<p>很简单直接的思路，直接在DQN上做出了分层的改进，但是感觉和option的结合并不是很紧密，比如终止函数没有单独设计，时间缩放步数N可能需要预设等等。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/8/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/30/">30</a><a class="extend next" rel="next" href="/page/10/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Txing"
      src="/images/my_photo.jpg">
  <p class="site-author-name" itemprop="name">Txing</p>
  <div class="site-description" itemprop="description">泛用人形决战型机器人博士</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">234</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">58</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/txing-casia" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;txing-casia" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://blog.uomi.moe/" title="https:&#x2F;&#x2F;blog.uomi.moe" rel="noopener" target="_blank">驱逐舰患者</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://m.mepai.me/photographyer/u_5a68085ba15aa.html?tdsourcetag=s_pctim_aiomsg" title="https:&#x2F;&#x2F;m.mepai.me&#x2F;photographyer&#x2F;u_5a68085ba15aa.html?tdsourcetag&#x3D;s_pctim_aiomsg" rel="noopener" target="_blank">隐之-INF</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2018 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Txing</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">572k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">8:40</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

</body>
</html>
