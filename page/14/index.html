<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"txing-casia.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","width":240,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="泛用类人决战型机器人博士">
<meta property="og:type" content="website">
<meta property="og:title" content="Txing">
<meta property="og:url" content="https://txing-casia.github.io/page/14/index.html">
<meta property="og:site_name" content="Txing">
<meta property="og:description" content="泛用类人决战型机器人博士">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Txing">
<meta property="article:tag" content="Txing">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://txing-casia.github.io/page/14/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Txing</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Txing</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">欢迎来到 | 伽蓝之堂</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>Sitemap</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://txing-casia.github.io/2021/03/25/2021-03-25-Neuroscience%20-%20A%20Gain-Field%20Encoding%20of%20Limb%20Position%20and%20Velocity%20in%20the%20Internal%20Model%20of%20Arm%20Dynamics/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Txing">
      <meta itemprop="description" content="泛用类人决战型机器人博士">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Txing">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/25/2021-03-25-Neuroscience%20-%20A%20Gain-Field%20Encoding%20of%20Limb%20Position%20and%20Velocity%20in%20the%20Internal%20Model%20of%20Arm%20Dynamics/" class="post-title-link" itemprop="url">Neuroscience | A Gain-Field Encoding of Limb Position and Velocity in the Internal Model of Arm Dynamics</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-25 00:00:00" itemprop="dateCreated datePublished" datetime="2021-03-25T00:00:00+08:00">2021-03-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-25 09:54:14" itemprop="dateModified" datetime="2023-03-25T09:54:14+08:00">2023-03-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="a-gain-field-encoding-of-limb-position-and-velocity-in-the-internal-model-of-arm-dynamics">A
Gain-Field Encoding of Limb Position and Velocity in the Internal Model
of Arm Dynamics</h1>
<p>论文链接：https://journals.plos.org/plosbiology/article?id=10.1371/journal.pbio.0000025</p>
<h2 id="背景">背景</h2>
<p>reaching任务的适应性取决于大脑中的计算，这种计算将手臂的位置和速度的感觉线索转换为运动指令。</p>
<p>本文提出一种位置-速度增益场来进行这种转换。</p>
<p>增益场中的运动基元由线性的位置编码基元和高斯形的速度编码基元乘法调制。</p>
<p>文章得出两个结论：</p>
<ol type="1">
<li><p>在被训练的空间之外，增益场依然能帮助泛化</p></li>
<li><p>非单调的力模式（nonmonotonic force
patterns）比单调的力模式（monotonic force patterns）更难学习</p></li>
</ol>
<h2 id="主要工作">主要工作</h2>
<ul>
<li><p>行为（<a target="_blank" rel="noopener" href="https://journals.plos.org/plosbiology/article?id=10.1371/journal.pbio.0000025#pbio.0000025-Shadmehr2">Shadmehr和Mussa-Ivaldi，1994</a>；<a target="_blank" rel="noopener" href="https://journals.plos.org/plosbiology/article?id=10.1371/journal.pbio.0000025#pbio.0000025-Conditt1">Conditt和Mussa-Ivaldi，1999</a>）和神经生理学（<a target="_blank" rel="noopener" href="https://journals.plos.org/plosbiology/article?id=10.1371/journal.pbio.0000025#pbio.0000025-Li1">Li等，2001</a>；<a target="_blank" rel="noopener" href="https://journals.plos.org/plosbiology/article?id=10.1371/journal.pbio.0000025#pbio.0000025-Gribble1">Gribble和Scott，2002）</a>）证据表明，大脑通过高度适应性强的内部模型控制肢体运动，</p></li>
<li><p>神经生理学实验表明运动皮层可能是学习肢体动力学内部模型的神经系统的重要组成部分之一（<a target="_blank" rel="noopener" href="https://www.cell.com/neuron/fulltext/S0896-6273(01)00301-4">Li et
al.
2001</a>）。现在有关于各种运动参数如何变化的重要信息，例如肢体速度（<a target="_blank" rel="noopener" href="https://journals.plos.org/plosbiology/article?id=10.1371/journal.pbio.0000025#pbio.0000025-Moran1">Moran和Schwartz，1999年</a>），手臂方向（<a target="_blank" rel="noopener" href="https://journals.plos.org/plosbiology/article?id=10.1371/journal.pbio.0000025#pbio.0000025-Scott1">Scott和Kalaska，1997年</a>；<a target="_blank" rel="noopener" href="https://journals.plos.org/plosbiology/article?id=10.1371/journal.pbio.0000025#pbio.0000025-Scott2">Scott等，1997年</a>）以及手部姿势（<a target="_blank" rel="noopener" href="https://journals.plos.org/plosbiology/article?id=10.1371/journal.pbio.0000025#pbio.0000025-Caminiti1">Caminiti等，1990年</a>；<a target="_blank" rel="noopener" href="https://journals.plos.org/plosbiology/article?id=10.1371/journal.pbio.0000025#pbio.0000025-Sergio1">Sergio和Kalaska</a>，<a target="_blank" rel="noopener" href="https://journals.plos.org/plosbiology/article?id=10.1371/journal.pbio.0000025#pbio.0000025-Scott2">1997年</a>）<a target="_blank" rel="noopener" href="https://journals.plos.org/plosbiology/article?id=10.1371/journal.pbio.0000025#pbio.0000025-Sergio1">1997</a>）由运动皮层中的神经元编码。</p></li>
<li><p>具有反映在神经生理学实验中发现的某些细胞特性的元素的计算模型已尝试解释适应过程中泛化的模式如何与神经表征相关。这些计算模型假设内部模型由“元素”或碱基组成，每个仅编码感觉空间的一部分，并且人口代码在计算感觉运动转换时会结合这些元素（<a target="_blank" rel="noopener" href="https://journals.plos.org/plosbiology/article?id=10.1371/journal.pbio.0000025#pbio.0000025-Georgopoulos2">Georgopoulos等人1986</a>；<a target="_blank" rel="noopener" href="https://journals.plos.org/plosbiology/article?id=10.1371/journal.pbio.0000025#pbio.0000025-Levi1">Levi和Camhi
2000</a>；<a target="_blank" rel="noopener" href="https://journals.plos.org/plosbiology/article?id=10.1371/journal.pbio.0000025#pbio.0000025-Pouget2">Pouget等人2000</a>；<a target="_blank" rel="noopener" href="https://journals.plos.org/plosbiology/article?id=10.1371/journal.pbio.0000025#pbio.0000025-Thoroughman1">Thoroughman和Shadmehr
2000</a>；<a target="_blank" rel="noopener" href="https://journals.plos.org/plosbiology/article?id=10.1371/journal.pbio.0000025#pbio.0000025-Donchin1">Donchin和Shadmehr
2002</a>；<a target="_blank" rel="noopener" href="https://journals.plos.org/plosbiology/article?id=10.1371/journal.pbio.0000025#pbio.0000025-Steinberg1">Steinberg等人2002。</a>）。该图将期望的感觉状态转换为即将到来的力的预测。在这些假设下，错误概括的模式应揭示基本元素的形状。</p></li>
<li><p>我们进行了一组实验，检查了神经元如何同时编码肢体位置和速度。我们表明，运动误差一般用一种模式暗示，该模式表明肢体位置空间的线性或单调编码，并且该编码是通过运动方向的编码进行乘法调制的。我们从泛化模式中得出的肢体位置和速度的增益场编码与运动皮层中这些参数的神经编码非常相似（<a target="_blank" rel="noopener" href="https://journals.plos.org/plosbiology/article?id=10.1371/journal.pbio.0000025#pbio.0000025-Georgopoulos1">Georgopoulos等，1984</a>）</p></li>
<li><p>实验部分：</p>
<ul>
<li><p>每个运动的关节转动角度相同，运动时间相同，因此保证探索相同的关节速度-位置空间</p></li>
<li><p>力场为 <strong>viscous
curl-field</strong>（粘性卷曲力场）</p></li>
<li><p><strong>catch trial</strong> 是不加力场的运动；<strong>field
trial</strong> 是加力场的运动</p></li>
<li><p>左边的轨迹，力场向左推手；</p></li>
<li><p>右边的轨迹，力场向右推手</p></li>
<li><p>中间的轨迹，力场输出为0</p></li>
</ul></li>
<li><p>运动相隔越远，力越能联系它们</p></li>
<li><p>以上结果表明，当不同的力与相同方向但在不同空间位置的两个运动相关联时，泛化会随着它们之间距离的增加而降低。另一方面，较早的结果发现，当在单个位置学习到不同方向的运动时，学习会推广到很远的其他手臂位置（<a target="_blank" rel="noopener" href="https://journals.plos.org/plosbiology/article?id=10.1371/journal.pbio.0000025#pbio.0000025-Ghez1">Ghez等，2000</a>；<a target="_blank" rel="noopener" href="https://journals.plos.org/plosbiology/article?id=10.1371/journal.pbio.0000025#pbio.0000025-Shadmehr1">Shadmehr和Moussavi，2000</a>；<a target="_blank" rel="noopener" href="https://journals.plos.org/plosbiology/article?id=10.1371/journal.pbio.0000025#pbio.0000025-Malfait1">Malfait等，2002</a>）。</p>
<p>The above results demonstrate that when different forces are to be
associated with two movements that are in the same direction but at
different spatial locations, generalization decreases with increased
distance between them. On the other hand, earlier results had found that
when movements to various directions are learned at a single location,
learning generalizes to other arm locations very far away (<a target="_blank" rel="noopener" href="https://journals.plos.org/plosbiology/article?id=10.1371/journal.pbio.0000025#pbio.0000025-Ghez1">Ghez
et al. 2000</a>; <a target="_blank" rel="noopener" href="https://journals.plos.org/plosbiology/article?id=10.1371/journal.pbio.0000025#pbio.0000025-Shadmehr1">Shadmehr
and Moussavi 2000</a>; <a target="_blank" rel="noopener" href="https://journals.plos.org/plosbiology/article?id=10.1371/journal.pbio.0000025#pbio.0000025-Malfait1">Malfait
et al. 2002</a>).</p></li>
<li><p>我们同时考虑了位置空间的高斯编码和线性编码。我们首先假设肢体位置空间为高斯编码，并评估基础元素的最佳宽度以适合数据。我们惊讶地发现，每个元素的半峰处最佳全宽约为80厘米（高斯函数的标准偏差，σ=
34厘米）。通过高斯基础元素对位置空间进行非常广泛的调整，在工作空间宽度的三倍的工作空间上形成了一个基本上线性的位置相关的接收场。由于此模型在我们的整个训练空间以及以后的范围内都产生了基本上单调的位置编码，因此我们决定详细研究具有简单线性位置编码的模型。的确，<strong>运动皮层</strong>的研究（<a target="_blank" rel="noopener" href="https://journals.plos.org/plosbiology/article?id=10.1371/journal.pbio.0000025#pbio.0000025-Georgopoulos1">Georgopoulos等人，1984年</a>；<a target="_blank" rel="noopener" href="https://journals.plos.org/plosbiology/article?id=10.1371/journal.pbio.0000025#pbio.0000025-Sergio1">Sergio和Kalaska（1997</a>），<strong>体感皮质</strong>（<a target="_blank" rel="noopener" href="https://journals.plos.org/plosbiology/article?id=10.1371/journal.pbio.0000025#pbio.0000025-Prudahomme1">Prud'homme和Kalaska
1994</a> ; <a target="_blank" rel="noopener" href="https://journals.plos.org/plosbiology/article?id=10.1371/journal.pbio.0000025#pbio.0000025-Tillery1">Tillery等人1996</a>）和<strong>脊髓小脑束</strong>（<a target="_blank" rel="noopener" href="https://journals.plos.org/plosbiology/article?id=10.1371/journal.pbio.0000025#pbio.0000025-Bosco1">Bosco等人1996</a>）发现，这些区域的细胞在全局范围内通常是<strong>线性地编码肢体静态位置</strong>。</p></li>
<li><p><strong>加性编码不能适应作为位置和速度的非线性函数的场</strong>，例如<em>f</em>（<em>x</em>，<em>ẋ</em>）=（<em>x
/ d</em>）·
<em>Bẋ</em>。这是描述我们在上一节中考虑的任务的力场。理论研究表明，要适应这样的非线性场，必须以乘法而不是加法形成组合空间的基函数（<a target="_blank" rel="noopener" href="https://journals.plos.org/plosbiology/article?id=10.1371/journal.pbio.0000025#pbio.0000025-Pouget1">Pouget和Sejnowski
1997</a>）。我们选择使用位置和速度的乘法组合。</p></li>
<li><p><strong>假设位置和速度通过增益场机制联合编码。</strong>We
hypothesized that position and velocity encoding are combined via a
gain-field mechanism</p></li>
<li><p>图3B是两个基元，线性力场的情况下的基元权重学习过程，曲线越与中间斜率为-1的虚线对齐，表示学习越快越高效。（1/2kd,-1/2kd）是最佳权重。k越大、d越大、b越小，越能出尽快速学习。</p></li>
<li><p>图3B中的简单线性基元示意：</p>
<ul>
<li><span class="math display">\[
f(x)=\frac{x}{d}\\
g_1=kx+b\\
g_2=-kx+b
\]</span></li>
</ul></li>
<li><p>Importantly, when the trained position <em>d</em> is close to the
zero of the coordinate axis, the slope is also close to zero, making the
generalization function flat (i.e., global generalization).</p></li>
<li><p>适应力场并不只是单纯地增加刚度。This was not simply a result of
<strong>increased stiffness</strong> because, when the force field was
removed unexpectedly, the trajectories and endpoint errors were on the
opposite side of those in the early force field, indicating <strong>a
proper internal model</strong>. <a target="_blank" rel="noopener" href="https://journals.plos.org/plosbiology/article?id=10.1371/journal.pbio.0000025#pbio-0000025-g004">Figure
4</a>C shows a position-dependent field in this category, and <a target="_blank" rel="noopener" href="https://journals.plos.org/plosbiology/article?id=10.1371/journal.pbio.0000025#pbio-0000025-g004">Figure
4</a>D–<a target="_blank" rel="noopener" href="https://journals.plos.org/plosbiology/article?id=10.1371/journal.pbio.0000025#pbio-0000025-g004">4</a>F
shows movements made by the simulation as it adapts to this field. This
pattern of adaptation is similar to reported values in human data (<a target="_blank" rel="noopener" href="https://journals.plos.org/plosbiology/article?id=10.1371/journal.pbio.0000025#pbio.0000025-Flash1">Flash
and Gurevich 1997</a>).</p></li>
<li><p>图4AB，在L区域训练，然后再R区域测试，在新力场中学习速度变快</p></li>
<li><p>两个模型的预测：</p>
<ol type="1">
<li><p>a change to the pattern of forces can substantially increase the
difficulty of a task; 力场中变化的力模式会大大增加任务难度</p></li>
<li><p>there should be hypergeneralization; i.e., forces expected in an
untrained part of the workspace may be larger than the ones experienced
at a trained
location.超泛化性，在工作空间的未训练部分预期的力可能比在训练位置经历的力大</p></li>
</ol></li>
<li><p>尽管在训练空间上学得很少，但我们在测试空间中发现了明显更大的后效应，即过度概括。我们的模拟表明，这种过度概括不能归因于<strong>肢体惯性</strong>和/或<strong>刚度</strong>随肢体位置的变化而变化。More
importantly, despite this small learning in the training space, we found
significantly bigger aftereffects in the test space, i.e.,
hypergeneralization. Our simulations suggest that this
hypergeneralization could not be due to varying limb inertia and/or
stiffness as a function of limb position.</p></li>
<li><p><strong>增益场定义</strong>：细胞编码中两个独立变量的乘法相互作用称为增益场编码。Multiplicative
interaction of two independent variables in cell encoding is called
gain-field coding.</p></li>
<li><p>位置-速度运动基元：</p></li>
</ul>
<p><span class="math display">\[
\tau=\sum Wg_z\\
g_z(q,\dot{q})=g_p(q)*g_v(\dot{q})\\
g_{p,i}(q)=k_i^T\cdot q+b\\
g_{v,i}(\dot{q})=\exp\bigg(\frac{\parallel\dot{q}-c_i\parallel^2}{2\sigma^2}\bigg)\\
k_i=|k| \cdot
\begin{bmatrix}
\cos(\theta_i)\\
\sin(\theta_i)\\
\end{bmatrix}
\\
b=1.3\\
k=1
\]</span></p>
<h2 id="总结">总结</h2>
<p>很有趣的文章，值得进一步考虑。但是提出的模型比较简单，可以进一步讨论。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://txing-casia.github.io/2021/03/24/2021-03-24-JZOffer%2006-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8-%E7%AE%80%E5%8D%95-%E9%93%BE%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Txing">
      <meta itemprop="description" content="泛用类人决战型机器人博士">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Txing">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/24/2021-03-24-JZOffer%2006-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8-%E7%AE%80%E5%8D%95-%E9%93%BE%E8%A1%A8/" class="post-title-link" itemprop="url">JZOffer 06-从尾到头打印链表-简单-链表</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-24 00:00:00" itemprop="dateCreated datePublished" datetime="2021-03-24T00:00:00+08:00">2021-03-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-25 09:54:14" itemprop="dateModified" datetime="2023-03-25T09:54:14+08:00">2023-03-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="剑指-offer-06.-从尾到头打印链表"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">剑指
Offer 06. 从尾到头打印链表</a></h4>
<h2 id="question">Question</h2>
<blockquote>
<p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
</blockquote>
<blockquote>
<p><strong>Example 1:</strong></p>
<p>输入：head = [1,3,2] 输出：[2,3,1]</p>
</blockquote>
<blockquote>
<p><strong>提示：</strong></p>
<ul>
<li>0 &lt;= 链表长度 &lt;= 10000</li>
</ul>
</blockquote>
<h3 id="approach-1-栈">Approach 1: 栈</h3>
<p>栈的特点是后进先出，即最后压入栈的元素最先弹出。考虑到栈的这一特点，使用栈将链表元素顺序倒置。从链表的头节点开始，依次将每个节点压入栈内，然后依次弹出栈内的元素并存储到数组中。</p>
<ul>
<li><p>创建一个栈，用于存储链表的节点</p></li>
<li><p>创建一个指针，初始时指向链表的头节点</p></li>
<li><p>当指针指向的元素非空时，重复下列操作：</p>
<ul>
<li>将指针指向的节点压入栈内</li>
<li>将指针移到当前节点的下一个节点</li>
</ul></li>
<li><p>获得栈的大小 size，创建一个数组 print，其大小为 size</p></li>
<li><p>创建下标并初始化 index = 0</p></li>
<li><p>重复 size 次下列操作：</p>
<ul>
<li><p>从栈内弹出一个节点，将该节点的值存到 print[index]</p></li>
<li><p>将 index 的值加 1</p></li>
</ul></li>
<li><p>返回 print</p></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.val = x</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">stringToListNode</span>(<span class="params"><span class="built_in">input</span></span>):</span><br><span class="line">    <span class="comment"># Now convert that list into linked list</span></span><br><span class="line">    dummyRoot = ListNode(<span class="number">0</span>)</span><br><span class="line">    ptr = dummyRoot</span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> <span class="built_in">input</span>:</span><br><span class="line">        ptr.<span class="built_in">next</span> = ListNode(number)</span><br><span class="line">        ptr = ptr.<span class="built_in">next</span></span><br><span class="line">    ptr = dummyRoot.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> ptr</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">listNodeToString</span>(<span class="params">node</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[]&quot;</span></span><br><span class="line">    result = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> node:</span><br><span class="line">        result += <span class="built_in">str</span>(node.val) + <span class="string">&quot;, &quot;</span></span><br><span class="line">        node = node.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;[&quot;</span> + result[:-<span class="number">2</span>] + <span class="string">&quot;]&quot;</span> <span class="comment"># 最后一个逗号不输出</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reversePrint</span>(<span class="params">self, head: ListNode</span>):</span><br><span class="line">        resList = []</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            resList.append(head.val)</span><br><span class="line">            head = head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> resList[::-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    head = stringToListNode([<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>])</span><br><span class="line">    solution=Solution().reversePrint(head)</span><br><span class="line">    <span class="built_in">print</span>(solution)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：O(n)。正向遍历一遍链表，然后从栈弹出全部节点，等于又反向遍历一遍链表。</p></li>
<li><p>空间复杂度：O(n)。额外使用一个栈存储链表中的每个节点。</p></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://txing-casia.github.io/2021/03/23/2021-03-23-Neuroscience%20-%20Learning%20of%20action%20through%20adaptive%20combination%20of%20motor%20primitives/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Txing">
      <meta itemprop="description" content="泛用类人决战型机器人博士">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Txing">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/23/2021-03-23-Neuroscience%20-%20Learning%20of%20action%20through%20adaptive%20combination%20of%20motor%20primitives/" class="post-title-link" itemprop="url">Neuroscience | Learning of action through adaptive combination of motor primitives (Nature)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-23 00:00:00" itemprop="dateCreated datePublished" datetime="2021-03-23T00:00:00+08:00">2021-03-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-25 09:54:14" itemprop="dateModified" datetime="2023-03-25T09:54:14+08:00">2023-03-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="learning-of-action-through-adaptive-combination-of-motor-primitives">Learning
of action through adaptive combination of motor primitives</h1>
<p>论文链接：https://www.nature.com/articles/35037588</p>
<h2 id="背景">背景</h2>
<p>理解大脑如何构造运动仍然是神经科学领域的一项基本挑战。</p>
<p>大脑可以通过运动基元灵活组合来控制复杂的运动，其中每个基元都是感觉运动地图中的计算元素，它将所需的肢体轨迹转换为运动命令。</p>
<h2 id="主要工作">主要工作</h2>
<ul>
<li><p>人在运动之前，通过预测力或者力矩，构建运动指令。然后不断调整预测，使得形成的轨迹近似期望的路径。</p></li>
<li><p>训练区域外的运动会被训练区域内的训练影响，说明大脑构建了一个状态依赖的近似外部力的<strong>内部模型</strong>（internal
model）</p></li>
<li><p>内部模型的泛化性能通过“抓取实验”来量化验证</p>
<p>Shadmehr, R. &amp; Mussa-Ivaldi, F. A. Adaptive representation of
dynamics during learning of a motor task. J. Neurosci. 14, 3208–3224
(1994).</p>
<p>Ghez, C., Krakauer, J. W., Sainburg, R. L. &amp; Ghilardi, M. F. in
The New Cognitive Neurosciences (ed. Gazzaniga, M. S.) 501–514 (MIT
Press, Cambridge, Massachusetts, 2000).</p></li>
<li><p><strong>本文主要介绍了如何通过灵活地组合运动基元构建内部模型，形成感觉-运动地图（sensorimotor
map），构建从轨迹到运动指令的具有泛化能力的转换。</strong></p></li>
<li><p>学习粘滞力场（viscous forces）<span class="math display">\[f=B\dot{x}\]</span></p></li>
<li><p>随着场空间频率的增加，对于所有基函数宽度，内部模型的精度都会下降。但是，更广泛的基础的学习能力在较低的频率下崩溃了。这与最近的发现是一致的，即人类在较高的空间频率力场中表现出的适应能力较弱。</p>
<p>Matsouka, Y. Models of generalization in motor control. PhD thesis,
MIT ( 1998).</p></li>
</ul>
<h2 id="总结">总结</h2>
<p>算是运动基元的比较早的也是比较权威的工作（Nature）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://txing-casia.github.io/2021/03/23/2021-03-23-Q402-%E7%A7%BB%E6%8E%89k%E4%BD%8D%E6%95%B0%E5%AD%97-%E4%B8%AD%E7%AD%89-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Txing">
      <meta itemprop="description" content="泛用类人决战型机器人博士">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Txing">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/23/2021-03-23-Q402-%E7%A7%BB%E6%8E%89k%E4%BD%8D%E6%95%B0%E5%AD%97-%E4%B8%AD%E7%AD%89-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">Q402-移掉K位数字-中等-贪心算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-23 00:00:00" itemprop="dateCreated datePublished" datetime="2021-03-23T00:00:00+08:00">2021-03-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-25 09:54:14" itemprop="dateModified" datetime="2023-03-25T09:54:14+08:00">2023-03-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="移掉k位数字"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-k-digits/">402.
移掉K位数字</a></h4>
<h2 id="question">Question</h2>
<blockquote>
<p>给定一个以字符串表示的非负整数 num，移除这个数中的 k
位数字，使得剩下的数字最小。</p>
<p><strong>注意:</strong></p>
<ul>
<li>num 的长度小于 10002 且 ≥ k。</li>
<li>num 不会包含任何前导零。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>Example 1:</strong></p>
<p>输入: num = "1432219", k = 3 输出: "1219" 解释: 移除掉三个数字 4, 3,
和 2 形成一个新的最小的数字 1219。</p>
</blockquote>
<blockquote>
<p><strong>Example 2：</strong></p>
<p>输入: num = "10200", k = 1 输出: "200" 解释: 移掉首位的 1
剩下的数字为 200. 注意输出不能有任何前导零。</p>
</blockquote>
<blockquote>
<p><strong>Example 3:</strong></p>
<p>输入: num = "10", k = 2 输出: "0" 解释:
从原数字移除所有的数字，剩余为空就是0。</p>
</blockquote>
<h3 id="approach-1-贪心-单调栈">Approach 1: 贪心 + 单调栈</h3>
<p>对于两个相同长度的数字序列，最左边不同的数字决定了这两个数字的大小，例如，对于
A = 1axxx，B = 1bxxx，如果 a &gt; b 则 A &gt; B。</p>
<p>基于此，我们可以知道，若要使得剩下的数字最小，需要保证靠前的数字尽可能小。</p>
<p>让我们从一个简单的例子开始。给定一个数字序列，例如
425，如果要求我们只删除一个数字，那么从左到右，我们有 4、2 和 5
三个选择。我们将每一个数字和它的左邻居进行比较。从 2 开始，2
小于它的左邻居 4。假设我们保留数字 4，那么所有可能的组合都是以数字 4（即
42，45）开头的。相反，如果移掉 4，留下 2，我们得到的是以 2
开头的组合（即 25），这明显小于任何留下数字 4
的组合。因此我们应该移掉数字 4。如果不移掉数字
4，则之后无论移掉什么数字，都不会得到最小数。</p>
<p>基于上述分析，我们可以得出「删除一个数字」的贪心策略：</p>
<p>给定一个长度为 n 的数字序列 <span class="math display">\[[D_0D_1D_2D_3\ldots
D_{n-1}]\]</span>，从左往右找到第一个位置 i（i&gt;0）使得 <span class="math display">\[D_i&lt;D_{i-1}\]</span>，并删去 <span class="math display">\[D_{i-1}\]</span>；如果不存在，说明整个数字序列单调不降，删去最后一个数字即可。</p>
<p>基于此，我们可以每次对整个数字序列执行一次这个策略；删去一个字符后，剩下的
n−1 长度的数字序列就形成了新的子问题，可以继续使用同样的策略，直至删除 k
次。</p>
<p>然而暴力的实现复杂度最差会达到
O(nk)（考虑整个数字序列是单调不降的），因此我们需要加速这个过程。</p>
<p>考虑从左往右增量的构造最后的答案。我们可以用一个栈维护当前的答案序列，栈中的元素代表截止到当前位置，删除不超过
k 次个数字后，所能得到的最小整数。根据之前的讨论：在使用 k
个删除次数之前，栈中的序列从栈底到栈顶单调不降。</p>
<p>因此，对于每个数字，如果该数字小于栈顶元素，我们就不断地弹出栈顶元素，直到</p>
<ul>
<li>栈为空</li>
<li>或者新的栈顶元素不大于当前数字</li>
<li>或者我们已经删除了 k 位数字</li>
</ul>
<p>上述步骤结束后我们还需要针对一些情况做额外的处理：</p>
<ul>
<li>如果我们删除了 m 个数字且
m&lt;k，这种情况下我们需要从序列尾部删除额外的 k-m 个数字。</li>
<li>如果最终的数字序列存在前导零，我们要删去前导零。</li>
<li>如果最终数字序列为空，我们应该返回 0。</li>
</ul>
<p>最终，从栈底到栈顶的答案序列即为最小数。</p>
<p>考虑到栈的特点是后进先出，如果通过栈实现，则需要将栈内元素依次弹出然后进行翻转才能得到最小数。为了避免翻转操作，可以使用双端队列代替栈的实现。</p>
<p><strong>几个关键函数：</strong></p>
<ul>
<li><code>"".join(finalStack)</code>用双引号内的字符作为连接将finalstack变为字符串。</li>
<li><code>finalStack.lstrip('0')</code>去掉finalStack左边的指定字符<code>0</code>。相对的，<code>finalStack.rstrip('0')</code>去掉finalStack右边的指定字符<code>0</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeKdigits</span>(<span class="params">self, num: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        numStack = []</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 构建单调递增的数字串</span></span><br><span class="line">        <span class="keyword">for</span> digit <span class="keyword">in</span> num:</span><br><span class="line">            <span class="keyword">while</span> k <span class="keyword">and</span> numStack <span class="keyword">and</span> numStack[-<span class="number">1</span>] &gt; digit:</span><br><span class="line">                numStack.pop()</span><br><span class="line">                k -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">            numStack.append(digit)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果 K &gt; 0，删除末尾的 K 个字符</span></span><br><span class="line">        finalStack = numStack[:-k] <span class="keyword">if</span> k <span class="keyword">else</span> numStack</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 抹去前导零</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(finalStack).lstrip(<span class="string">&#x27;0&#x27;</span>) <span class="keyword">or</span> <span class="string">&quot;0&quot;</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    num = <span class="string">&quot;1432219&quot;</span></span><br><span class="line">    k = <span class="number">3</span></span><br><span class="line">    solution=Solution().removeKdigits(num,k)</span><br><span class="line">    <span class="built_in">print</span>(solution)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n)，其中 n
为字符串的长度。尽管存在嵌套循环，但内部循环最多运行 k 次。由于 <span class="math display">\[0 &lt; k \le
n\]</span>，主循环的时间复杂度被限制在 2n
以内。对于主循环之外的逻辑，它们的时间复杂度是 O(n)，因此总时间复杂度为
O(n)。</li>
<li>空间复杂度：O(n)。栈存储数字需要线性的空间。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://txing-casia.github.io/2021/03/22/2021-03-22-Q191-%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0-%E7%AE%80%E5%8D%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Txing">
      <meta itemprop="description" content="泛用类人决战型机器人博士">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Txing">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/22/2021-03-22-Q191-%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0-%E7%AE%80%E5%8D%95/" class="post-title-link" itemprop="url">Q191-位1的个数-简单</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-22 00:00:00" itemprop="dateCreated datePublished" datetime="2021-03-22T00:00:00+08:00">2021-03-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-25 09:54:14" itemprop="dateModified" datetime="2023-03-25T09:54:14+08:00">2023-03-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="位1的个数"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-1-bits/">191.
位1的个数</a></h4>
<h2 id="question">Question</h2>
<blockquote>
<p>编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为
'1' 的个数（也被称为<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/汉明重量">汉明重量</a>）。</p>
</blockquote>
<blockquote>
<p><strong>Example 1:</strong></p>
<p>输入：00000000000000000000000000001011 输出：3 解释：输入的二进制串
00000000000000000000000000001011 中，共有三位为 '1'。</p>
</blockquote>
<blockquote>
<p><strong>Example 2：</strong></p>
<p>输入：00000000000000000000000010000000 输出：1 解释：输入的二进制串
00000000000000000000000010000000 中，共有一位为 '1'。</p>
</blockquote>
<blockquote>
<p><strong>Example 3：</strong></p>
<p>输入：11111111111111111111111111111101 输出：31 解释：输入的二进制串
11111111111111111111111111111101 中，共有 31 位为 '1'。</p>
</blockquote>
<blockquote>
<p><strong>Note:</strong></p>
<ul>
<li>请注意，在某些语言（如
Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</li>
<li>在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的
示例 3 中，输入表示有符号整数 -3。</li>
<li>输入必须是长度为 <code>32</code> 的 <strong>二进制串</strong>
。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>进阶</strong>：</p>
<ul>
<li>如果多次调用这个函数，你将如何优化你的算法？</li>
</ul>
</blockquote>
<h3 id="approach-1-循环检查二进制位">Approach 1: 循环检查二进制位</h3>
<p>我们可以直接循环检查给定整数 n 的二进制位的每一位是否为
1。具体代码中，当检查第 i 位时，我们可以让 n 与 <span class="math display">\[2^i\]</span> 进行与运算，当且仅当 n 的第 i 位为 1
时，运算结果不为 0。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hammingWeight</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ret = <span class="built_in">sum</span>(<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>) <span class="keyword">if</span> n &amp; (<span class="number">1</span> &lt;&lt; i)) </span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">input</span> = <span class="number">11111111111111111111111111111101</span></span><br><span class="line">    solution=Solution().hammingWeight(<span class="built_in">input</span>)</span><br><span class="line">    <span class="built_in">print</span>(solution)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：<span class="math display">\[O(k)\]</span>，其中 k 是
<span class="math display">\[\text{int}\]</span>
型的二进制位数，k=32。我们需要检查 n 的二进制位的每一位，一共需要检查 32
位。</p></li>
<li><p>空间复杂度：<span class="math display">\[O(1)\]</span>，我们只需要常数的空间保存若干变量。</p></li>
</ul>
<h3 id="approach-2-位运算优化">Approach 2: 位运算优化</h3>
<p>观察这个运算：<span class="math display">\[n~\&amp;~(n -
1)\]</span>，其结果恰为把 n 的二进制位中的最低位的 1 变为 0
之后的结果。</p>
<p>如：<span class="math display">\[6~\&amp;~(6-1) = 4, 6 = (110)_2, 4 =
(100)_2\]</span> ，运算结果 4 即为把 6 的二进制位中的最低位的 1 变为 0
之后的结果。</p>
<p>这样我们可以利用这个位运算的性质加速我们的检查过程，在实际代码中，我们不断让当前的
n 与 n - 1 做与运算，直到 n 变为 0 即可。因为每次运算会使得 n 的最低位的
1 被翻转，因此运算次数就等于 n 的二进制位中 1 的个数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hammingWeight</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            n &amp;= n - <span class="number">1</span></span><br><span class="line">            ret += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：<span class="math display">\[O(\log
n)\]</span>。循环次数等于 n 的二进制位中 1 的个数，最坏情况下 n
的二进制位全部为 1。我们需要循环 <span class="math display">\[\log
n\]</span> 次。</li>
<li>空间复杂度：<span class="math display">\[O(1)\]</span>，我们只需要常数的空间保存若干变量。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://txing-casia.github.io/2021/03/19/2021-03-19-Q54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5-%E4%B8%AD%E7%AD%89-%E6%95%B0%E7%BB%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Txing">
      <meta itemprop="description" content="泛用类人决战型机器人博士">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Txing">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/19/2021-03-19-Q54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5-%E4%B8%AD%E7%AD%89-%E6%95%B0%E7%BB%84/" class="post-title-link" itemprop="url">Q54-螺旋矩阵-中等-数组</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-19 00:00:00" itemprop="dateCreated datePublished" datetime="2021-03-19T00:00:00+08:00">2021-03-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-25 09:54:14" itemprop="dateModified" datetime="2023-03-25T09:54:14+08:00">2023-03-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="螺旋矩阵"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/spiral-matrix/">54.
螺旋矩阵</a></h4>
<h2 id="question">Question</h2>
<blockquote>
<p>给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序
，返回矩阵中的所有元素。</p>
</blockquote>
<blockquote>
<p><strong>Example 1:</strong></p>
<p>输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]</p>
</blockquote>
<blockquote>
<p><strong>Example 2：</strong></p>
<p>输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
输出：[1,2,3,4,8,12,11,10,9,5,6,7]</p>
</blockquote>
<blockquote>
<p><strong>Note:</strong></p>
<ul>
<li>m == matrix.length</li>
<li>n == matrix[i].length</li>
<li>1 &lt;= m, n &lt;= 10</li>
<li>-100 &lt;= <span class="math display">\[matrix[i][j]\]</span> &lt;=
100</li>
</ul>
</blockquote>
<h3 id="approach-1-模拟">Approach 1: 模拟</h3>
<p>可以模拟螺旋矩阵的路径。初始位置是矩阵的左上角，初始方向是向右，当路径超出界限或者进入之前访问过的位置时，顺时针旋转，进入下一个方向。</p>
<p>判断路径是否进入之前访问过的位置需要使用一个与输入矩阵大小相同的辅助矩阵
<span class="math display">\[\textit{visited}\]</span>，其中的每个元素表示该位置是否被访问过。当一个元素被访问时，将
<span class="math display">\[\textit{visited}\]</span>
中的对应位置的元素设为已访问。</p>
<p>如何判断路径是否结束？由于矩阵中的每个元素都被访问一次，因此路径的长度即为矩阵中的元素数量，当路径的长度达到矩阵中的元素数量时即为完整路径，将该路径返回。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">spiralOrder</span>(<span class="params">self, matrix</span>):</span><br><span class="line">        <span class="comment"># 判断输入矩阵是否正常</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix <span class="keyword">or</span> <span class="keyword">not</span> matrix[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">list</span>()</span><br><span class="line">        </span><br><span class="line">        rows, columns = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        visited = [[<span class="literal">False</span>] * columns <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(rows)]</span><br><span class="line">        total = rows * columns</span><br><span class="line">        order = [<span class="number">0</span>] * total</span><br><span class="line"></span><br><span class="line">        directions = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, -<span class="number">1</span>], [-<span class="number">1</span>, <span class="number">0</span>]]</span><br><span class="line">        row, column = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        directionIndex = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(total):</span><br><span class="line">            <span class="comment"># 元素逐个加入</span></span><br><span class="line">            order[i] = matrix[row][column]</span><br><span class="line">            visited[row][column] = <span class="literal">True</span></span><br><span class="line">            nextRow, nextColumn = row + directions[directionIndex][<span class="number">0</span>], column + directions[directionIndex][<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (<span class="number">0</span> &lt;= nextRow &lt; rows <span class="keyword">and</span> <span class="number">0</span> &lt;= nextColumn &lt; columns <span class="keyword">and</span> <span class="keyword">not</span> visited[nextRow][nextColumn]):</span><br><span class="line">                directionIndex = (directionIndex + <span class="number">1</span>) % <span class="number">4</span></span><br><span class="line">            row += directions[directionIndex][<span class="number">0</span>]</span><br><span class="line">            column += directions[directionIndex][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> order</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    matrix = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line">    solution=Solution().spiralOrder(matrix)</span><br><span class="line">    <span class="built_in">print</span>(solution)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：<span class="math display">\[O(mn)\]</span>，其中 m
和 n
分别是输入矩阵的行数和列数。矩阵中的每个元素都要被访问一次。</p></li>
<li><p>空间复杂度：<span class="math display">\[O(mn)\]</span>。需要创建一个大小为 <span class="math display">\[m \times n\]</span> 的矩阵 <span class="math display">\[\textit{visited}\]</span>
记录每个位置是否被访问过。</p></li>
</ul>
<h3 id="approach-2-按层模拟">Approach 2: 按层模拟</h3>
<p>可以将矩阵看成若干层，首先输出最外层的元素，其次输出次外层的元素，直到输出最内层的元素。</p>
<p>定义矩阵的第 k 层是到最近边界距离为 k
的所有顶点。例如，下图矩阵最外层元素都是第 1 层，次外层元素都是第 2
层，剩下的元素都是第 3 层。</p>
<blockquote>
<p><code>[[1, 1, 1, 1, 1, 1, 1],</code></p>
<p><code>[1, 2, 2, 2, 2, 2, 1],</code></p>
<p><code>[1, 2, 3, 3, 3, 2, 1],</code></p>
<p><code>[1, 2, 2, 2, 2, 2, 1],</code></p>
<p><code>[1, 1, 1, 1, 1, 1, 1]]</code></p>
</blockquote>
<p>对于每层，从左上方开始以顺时针的顺序遍历所有元素。假设当前层的左上角位于
<span class="math display">\[(\textit{top},
\textit{left})\]</span>，右下角位于 <span class="math display">\[(\textit{bottom},
\textit{right})\]</span>，按照如下顺序遍历当前层的元素。</p>
<ul>
<li><p>从左到右遍历上侧元素，依次为 <span class="math display">\[(\textit{top}, \textit{left})\]</span> 到 <span class="math display">\[(\textit{top},
\textit{right})\]</span>。</p></li>
<li><p>从上到下遍历右侧元素，依次为 <span class="math display">\[(\textit{top} + 1, \textit{right})\]</span> 到
<span class="math display">\[(\textit{bottom},
\textit{right})\]</span>。</p></li>
<li><p>如果 <span class="math display">\[\textit{left} &lt;
\textit{right}\]</span> 且 <span class="math display">\[\textit{top}
&lt; \textit{bottom}\]</span>，则从右到左遍历下侧元素，依次为 <span class="math display">\[(\textit{bottom}, \textit{right} - 1)\]</span> 到
<span class="math display">\[(\textit{bottom}, \textit{left} +
1)\]</span>，以及从下到上遍历左侧元素，依次为 <span class="math display">\[(\textit{bottom}, \textit{left})\]</span> 到
<span class="math display">\[(\textit{top} + 1,
\textit{left})\]</span>。</p></li>
</ul>
<p>遍历完当前层的元素之后，将 <span class="math display">\[\textit{left}\]</span> 和 <span class="math display">\[\textit{top}\]</span> 分别增加 1，将 <span class="math display">\[\textit{right}\]</span> 和 <span class="math display">\[\textit{bottom}\]</span> 分别减少
1，进入下一层继续遍历，直到遍历完所有元素为止。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">spiralOrder</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix <span class="keyword">or</span> <span class="keyword">not</span> matrix[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">list</span>()</span><br><span class="line">        </span><br><span class="line">        rows, columns = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        order = <span class="built_in">list</span>()</span><br><span class="line">        left, right, top, bottom = <span class="number">0</span>, columns - <span class="number">1</span>, <span class="number">0</span>, rows - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right <span class="keyword">and</span> top &lt;= bottom:</span><br><span class="line">            <span class="keyword">for</span> column <span class="keyword">in</span> <span class="built_in">range</span>(left, right + <span class="number">1</span>):</span><br><span class="line">                order.append(matrix[top][column])</span><br><span class="line">            <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(top + <span class="number">1</span>, bottom + <span class="number">1</span>):</span><br><span class="line">                order.append(matrix[row][right])</span><br><span class="line">            <span class="keyword">if</span> left &lt; right <span class="keyword">and</span> top &lt; bottom:</span><br><span class="line">                <span class="keyword">for</span> column <span class="keyword">in</span> <span class="built_in">range</span>(right - <span class="number">1</span>, left, -<span class="number">1</span>):</span><br><span class="line">                    order.append(matrix[bottom][column])</span><br><span class="line">                <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(bottom, top, -<span class="number">1</span>):</span><br><span class="line">                    order.append(matrix[row][left])</span><br><span class="line">            left, right, top, bottom = left + <span class="number">1</span>, right - <span class="number">1</span>, top + <span class="number">1</span>, bottom - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> order</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：<span class="math display">\[O(mn)\]</span>，其中 m 和 n
分别是输入矩阵的行数和列数。矩阵中的每个元素都要被访问一次。</li>
<li>空间复杂度：<span class="math display">\[O(mn)\]</span>。除了输出数组以外，空间复杂度是常数。</li>
</ul>
<h3 id="approach-3-利用zip的简洁代码">Approach 3: 利用zip的简洁代码</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">spiralOrder</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> matrix:</span><br><span class="line">            <span class="comment"># 移除第一行并返回移除元素</span></span><br><span class="line">            res += matrix.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="comment"># zip(*Array) 可理解为解压，返回二维矩阵，把每一列打包</span></span><br><span class="line">            matrix = <span class="built_in">list</span>(<span class="built_in">zip</span>(*matrix))[::-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：<span class="math display">\[O(N\times p)\]</span>，其中
N 是 m 和 n 中最大值，调用 p 次zip()。因为函数调用时间复杂度是O(N)</li>
<li>空间复杂度：<span class="math display">\[O(mn)\]</span>。除了输出数组以外，空间复杂度是常数。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://txing-casia.github.io/2021/03/18/2021-03-18-Q1300-%E8%BD%AC%E5%8F%98%E6%95%B0%E7%BB%84%E5%90%8E%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C-%E4%B8%AD%E7%AD%89-%E6%95%B0%E7%BB%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Txing">
      <meta itemprop="description" content="泛用类人决战型机器人博士">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Txing">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/18/2021-03-18-Q1300-%E8%BD%AC%E5%8F%98%E6%95%B0%E7%BB%84%E5%90%8E%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C-%E4%B8%AD%E7%AD%89-%E6%95%B0%E7%BB%84/" class="post-title-link" itemprop="url">Q1300-转变数组后最接近目标值的数组和-中等-数组</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-18 00:00:00" itemprop="dateCreated datePublished" datetime="2021-03-18T00:00:00+08:00">2021-03-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-25 09:54:14" itemprop="dateModified" datetime="2023-03-25T09:54:14+08:00">2023-03-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="转变数组后最接近目标值的数组和"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target/">1300.
转变数组后最接近目标值的数组和</a></h4>
<h2 id="question">Question</h2>
<blockquote>
<p>给你一个整数数组 arr 和一个目标值 target ，请你返回一个整数 value
，使得将数组中所有大于 value 的值变成 value 后，数组的和最接近 target
（最接近表示两者之差的绝对值最小）。</p>
<p>如果有多种使得和最接近 target
的方案，请你返回这些整数中的最小值。</p>
<p>请注意，答案不一定是 arr 中的数字。</p>
</blockquote>
<blockquote>
<p><strong>Example 1:</strong></p>
<p>输入：arr = [4,9,3], target = 10 输出：3 解释：当选择 value 为 3
时，数组会变成 [3, 3, 3]，和为 9 ，这是最接近 target 的方案。</p>
</blockquote>
<blockquote>
<p><strong>Example 2：</strong></p>
<p>输入：arr = [2,3,5], target = 10 输出：5</p>
</blockquote>
<blockquote>
<p><strong>Example 3：</strong></p>
<p>输入：arr = [60864,25176,27249,21296,20204], target = 56803
输出：11361</p>
</blockquote>
<blockquote>
<p><strong>Note:</strong></p>
<ul>
<li>1 &lt;= arr.length &lt;= 10^4</li>
<li>1 &lt;= arr[i], target &lt;= 10^5</li>
</ul>
</blockquote>
<h3 id="approach-1-排序文件夹">Approach 1: 排序文件夹</h3>
<p>由于数组 arr 中每个元素值的范围是 [1,<span class="math display">\[10^5\]</span>]，在可以直接枚举的范围内，因此我们可以对所有可能作为
value 的值进行枚举。</p>
<p>那么 value 值的上下界是多少呢？我们需要进行一些分析：</p>
<ul>
<li><p>value 的下界为 0。这是因为当 value = 0 时，数组的和为 0。由于
target 是正整数，因此当 value
继续减小时，数组的和也会随之减小，且变为负数（这个和等于 value * n，其中
n 是数组 arr 的长度），并不会比 value = 0 时更接近 target。</p></li>
<li><p>value 的上界为数组 arr 中的最大值。这是因为当 value &gt;= arr
时，数组中所有的元素都不变，因为它们均不大于
value。由于我们需要找到最接近 target 的最小 value 值，因此我们只需将数组
arr 中的最大值作为上界即可。</p></li>
</ul>
<p>当我们确定了 value 值的上下界之后，就可以进行枚举了。当枚举到 value =
x 时，我们需要将数组 arr 中所有小于等于 x 的值保持不变，所有大于 x
的值变为 x。要实现这个操作，我们可以将数组 arr
先进行排序，随后进行二分查找，找出数组 arr 中最小的比 x 大的元素
arr[i]。由于将数组 arr 中的等于 x 的值变为 x
并没有改变原来的值，因此上述操作可以改为：</p>
<p><span class="math display">\[
arr[0] + ... + arr[i - 1] + x \times (n - i)
\]</span>
使用该操作是因为很多编程语言自带的二分查找只能返回目标值第一次出现的位置。在此鼓励读者自己实现返回目标值最后一次出现的位置的二分查找。</p>
<p>为了加速求和操作，我们可以预处理出数组 arr
的前缀和，这样数组求和的时间复杂度即能降为 O(1)。我们将和与 target
进行比较，同时更新答案即可。</p>
<p>这里会使用到二分查找的库bisect，几个相关的函数需要熟悉：</p>
<p>bisect.bisect_left(L,x)</p>
<p>bisect.bisect_right(L,x)</p>
<p>bisect.insort_left(L,x)</p>
<p>bisect.insort_right(L,x)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findBestValue</span>(<span class="params">self, arr, target</span>):</span><br><span class="line">        arr.sort()</span><br><span class="line">        n = <span class="built_in">len</span>(arr)</span><br><span class="line">        prefix = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> arr:</span><br><span class="line">            prefix.append(prefix[-<span class="number">1</span>] + num)</span><br><span class="line">        </span><br><span class="line">        r, ans, diff = <span class="built_in">max</span>(arr), <span class="number">0</span>, target</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, r + <span class="number">1</span>):</span><br><span class="line">            it = bisect.bisect_left(arr, i)</span><br><span class="line">            cur = prefix[it] + (n - it) * i</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">abs</span>(cur - target) &lt; diff:</span><br><span class="line">                ans, diff = i, <span class="built_in">abs</span>(cur - target)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    arr = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">    target = <span class="number">10</span></span><br><span class="line">    solution=Solution().findBestValue(arr, target)</span><br><span class="line">    <span class="built_in">print</span>(solution)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：<span class="math display">\[O((N + C)\log
N)\]</span>，其中 N 是数组 arr 的长度，C 是一个常数，为数组 arr
中的最大值，不会超过 10^5 。排序需要的时间复杂度为 <span class="math display">\[O(N \log N)\]</span>，二分查找的单次时间复杂度为
<span class="math display">\[O(\log N)\]</span>，需要进行 C 次。</li>
<li>空间复杂度：<span class="math display">\[O(N)\]</span>，我们需要
O(N)O(N) 的空间用来存储数组 arr 的前缀和，排序需要 <span class="math display">\[O(\log N)\]</span>
的栈空间，因此最后总空间复杂度为 <span class="math display">\[O(N)\]</span>。</li>
</ul>
<h3 id="approach-2-双重二分查找">Approach 2: 双重二分查找</h3>
<p>方法一的枚举策略建立在数组 arr 的元素范围不大的条件之上。如果数组 arr
中的元素范围是
[1,10^9]，那么我们将无法直接枚举，有没有更好的解决方法呢？</p>
<p>我们首先考虑题目的一个简化版本：我们需要找到
value，使得数组的和最接近 target 且不大于 target。可以发现，在
[0,(arr)]（即方法一中确定的上下界）的范围之内，随着 value
的增大，数组的和是严格单调递增的。这里「严格」的意思是，不存在两个不同的
value 值，它们对应的数组的和相等。这样一来，一定存在唯一的一个 value
值，使得数组的和最接近且不大于
target。并且由于严格单调递增的性质，我们可以通过二分查找的方法，找到这个
value 值，记为 value_lower。</p>
<p>同样地，我们考虑题目的另一个简化版本：我们需要找到一个
value，使得数组的和最接近 target 且大于
target。我们也可以通过二分查找的方法，找到这个 value 值，记为
value_upper。</p>
<p>显然 value 值就是 value_lower 和 value_upper
中的一个，我们只需要比较这两个值对应的数组的和与 target
的差，就能确定最终的答案。这样一来，我们通过两次二分查找，就可以找出
value
值，在每一次二分查找中，我们使用和方法一中相同的查找方法，快速地求出每个
value
值对应的数组的和。算法从整体上来看，是外层二分查找中嵌套了一个内层二分查找。</p>
<p>那么这个方法还有进一步优化的余地吗？仔细思考一下 value_lower 与
value_upper 的定义，前者最接近且不大于 target，后者最接近且大于
target。由于数组的和随着 value 的增大是严格单调递增的，所以 value_upper
的值一定就是 value_lower + 1。因此我们只需要进行一次外层二分查找得到
value_lower，并直接通过 value_lower + 1 计算出 value_upper
的值就行了。这样我们就减少了一次外层二分查找，虽然时间复杂度没有变化，但降低了常数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findBestValue</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        arr.sort()</span><br><span class="line">        n = <span class="built_in">len</span>(arr)</span><br><span class="line">        prefix = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> arr:</span><br><span class="line">            prefix.append(prefix[-<span class="number">1</span>] + num)</span><br><span class="line">        </span><br><span class="line">        l, r, ans = <span class="number">0</span>, <span class="built_in">max</span>(arr), -<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            mid = (l + r) // <span class="number">2</span></span><br><span class="line">            it = bisect.bisect_left(arr, mid)</span><br><span class="line">            cur = prefix[it] + (n - it) * mid</span><br><span class="line">            <span class="keyword">if</span> cur &lt;= target:</span><br><span class="line">                ans = mid</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">x</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">sum</span>(x <span class="keyword">if</span> num &gt;= x <span class="keyword">else</span> num <span class="keyword">for</span> num <span class="keyword">in</span> arr)</span><br><span class="line">        </span><br><span class="line">        choose_small = check(ans)</span><br><span class="line">        choose_big = check(ans + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans <span class="keyword">if</span> <span class="built_in">abs</span>(choose_small - target) &lt;= <span class="built_in">abs</span>(choose_big - target) <span class="keyword">else</span> ans + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：<span class="math display">\[O(N\log N)\]</span>，其中 N
是数组 arr 的长度。排序需要的时间复杂度为 <span class="math display">\[O(N \log N)\]</span>，外层二分查找的时间复杂度为
<span class="math display">\[O(\log
C)\]</span>，内层二分查找的时间复杂度为 <span class="math display">\[O(\log N)\]</span>，它们的乘积在数量级上小于
<span class="math display">\[O(N \log N)\]</span>。</li>
<li>空间复杂度：<span class="math display">\[O(N)\]</span>。分析同方法一。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://txing-casia.github.io/2021/03/17/2021-03-17-Q1233-%E5%88%A0%E9%99%A4%E5%AD%90%E6%96%87%E4%BB%B6%E5%A4%B9-%E4%B8%AD%E7%AD%89-%E6%95%B0%E7%BB%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Txing">
      <meta itemprop="description" content="泛用类人决战型机器人博士">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Txing">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/03/17/2021-03-17-Q1233-%E5%88%A0%E9%99%A4%E5%AD%90%E6%96%87%E4%BB%B6%E5%A4%B9-%E4%B8%AD%E7%AD%89-%E6%95%B0%E7%BB%84/" class="post-title-link" itemprop="url">Q1233-删除子文件夹-中等-数组</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-03-17 00:00:00" itemprop="dateCreated datePublished" datetime="2021-03-17T00:00:00+08:00">2021-03-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-25 09:54:14" itemprop="dateModified" datetime="2023-03-25T09:54:14+08:00">2023-03-25</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="删除子文件夹"><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-sub-folders-from-the-filesystem/">1233.
删除子文件夹</a></h4>
<h2 id="question">Question</h2>
<blockquote>
<p>你是一位系统管理员，手里有一份文件夹列表
folder，你的任务是要删除该列表中的所有<strong>子文件</strong>夹，并以
<strong>任意顺序</strong> 返回剩下的文件夹。</p>
<p>我们这样定义「子文件夹」：</p>
<ul>
<li><p>如果文件夹 folder[i] 位于另一个文件夹 folder[j] 下，那么
folder[i] 就是 folder[j]
的子文件夹。文件夹的「路径」是由一个或多个按以下格式串联形成的字符串：</p></li>
<li><p>/ 后跟一个或者多个小写英文字母。 例如，/leetcode 和
/leetcode/problems 都是有效的路径，而空字符串和 / 不是。</p></li>
</ul>
</blockquote>
<blockquote>
<p><strong>Example 1:</strong></p>
<p>输入：folder = ["/a","/a/b","/c/d","/c/d/e","/c/f"]
输出：["/a","/c/d","/c/f"] 解释："/a/b/" 是 "/a" 的子文件夹，而 "/c/d/e"
是 "/c/d" 的子文件夹。</p>
</blockquote>
<blockquote>
<p><strong>Example 2：</strong></p>
<p>输入：folder = ["/a","/a/b/c","/a/b/d"] 输出：["/a"] 解释：文件夹
"/a/b/c" 和 "/a/b/d/" 都会被删除，因为它们都是 "/a" 的子文件夹。</p>
</blockquote>
<blockquote>
<p><strong>Example 3：</strong></p>
<p>输入：folder = ["/a/b/c","/a/b/d","/a/b/ca"]
输出：["/a/b/c","/a/b/ca","/a/b/d"]</p>
</blockquote>
<blockquote>
<p><strong>Note:</strong></p>
<ul>
<li>1 &lt;= folder.length &lt;= 4 * 10^4</li>
<li>2 &lt;= folder[i].length &lt;= 100</li>
<li>folder[i] 只包含小写字母和 /</li>
<li>folder[i] 总是以字符 / 起始</li>
<li>每个文件夹名都是唯一的</li>
</ul>
</blockquote>
<h3 id="approach-1-排序文件夹">Approach 1: 排序文件夹</h3>
<p>对folder排序，排序第一个的是最短路，它一定是一个父文件夹，否则会有更短的文件夹在其前面。然后从左到右依次查找后面的文件夹路径是否包含那个父文件夹的路径，如果没有，把路径加入roots；如果有，跳过该路径，检查下一个。</p>
<p>startswith()方法用于检查字符串是否是以指定子字符串开头，如果是则返回
True，否则返回 False。如果参数 beg 和 end
指定值，则在指定范围内检查。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeSubfolders</span>(<span class="params">self, folder</span>):</span><br><span class="line">        <span class="comment"># 首先对folder排序，然后把第一个文件夹放入res中。但我们可以理解为，最短的文件夹一定不是一个子文件夹，否则还会有一个更短的父文件夹。然后遍历folder，因为已经排序了，所以每次只和res最后一个比较就可以。如果开头部分不相同，说明当前遍历到了一个新的文件夹目录，加入res。</span></span><br><span class="line">        folder.sort()</span><br><span class="line">        roots = [folder[<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(folder)):</span><br><span class="line">            fd = folder[i]</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> fd.startswith(roots[-<span class="number">1</span>] + <span class="string">&quot;/&quot;</span>):</span><br><span class="line">                roots.append(fd)</span><br><span class="line">        <span class="keyword">return</span> roots</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    folder = [<span class="string">&quot;/a&quot;</span>,<span class="string">&quot;/a/b&quot;</span>,<span class="string">&quot;/c/d&quot;</span>,<span class="string">&quot;/c/d/e&quot;</span>,<span class="string">&quot;/c/f&quot;</span>]</span><br><span class="line">    solution=Solution().removeSubfolders(folder)</span><br><span class="line">    <span class="built_in">print</span>(solution)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：<span class="math display">\[O(N)\]</span>，其中 N
为文件夹个数</li>
<li>空间复杂度：<span class="math display">\[O(N)\]</span>，建立roots数组</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/13/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/page/15/">15</a><span class="space">&hellip;</span><a class="page-number" href="/page/29/">29</a><a class="extend next" rel="next" href="/page/15/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Txing</p>
  <div class="site-description" itemprop="description">泛用类人决战型机器人博士</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">229</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">57</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/yourname" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/yourname" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;yourname" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Txing</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
