## 使用Gperf查看模块函数级别CPU资源占用

**步骤1：Cmake修改**

CMakeLists.txt文件，添加有`#_`标记的行

```
 set(PKGS common map error_relation) 
 set(PKG_LIBRARIES)
 foreach(pkg ${PKGS})
    find_package(${pkg})
    include_directories(${${pkg}_INCLUDE_DIRS})
    include_directories(/build_env/x86/thirdparty/gperf/include) #_ 
    link_directories(${${pkg}_LIBRARY_DIRS})
    link_directories(/build_env/x86/thirdparty/gperf/lib) #_
    message(STATUS "${pkg}_INCLUDE_DIRS ${${pkg}_INCLUDE_DIRS}")
    message(STATUS "${pkg}_LIBRARY_DIRS ${${pkg}_LIBRARY_DIRS}")
    list(APPEND PKG_LIBRARIES ${${pkg}_LIBRARIES})
 endforeach()

 #_
 include_directories(/build_env/x86/thirdparty/gperf/include) #_ 
 link_directories(/build_env/x86/thirdparty/gperf/lib) #_
```

```
if (USE_IPOPT)
    add_definitions(-DUSE_IPOPT)
    set(LIBS
        ${HIOS_ALL_LIBRARIES}
        ${PKG_LIBRARIES}
        ${catkin_LIBRARIES}
        ${OSQP_LIBRARIES}
        ${IPOPT_LIBRARIES}
        ${ADOLC_LIBRARIES}
        ${HSL_LIBRARIES}
        profiler #_
    )
else()
    set(LIBS
        ${HIOS_ALL_LIBRARIES}
        ${PKG_LIBRARIES}
        ${catkin_LIBRARIES}
        ${OSQP_LIBRARIES}
        # ${IPOPT_LIBRARIES}
        ${ADOLC_LIBRARIES}
        ${HSL_LIBRARIES}
        profiler #_ 
        )
endif()
```

include_directories(/build_env/x86/thirdparty/gperf/include)
   link_directories(/build_env/x86/thirdparty/gperf/lib)
   set(LIBS
      xxx
      profiler
      xxx)
LIBS 里面加入profiler。
建议如果是发版分支，在提交代码时，把BUILD_GPERF 设置为"OFF"



**步骤2：执行器代码更改**

planning_exec.h添加头文件

```
#include <gperftools/profiler.h> // #_
```

**步骤3：process函数修改**

planning_exec.cpp添加如下行

```
int PlanningExec::process(const ::haomo::pos::IData* const input, ::haomo::pos::IData* const output) {
    MLOG(PLANNING, INFO) << "-------------In PlanningExec process------------";
    
    // #_
    // GPERF_SECTION("planning.prof", 1200)
    static int ii = 0;
    if(ii == 0)
    {
        ProfilerStart("planning.prof"); 
        ProfilerRegisterThread();
        ProfilerEnable();
    }
    ii++;
    if(ii < 1200)
    {
        ProfilerFlush();
    }
    if(ii == 1200)
    {
        ProfilerStop();
    }
    // #_
```

1200 表示函数调用1200次后，终止profile，可根据实际情况修改

**步骤4：程序执行**

和之前在docker里跑包一样，正常运行即可。

**步骤5：生成text prof文件**

```
pprof ./output/x86/planning/lib/libplanning.so planning.prof  --text > test.txt
```

这里根据自己模块名称，生成prof名称替换即可。

txt文档从左到右的含义是：

每一行表示一个函数的信息。

flat：函数在 CPU 上运行的时间

flat%：函数在CPU上运行时间的百分比

sum%：是从上到当前行所有函数累加使用 CPU 的比例，如第二行sum=48.52=28.79+19.73

cum：这个函数以及子函数运行所占用的时间，应该大于等于flat

cum%：这个函数以及子函数运行所占用的比例，应该大于等于flat%

最后一列：函数的名字

步骤6：生成SVG文件

```
pprof ./output/x86/planning/lib/libplanning.so planning.prof  --svg > test.svg
```

最下面一行数字代表该函数共占用多少CPU片段，一个CPU片段大概是10ms。我一共跑了1200次，所以可以得出该函数的平均CPU时间是2386*10/1200 = 19ms



参考资料：

https://gperftools.github.io/gperftools/cpuprofile.html

https://www.cnblogs.com/caosiyang/archive/2013/01/25/2876244.html
