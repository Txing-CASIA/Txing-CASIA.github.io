---
layout:     post
title:      "JZOffer 55-平衡二叉树-II-简单-链表"
subtitle:   ""
date:       2021-04-14
author:     "Txing"
header-img: "img/post-bg-py.jpg"
tags:
    - Algorithm
    - Python
    - Easy
    - Tree

---

#### [剑指 Offer 55 - II. 平衡二叉树](https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/)

## Question

> 输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。



> **Example 1:**
>
> 给定二叉树 `[3,9,20,null,null,15,7]`
>
> ```
>    3
>    / \
>    9  20
>     /  \
>    15   7
>  ```
> 
> 返回 `true` 。

> **Example 2:**
>
> 给定二叉树 `[1,2,2,3,3,null,null,4,4]`
>
> ```
>        1
>       / \
>      2   2
>     / \
>    3   3
>   / \
>  4   4
> ```
>
> 返回 `false` 。

> **提示：**
>
> - `0 <= 树的结点个数 <= 10000`

注意：本题与主站 110 题相同：https://leetcode-cn.com/problems/balanced-binary-tree/



以下两种方法均基于以下性质推出： **此树的深度** 等于 **左子树的深度** 与 **右子树的深度** 中的 **最大值** +1+1 。

## Approach 1:  后序遍历 + 剪枝 （从底至顶）

>  此方法为本题的最优解法，但剪枝的方法不易第一时间想到。

思路是对二叉树做后序遍历，从底至顶返回子树深度，若判定某子树不是平衡树则 “剪枝” ，直接向上返回。

**算法流程：**
recur(root) 函数：

- **返回值：**
  
  - 当节点root 左 / 右子树的深度差 $$\leq 1$$ ：则返回当前子树的深度，即节点 root 的左 / 右子树的深度最大值 +1 （ max(left, right) + 1 ）；
  - 当节点root 左 / 右子树的深度差 > 2 ：则返回 -1 ，代表 此子树不是平衡树 。
  
- **终止条件：**
  
    - 当 root 为空：说明越过叶节点，因此返回高度 0 ；
    
    - 当左（右）子树深度为 -1 ：代表此树的 左（右）子树不是平衡树，因此剪枝，直接返回 -1 ；
    

isBalanced(root) 函数：

- **返回值**： 若 recur(root) != -1 ，则说明此树平衡，返回 true ； 否则返回 false 。


```python
class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        if not root: return 0
        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1
```

**复杂度分析**

- 时间复杂度 O(N)： N 为树的节点数量，计算树的深度需要遍历所有节点。
- 空间复杂度 O(N) ： 最差情况下（当树退化为链表时），递归深度可达到 N 。



## 方法二：层序遍历（BFS）

- 树的层序遍历 / 广度优先搜索往往利用 队列 实现。

- 关键点： 每遍历一层，则计数器 +1+1 ，直到遍历完成，则可得到树的深度。

**算法解析：**

- **特例处理**： 当 root 为空，直接返回 深度 00 。
- **初始化**： 队列 queue （加入根节点 root ），计数器 res = 0。
- **循环遍历**： 当 queue 为空时跳出。
  - 初始化一个空列表 tmp ，用于临时存储下一层节点；
  - 遍历队列： 遍历 queue 中的各节点 node ，并将其左子节点和右子节点加入 tmp；
  - 更新队列： 执行 queue = tmp ，将下一层节点赋值给 queue；
  - 统计层数： 执行 res += 1 ，代表层数加 1；
- **返回值**： 返回 res 即可。

```python
class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        if not root: return 0
        queue, res = [root], 0
        while queue:
            tmp = []
            for node in queue:
                if node.left: tmp.append(node.left)
                if node.right: tmp.append(node.right)
            queue = tmp
            res += 1
        return res
```

**复杂度分析**

- 时间复杂度 O(N) ： N 为树的节点数量，计算树的深度需要遍历所有节点。
- 空间复杂度 O(N) ： 最差情况下（当树平衡时），队列 queue 同时存储 N/2 个节点。