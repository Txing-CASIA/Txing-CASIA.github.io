---
layout:     post
title:      "Q1029-两地调度-中等-贪心"
subtitle:   ""
date:       2021-04-29
author:     "Txing"
header-img: "img/post-bg-py.jpg"
tags:
    - Algorithm
    - Python
    - Medium
    - Greedy
---

#### [1029. 两地调度](https://leetcode-cn.com/problems/two-city-scheduling/)

## Question

> 公司计划面试 2N 人。第 i 人飞往 A 市的费用为 $$costs[i][0]$$，飞往 B 市的费用为 $$costs[i][1]$$。
>
> 返回将每个人都飞到某座城市的最低费用，要求每个城市都有 N 人抵达。
>

> **Example 1:**
>
> 输入：[[10,20],[30,200],[400,50],[30,20]]
> 输出：110
> 解释：
> 第一个人去 A 市，费用为 10。
> 第二个人去 A 市，费用为 30。
> 第三个人去 B 市，费用为 50。
> 第四个人去 B 市，费用为 20。
>
> 最低总费用为 10 + 30 + 50 + 20 = 110，每个城市都有一半的人在面试。
>

> **Note:**
>
> - `1 <= costs.length <= 100`
> - `costs.length` 为偶数
> - `1 <= costs[i][0], costs[i][1] <= 1000`

### Apporach 1: 深度优先搜索

- 按深度优先搜索的顺序计算范围和。记当前子树根节点为 \textit{root}root，分以下四种情况讨论：

  - $$\textit{root}$$ 节点为空

    返回 0。

  - $$\textit{root}$$ 节点的值大于 $$\textit{high}$$

    由于二叉搜索树右子树上所有节点的值均大于根节点的值，即均大于 $$\textit{high}$$，故无需考虑右子树，返回左子树的范围和。

  - $$\textit{root}$$ 节点的值小于$$ \textit{low}$$

    由于二叉搜索树左子树上所有节点的值均小于根节点的值，即均小于 $$\textit{low}$$，故无需考虑左子树，返回右子树的范围和。
  
  - $$\textit{root}$$ 节点的值在 $$[\textit{low},\textit{high}]$$ 范围内

    此时应返回 $$\textit{root}$$ 节点的值、左子树的范围和、右子树的范围和这三者之和。
  


```python
class Solution:
    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:
        if not root:
            return 0
        if root.val > high:
            return self.rangeSumBST(root.left, low, high)
        if root.val < low:
            return self.rangeSumBST(root.right, low, high)
        return root.val + self.rangeSumBST(root.left, low, high) + self.rangeSumBST(root.right, low, high)
```

**复杂度分析**

- 时间复杂度：O(n)，其中 n*n* 是二叉搜索树的节点数。
- 空间复杂度：O(n)。空间复杂度主要取决于栈空间的开销。



### Apporach 2: 广度优先搜索

使用广度优先搜索的方法，用一个队列 q*q* 存储需要计算的节点。每次取出队首节点时，若节点为空则跳过该节点，否则按方法一中给出的大小关系来决定加入队列的子节点。


```python
class Solution:
    def rangeSumBST(self, root: TreeNode, low: int, high: int) -> int:
        total = 0
        q = collections.deque([root])
        while q:
            node = q.popleft()
            if not node:
                continue
            if node.val > high:
                q.append(node.left)
            elif node.val < low:
                q.append(node.right)
            else:
                total += node.val
                q.append(node.left)
                q.append(node.right)

        return total
```

**复杂度分析**

- 时间复杂度：O(n)，其中 n*n* 是二叉搜索树的节点数。
- 空间复杂度：O(n)。空间复杂度主要取决于队列的空间。







