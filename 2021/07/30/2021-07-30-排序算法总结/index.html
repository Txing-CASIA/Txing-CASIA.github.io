<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="泛用人形决战型机器人博士">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
          排序算法总结 - 伽蓝之堂 | Txing Blog
        
    </title>

    <link rel="canonical" href="https://txing-casia.github.io/2021/07/30/2021-07-30-排序算法总结/">

    <!-- Bootstrap Core CSS -->
    
<link rel="stylesheet" href="/css/bootstrap.min.css">


    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/hux-blog.min.css">


    <!-- Pygments Highlight CSS -->
    
<link rel="stylesheet" href="/css/highlight.css">


    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
<meta name="generator" content="Hexo 6.3.0"></head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Txing</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    
<!-- Image to hack wechat -->
<!-- <img src="https://txing-casia.github.io/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="{{ site.baseurl }}/{% if page.header-img %}{{ page.header-img }}{% else %}{{ site.header-img }}{% endif %}" width="0" height="0"> -->

<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        background-image: url('img/post-bg-py.jpg')
    }
</style>
<header class="intro-header" >
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                          <a class="tag" href="/tags/#Algorithm" title="Algorithm">Algorithm</a>
                        
                          <a class="tag" href="/tags/#Code Tips" title="Code Tips">Code Tips</a>
                        
                    </div>
                    <h1>排序算法总结</h1>
                    <h2 class="subheading"></h2>
                    <span class="meta">
                        Posted by Txing on
                        2021-07-30
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <h1 id="排序算法总结"><a href="#排序算法总结" class="headerlink" title="排序算法总结"></a>排序算法总结</h1><h2 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h2><h4 id="1-1-方法描述："><a href="#1-1-方法描述：" class="headerlink" title="1.1 方法描述："></a>1.1 方法描述：</h4><p>从数组A第一个元素开始，两两比较相邻元素的大小，如果前面的大于后面的，则把两元素交换位置，这样一次遍历后，最末位的元素就是最大的元素，重复上述过程n次，排序完成。</p>
<p><strong>简述：把相邻元素两两对比，一个一个移动到正确位置。</strong></p>
<p><img src="https://raw.githubusercontent.com/txing-casia/txing-casia.github.io/master/img/20210729-2.gif"></p>
<h4 id="1-2-代码实现："><a href="#1-2-代码实现：" class="headerlink" title="1.2 代码实现："></a>1.2 代码实现：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 冒泡排序</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bubbleSort</span>(<span class="params">alist</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(alist)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, i):</span><br><span class="line">            <span class="keyword">if</span> alist[j] &gt; alist[j+<span class="number">1</span>]:</span><br><span class="line">                alist[j], alist[j+<span class="number">1</span>] = alist[j+<span class="number">1</span>], alist[j]</span><br><span class="line">    <span class="keyword">return</span> alist</span><br></pre></td></tr></table></figure>

<h4 id="1-3-算法优化："><a href="#1-3-算法优化：" class="headerlink" title="1.3 算法优化："></a>1.3 算法优化：</h4><p>因为冒泡排序必须要在最终位置找到之前不断交换数据项，所以它经常被认为是最低效的排 序方法。这些 “浪费式” 的交换操作消耗了许多时间。但是，由于冒泡排序要遍历整个未排好的 部分，它可以做一些大多数排序方法做不到的事。尤其是如果在整个排序过程中没有交换，我们就可断定列表已经排好。因此可改良冒泡排序，使其在已知列表排好的情况下提前结束。这就是说，如果一个列表只需要几次遍历就可排好，冒泡排序就占有优势：它可以在发现列表已排好时立刻结束。</p>
<p><strong>优化代码：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 冒泡排序</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bubbleSort</span>(<span class="params">alist</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(alist)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        exchange = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, i):</span><br><span class="line">            <span class="keyword">if</span> alist[j] &gt; alist[j+<span class="number">1</span>]:</span><br><span class="line">                alist[j], alist[j+<span class="number">1</span>] = alist[j+<span class="number">1</span>], alist[j]</span><br><span class="line">                exchange = <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 如果发现整个排序过程中没有交换，提前结束</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> exchange:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> alist</span><br></pre></td></tr></table></figure>





<h2 id="2-选择排序"><a href="#2-选择排序" class="headerlink" title="2. 选择排序"></a>2. 选择排序</h2><h4 id="2-1-方法描述："><a href="#2-1-方法描述：" class="headerlink" title="2.1 方法描述："></a>2.1 方法描述：</h4><p>​		描述1：选择排序提高了冒泡排序的性能，它每遍历一次列表只交换一次数据，即进行一次遍历时找到最大的项，完成遍历后，再把它换到正确的位置。和冒泡排序一样，第一次遍历后，最大的数据项就已归位，第二次遍历使次大项归位。这个过程持续进行，一共需要 n-1 次遍历来排好 n 个数据，因为最后一个数据必须在第 n-1 次遍历之后才能归位。</p>
<p>​		描述2：初始时在序列中找到最小（大）元素，放到序列的起始位置作为已排序序列；然后，再从剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<p>　　注意选择排序与冒泡排序的区别：冒泡排序通过依次交换相邻两个顺序不合法的元素位置，从而将当前最小（大）元素放到合适的位置；而选择排序每遍历一次都记住了当前最小（大）元素的位置，最后仅需一次交换操作即可将其放到合适的位置。</p>
<p>​		<strong>简述：以一个元素为基，遍历数组寻找比它更小的值，找到后按顺序排到正确位置。</strong></p>
<p><img src="https://raw.githubusercontent.com/txing-casia/txing-casia.github.io/master/img/20210729-3.gif"></p>
<h4 id="2-2-代码实现："><a href="#2-2-代码实现：" class="headerlink" title="2.2 代码实现："></a>2.2 代码实现：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选择排序</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">selectionSort</span>(<span class="params">alist</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(alist)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 寻找[i,n]区间里的最小值</span></span><br><span class="line">        min_index = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> alist[j] &lt; alist[min_index]:</span><br><span class="line">                min_index = j</span><br><span class="line">        alist[i], alist[min_index] = alist[min_index], alist[i]</span><br><span class="line">    <span class="keyword">return</span> alist</span><br></pre></td></tr></table></figure>



<h2 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3. 插入排序"></a>3. 插入排序</h2><h4 id="3-1-方法描述："><a href="#3-1-方法描述：" class="headerlink" title="3.1 方法描述："></a>3.1 方法描述：</h4><p>插入排序的算法复杂度仍然是$$O(n^2)$$，但其工作原理稍有不同。它总是<strong>保持一个位置靠前的已排好的子表</strong>，然后每一个新的数据项被 “插入” 到前边的子表里，排好的子表增加一项。我们认为只含有一个数据项的列表是已经排好的。每排后面一个数据（从 1 开始到 n-1），这个的数据会和已排好子表中的数据比较。比较时，我们把之前已经排好的列表中比这个数据大的移到它的右边。当子表数据小于当前数据，或者当前数据已经和子表的所有数据比较了时，就可以在此处插入当前数据项。</p>
<p><img src="https://raw.githubusercontent.com/txing-casia/txing-casia.github.io/master/img/20210729-1.gif"></p>
<h4 id="3-2-代码实现："><a href="#3-2-代码实现：" class="headerlink" title="3.2 代码实现："></a>3.2 代码实现：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 插入排序</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insertionSort</span>(<span class="params">alist</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(alist)):</span><br><span class="line">        currentvalue=alist[i]</span><br><span class="line">        position=i</span><br><span class="line">        <span class="keyword">while</span> alist[position-<span class="number">1</span>]&gt;currentvalue <span class="keyword">and</span> position&gt;<span class="number">0</span>:</span><br><span class="line">            alist[position]=alist[position-<span class="number">1</span>]</span><br><span class="line">            position=position-<span class="number">1</span></span><br><span class="line">        alist[position]=currentvalue</span><br><span class="line">    <span class="keyword">return</span> alist</span><br></pre></td></tr></table></figure>

<p>注意，这里在用 Python 实现的时候需要注意，第一次我采用的是下面的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 插入排序</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insertionSort</span>(<span class="params">blist</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(blist)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        <span class="comment"># 寻找a[i]合适的插入位置</span></span><br><span class="line">        temp = blist[i]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> (temp &lt; blist[j-<span class="number">1</span>]):</span><br><span class="line">                blist[j] = blist[j-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        blist[j-<span class="number">1</span>] = temp</span><br><span class="line">    <span class="keyword">return</span> blist</span><br></pre></td></tr></table></figure>

<p>在测试性能的时候发现，当数列的逐渐变大的时候，运行时间并不是按照$$n^2$$的速度增长，后来分析发现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, <span class="number">0</span>, -<span class="number">1</span>):</span><br></pre></td></tr></table></figure>

<p>这行代码在数列很大的时候，会不听的新建列表，这回损害性能，这是非算法思想因素的影响，但是需要注意一下。可以用<code>while</code>和一个列表代替。</p>
<h2 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4. 希尔排序"></a>4. 希尔排序</h2><h4 id="4-1-方法描述："><a href="#4-1-方法描述：" class="headerlink" title="4.1 方法描述："></a>4.1 方法描述：</h4><p>希尔排序有时又叫做 “缩小间隔排序”，它以插入排序为基础，将原来要排序的列表划分为一些子列表，再对每一个子列表执行插入排序，从而实现对插入排序性能的改进。划分子列的特定方法是希尔排序的关键。我们并不是将原始列表分成含有连续元素的子列，而是确定一个划分列表的增量 “i”，这个i更准确地说，是划分的间隔。然后把每间隔为i的所有元素选出来组成子列表，然后对每个子序列进行插入排序，最后当 i&#x3D;1 时，对整体进行一次直接插入排序。</p>
<p><img src="https://raw.githubusercontent.com/txing-casia/txing-casia.github.io/master/img/20210729-4.gif"></p>
<p><img src="https://raw.githubusercontent.com/txing-casia/txing-casia.github.io/master/img/20210729-5.png"></p>
<h4 id="4-2-代码实现"><a href="#4-2-代码实现" class="headerlink" title="4.2 代码实现"></a>4.2 代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 希尔排序</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shellSort</span>(<span class="params">alist</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(alist)</span><br><span class="line">    gap = n // <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(gap):</span><br><span class="line">            gapInsetionSort(alist, i, gap)</span><br><span class="line">        gap = gap // <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> alist</span><br><span class="line"></span><br><span class="line"><span class="comment"># # start子数列开始的起始位置， gap表示间隔</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gapInsetionSort</span>(<span class="params">alist,startpos,gap</span>):</span><br><span class="line">    <span class="comment">#希尔排序的辅助函数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startpos+gap,<span class="built_in">len</span>(alist),gap):</span><br><span class="line">        position=i</span><br><span class="line">        currentvalue=alist[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> position&gt;startpos <span class="keyword">and</span> alist[position-gap]&gt;currentvalue:</span><br><span class="line">            alist[position]=alist[position-gap]</span><br><span class="line">            position=position-gap</span><br><span class="line">        alist[position]=currentvalue</span><br></pre></td></tr></table></figure>



<h2 id="5-并归排序"><a href="#5-并归排序" class="headerlink" title="5. 并归排序"></a>5. 并归排序</h2><h4 id="5-1-方法描述："><a href="#5-1-方法描述：" class="headerlink" title="5.1 方法描述："></a>5.1 方法描述：</h4><p>归并排序是一种递归算法，它持续地将一个列表分成两半。如果列表是空的或者只有一个元素，那么根据定义，它就被排序好了（最基本的情况）。如果列表里的元素超过一个，我们就把列表拆分，然后分别对两个部分调用递归排序。一旦这两个部分被排序好了，然后就可以对这两部分数列进行归并了。归并是这样一个过程：把两个排序好了的列表结合在一起组合成一个单一的有序的新列表。有自顶向下（递归法）和自底向上的两种实现方法。</p>
<p><img src="https://raw.githubusercontent.com/txing-casia/txing-casia.github.io/master/img/20210730-1.png"></p>
<h4 id="5-2-代码实现"><a href="#5-2-代码实现" class="headerlink" title="5.2 代码实现"></a>5.2 代码实现</h4><p><strong>自顶向下（递归法）方法实现</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 归并排序</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mergeSort</span>(<span class="params">alist</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(alist)</span><br><span class="line">    __mergeSort(alist, <span class="number">0</span>, n-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> alist</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对arr[l...r]的范围进行排序</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__mergeSort</span>(<span class="params">alist, start, end</span>):</span><br><span class="line">    <span class="comment">#当数列的大小比较小的时候，数列近乎有序的概率较大</span></span><br><span class="line">    <span class="keyword">if</span> (end-start &lt;= <span class="number">15</span>):</span><br><span class="line">        insertionSortHelp(alist, start, end)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> start &gt;= end:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 存在风险，start+end可能越界</span></span><br><span class="line">    mid = (start + end) // <span class="number">2</span></span><br><span class="line">    <span class="comment"># mid = start + (end - start) // 2</span></span><br><span class="line">    __mergeSort(alist, start, mid)</span><br><span class="line">    __mergeSort(alist, mid + <span class="number">1</span>, end)</span><br><span class="line">    <span class="comment">#优化</span></span><br><span class="line">    <span class="keyword">if</span> alist[mid] &gt; alist[mid+<span class="number">1</span>]:</span><br><span class="line">        merge(alist, start, mid, end)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并有序数列alist[start....mid] 和 alist[mid+1...end]，使之成为有序数列</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">alist, start, mid, end</span>):</span><br><span class="line">    <span class="comment"># 复制一份</span></span><br><span class="line">    blist = alist[start:end+<span class="number">1</span>]</span><br><span class="line">    l = start</span><br><span class="line">    k = mid + <span class="number">1</span></span><br><span class="line">    pos = start</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> pos &lt;= end:</span><br><span class="line">        <span class="keyword">if</span> (l &gt; mid):</span><br><span class="line">            alist[pos] = blist[k-start]</span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> (k &gt; end):</span><br><span class="line">            alist[pos] = blist[l-start]</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> blist[l-start] &lt;= blist[k-start]:</span><br><span class="line">            alist[pos] = blist[l-start]</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            alist[pos] = blist[k-start]</span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">        pos += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insertionSortHelp</span>(<span class="params">alist,l, r</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l+<span class="number">1</span>,r+<span class="number">1</span>):</span><br><span class="line">        currentvalue=alist[i]</span><br><span class="line">        position=i</span><br><span class="line">        <span class="keyword">while</span> alist[position-<span class="number">1</span>]&gt;currentvalue <span class="keyword">and</span> position&gt;l:</span><br><span class="line">            alist[position]=alist[position-<span class="number">1</span>]</span><br><span class="line">            position=position-<span class="number">1</span></span><br><span class="line">        alist[position]=currentvalue</span><br><span class="line">    <span class="keyword">return</span> alist</span><br></pre></td></tr></table></figure>

<p>注意：这里进行小的优化，当数列的长度小于等于15的时候，我们一般认为数列此时基本有序，这时候采用直接插入排序非常快。</p>
<p><strong>自底向上（非递归法）方法</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自底向上的归并算法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mergeBU</span>(<span class="params">alist</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(alist)</span><br><span class="line">    <span class="comment">#表示归并的大小</span></span><br><span class="line">    size = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> size &lt;= n:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n-size, size+size):</span><br><span class="line">            merge(alist, i, i+size-<span class="number">1</span>, <span class="built_in">min</span>(i+size+size-<span class="number">1</span>, n-<span class="number">1</span>))</span><br><span class="line">        size += size</span><br><span class="line">    <span class="keyword">return</span> alist</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并有序数列alist[start....mid] 和 alist[mid+1...end]，使之成为有序数列</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">alist, start, mid, end</span>):</span><br><span class="line">    <span class="comment"># 复制一份</span></span><br><span class="line">    blist = alist[start:end+<span class="number">1</span>]</span><br><span class="line">    l = start</span><br><span class="line">    k = mid + <span class="number">1</span></span><br><span class="line">    pos = start</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> pos &lt;= end:</span><br><span class="line">        <span class="keyword">if</span> (l &gt; mid):</span><br><span class="line">            alist[pos] = blist[k-start]</span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> (k &gt; end):</span><br><span class="line">            alist[pos] = blist[l-start]</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> blist[l-start] &lt;= blist[k-start]:</span><br><span class="line">            alist[pos] = blist[l-start]</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            alist[pos] = blist[k-start]</span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">        pos += <span class="number">1</span></span><br></pre></td></tr></table></figure>



<h2 id="6-快速排序"><a href="#6-快速排序" class="headerlink" title="6. 快速排序"></a>6. 快速排序</h2><h4 id="6-1-方法描述："><a href="#6-1-方法描述：" class="headerlink" title="6.1 方法描述："></a>6.1 方法描述：</h4><p>快速排序由 C. A. R. Hoare 在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>
<ul>
<li>从数列中挑出一个元素，称为”基准”（pivot）。</li>
<li>重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</li>
<li>递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/txing-casia/txing-casia.github.io/master/img/20210730-1.png"></p>
<h4 id="6-2-代码实现"><a href="#6-2-代码实现" class="headerlink" title="6.2 代码实现"></a>6.2 代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__quickSort</span>(<span class="params">alist, l, r</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment">#当数列的大小比较小的时候，数列近乎有序的概率较大</span></span><br><span class="line">    <span class="comment"># if (r - l &lt;= 15):</span></span><br><span class="line">    <span class="comment">#     insertionSortHelp(alist, l, r)</span></span><br><span class="line">    <span class="comment">#     return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> l &gt;= r:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># p = partition(alist, l, r)</span></span><br><span class="line">    p = partitionQS(alist, l, r)</span><br><span class="line"></span><br><span class="line">    __quickSort(alist, l, p-<span class="number">1</span>)</span><br><span class="line">    __quickSort(alist, p+<span class="number">1</span>, r)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在alist[l...r]中寻找j,使得alist[l...j] &lt;= alist[l], alist[j+1...r] &gt;alist[l]</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">alist, l, r</span>):</span><br><span class="line">    pos = randint(l, r)</span><br><span class="line">    alist[pos], alist[l] = alist[l], alist[pos]</span><br><span class="line">    v = alist[l]</span><br><span class="line">    <span class="comment"># v = alist[l]</span></span><br><span class="line">    j = l</span><br><span class="line">    i = l + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= r:</span><br><span class="line">        <span class="keyword">if</span> alist[i] &lt;= v:</span><br><span class="line">            alist[j+<span class="number">1</span>],alist[i] = alist[i],alist[j+<span class="number">1</span>]</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    alist[l], alist[j] = alist[j], alist[l]</span><br><span class="line">    <span class="keyword">return</span> j</span><br></pre></td></tr></table></figure>

<p><strong>快速排序一些可以优化的点</strong></p>
<ul>
<li>当数列近乎有序的时，由于每次选取的都是第一个数，所以造成数列分割的极其不等，此时快排蜕化成$$O(n^2)$$的算法， 此时只要随机选取基准点即可</li>
<li>当数列中包含大量的重复元素的时候，这一版的代码也会造成”分割不等“的问题，此时需要将重复元素均匀的分散的自数列旁</li>
<li>使用三路快排</li>
</ul>


                <hr>

                

                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/2021/08/08/2021-08-08-Python中的链表和二叉树/" data-toggle="tooltip" data-placement="top" title="Python中的链表和二叉树">&larr; Previous Post</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/2021/07/22/2021-07-22-Q994-腐烂的橘子-中等-深度and宽度优先搜索/" data-toggle="tooltip" data-placement="top" title="Q994-腐烂的橘子-中等-深度/宽度优先搜索">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                

                

            </div>
    <!-- Side Catalog Container -->
        

    <!-- Sidebar Container -->

            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#Algorithm" title="Algorithm">Algorithm</a>
                        
                          <a class="tag" href="/tags/#Code Tips" title="Code Tips">Code Tips</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                        <li><a href="https://blog.uomi.moe" target="_blank">驱逐舰患者</a></li>
                    
                        <li><a href="https://m.mepai.me/photographyer/u_5a68085ba15aa.html?tdsourcetag=s_pctim_aiomsg" target="_blank">隐之-INF</a></li>
                    
                </ul>
                
            </div>

        </div>
    </div>
</article>









    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                

                

                

                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Txing 2023 
                    <br>
                    Theme by <a target="_blank" rel="noopener" href="http://huangxuan.me">Hux</a> 
                    <span style="display: inline-block; margin: 0 5px;">
                        <i class="fa fa-heart"></i>
                    </span> 
                    Ported by <a target="_blank" rel="noopener" href="http://blog.kaijun.rocks">Kaijun</a> | 
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="91px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=kaijun&repo=hexo-theme-huxblog&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->

<script src="/js/jquery.min.js"></script>


<!-- Bootstrap Core JavaScript -->

<script src="/js/bootstrap.min.js"></script>


<!-- Custom Theme JavaScript -->

<script src="/js/hux-blog.min.js"></script>



<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://txing-casia.github.io/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->




<!-- Baidu Tongji -->


<!-- Side Catalog -->





<!-- Image to hack wechat -->
<img src="https://txing-casia.github.io/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
